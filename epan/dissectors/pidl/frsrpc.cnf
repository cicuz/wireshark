NOEMIT CommPktChunkCtr
NOEMIT CommPktChangeOrderCommand.file_name

ETT_FIELD ett_ChunkCtr
HF_FIELD hf_frsrpc_CommPktChangeOrderCommand_file_name "File Name" "frsrpc.CommPktChangeOrderCommand.file_name" FT_STRING BASE_NONE NULL 0 "" "" ""
HF_FIELD hf_CommPktChunk "Chunk" "frsrpc.chunk.ctr.chunk" FT_NONE BASE_NONE NULL 0 "" "" ""

MANUAL frsrpc_dissect_struct_frsrpc_CommPktChunkCtr
MANUAL frsrpc_dissect_element_CommPktChangeOrderCommand_file_name

CODE START
static int
frsrpc_dissect_element_CommPktChangeOrderCommand_file_name(tvbuff_t *tvb _U_, int offset _U_, packet_info *pinfo _U_, proto_tree *tree _U_, guint8 *drep _U_)
{
	dcerpc_info *di = pinfo->private_data;
	int conformant = di->conformant_run;

	if (!conformant) {
		guint32 soffset = dissect_null_term_wstring(tvb, offset, pinfo, tree, drep, hf_frsrpc_CommPktChangeOrderCommand_file_name, 0);
		/* The difference has to be 4 due to the uint16 of the length  + null terminator utf16*/
		DISSECTOR_ASSERT(soffset - offset < 261);
		offset += 261;
	}

	return offset;
}

static int
frsrpc_dissect_struct_frsrpc_CommPktChunkCtr(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint8 *drep _U_, int hf_index, guint32 param _U_)
{
	guint32 nb_chunk = 0;
	guint32 remaining = tvb_length_remaining(tvb, offset);
	dcerpc_info *di = pinfo->private_data;
	int align_status = di->no_align;

	if (remaining > 0) {
		proto_item *item = proto_tree_add_item(tree, hf_index, tvb, offset, -1, TRUE);
		proto_tree *subtree = proto_item_add_subtree(item, ett_ChunkCtr);
		di->no_align = 1;
		for(nb_chunk = 0; remaining > 0; nb_chunk++) {
			offset = frsrpc_dissect_struct_CommPktChunk(tvb, offset, pinfo, subtree, drep, hf_CommPktChunk, param);
			remaining = tvb_length_remaining(tvb, offset);
		}
		di->no_align = align_status;
	}
	return offset;
}

CODE END

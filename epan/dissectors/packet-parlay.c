/* packet-parlay.c
 *
 * $Id$
 *
 * Routines for IDL dissection
 *
 * Autogenerated from idl2wrs
 * Copyright 2001 Frank Singleton <frank.singleton@ericsson.com>
 */


/*
 * Wireshark - Network traffic analyzer
 * By Gerald Combs
 * Copyright 1999 - 2012 Gerald Combs
 */

static int hf_operationrequest = -1;/* Request_Operation field */


/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <gmodule.h>

#include <string.h>
#include <glib.h>
#include <epan/packet.h>
#include <epan/proto.h>
#include <epan/dissectors/packet-giop.h>
#include <epan/expert.h>

#ifdef _MSC_VER
/* disable warning: "unreference local variable" */
#pragma warning(disable:4101)
#endif


static proto_tree *start_dissecting(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset);



/* Struct prototype declaration Start */


/* Struct = IDL:org/csapi/TpAddress:1.0 */
static void decode_org_csapi_TpAddress_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpAddressRange:1.0 */
static void decode_org_csapi_TpAddressRange_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpCAIElements:1.0 */
static void decode_org_csapi_TpCAIElements_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpChargeAdviceInfo:1.0 */
static void decode_org_csapi_TpChargeAdviceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpChargePerTime:1.0 */
static void decode_org_csapi_TpChargePerTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpAoCInfo:1.0 */
static void decode_org_csapi_TpAoCInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpTimeInterval:1.0 */
static void decode_org_csapi_TpTimeInterval_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpStructuredAttributeValue:1.0 */
static void decode_org_csapi_TpStructuredAttributeValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/TpAttribute:1.0 */
static void decode_org_csapi_TpAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpFaultStats:1.0 */
static void decode_org_csapi_fw_TpFaultStats_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpFaultStatsRecord:1.0 */
static void decode_org_csapi_fw_TpFaultStatsRecord_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpLoadPolicy:1.0 */
static void decode_org_csapi_fw_TpLoadPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpLoadStatisticData:1.0 */
static void decode_org_csapi_fw_TpLoadStatisticData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpLoadThreshold:1.0 */
static void decode_org_csapi_fw_TpLoadThreshold_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpLoadInitVal:1.0 */
static void decode_org_csapi_fw_TpLoadInitVal_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpProperty:1.0 */
static void decode_org_csapi_fw_TpProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpClientAppDescription:1.0 */
static void decode_org_csapi_fw_TpClientAppDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpEntOp:1.0 */
static void decode_org_csapi_fw_TpEntOp_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpSag:1.0 */
static void decode_org_csapi_fw_TpSag_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProperty:1.0 */
static void decode_org_csapi_fw_TpServiceProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceDescription:1.0 */
static void decode_org_csapi_fw_TpServiceDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpService:1.0 */
static void decode_org_csapi_fw_TpService_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProfileDescription:1.0 */
static void decode_org_csapi_fw_TpServiceProfileDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypeProperty:1.0 */
static void decode_org_csapi_fw_TpServiceTypeProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypeDescription:1.0 */
static void decode_org_csapi_fw_TpServiceTypeDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpSignatureAndServiceMgr:1.0 */
static void decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpPerson:1.0 */
static void decode_org_csapi_fw_TpPerson_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceContractDescription:1.0 */
static void decode_org_csapi_fw_TpServiceContractDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpLoadStatistic:1.0 */
static void decode_org_csapi_fw_TpLoadStatistic_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceContract:1.0 */
static void decode_org_csapi_fw_TpServiceContract_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceProfile:1.0 */
static void decode_org_csapi_fw_TpServiceProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpAuthDomain:1.0 */
static void decode_org_csapi_fw_TpAuthDomain_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpSagProfilePair:1.0 */
static void decode_org_csapi_fw_TpSagProfilePair_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpAddSagMembersConflict:1.0 */
static void decode_org_csapi_fw_TpAddSagMembersConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpAssignSagToServiceProfileConflict:1.0 */
static void decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpServiceTypePropertyValue:1.0 */
static void decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpFwMigrationServiceAvailableInfo:1.0 */
static void decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/fw/TpFwAgreementInfo:1.0 */
static void decode_org_csapi_fw_TpFwAgreementInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIMessageCriteria:1.0 */
static void decode_org_csapi_ui_TpUIMessageCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventInfo:1.0 */
static void decode_org_csapi_ui_TpUIEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventCriteria:1.0 */
static void decode_org_csapi_ui_TpUIEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventCriteriaResult:1.0 */
static void decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIEventNotificationInfo:1.0 */
static void decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIRecognitionProperty:1.0 */
static void decode_org_csapi_ui_TpUIRecognitionProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIRecognitionCriteria:1.0 */
static void decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUICollectCriteria:1.0 */
static void decode_org_csapi_ui_TpUICollectCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIWordOverride:1.0 */
static void decode_org_csapi_ui_TpUIWordOverride_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUISynthesisInfoData:1.0 */
static void decode_org_csapi_ui_TpUISynthesisInfoData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallError:1.0 */
static void decode_org_csapi_cc_TpCallError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallEndedReport:1.0 */
static void decode_org_csapi_cc_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallInfoReport:1.0 */
static void decode_org_csapi_cc_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallServiceCode:1.0 */
static void decode_org_csapi_cc_TpCallServiceCode_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallTreatment:1.0 */
static void decode_org_csapi_cc_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallChargePlan:1.0 */
static void decode_org_csapi_cc_TpCallChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteria:1.0 */
static void decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteriaResult:1.0 */
static void decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReleaseCause:1.0 */
static void decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReport:1.0 */
static void decode_org_csapi_cc_gccs_TpCallReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallReportRequest:1.0 */
static void decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEventInfo:1.0 */
static void decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallEndedReport:1.0 */
static void decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallInfoReport:1.0 */
static void decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallTreatment:1.0 */
static void decode_org_csapi_cc_gccs_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/gccs/TpCallIdentifier:1.0 */
static void decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationScope:1.0 */
static void decode_org_csapi_cc_TpCallNotificationScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationReportScope:1.0 */
static void decode_org_csapi_cc_TpCallNotificationReportScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallEventRequest:1.0 */
static void decode_org_csapi_cc_TpCallEventRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationRequest:1.0 */
static void decode_org_csapi_cc_TpCallNotificationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpNotificationRequested:1.0 */
static void decode_org_csapi_cc_TpNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegConnectionProperties:1.0 */
static void decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallEventInfo:1.0 */
static void decode_org_csapi_cc_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpNotificationRequestedSetEntry:1.0 */
static void decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCarrier:1.0 */
static void decode_org_csapi_cc_TpCarrier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallNotificationInfo:1.0 */
static void decode_org_csapi_cc_TpCallNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegInfoReport:1.0 */
static void decode_org_csapi_cc_TpCallLegInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/TpCallLegProperty:1.0 */
static void decode_org_csapi_cc_TpCallLegProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpMultiPartyCallIdentifier:1.0 */
static void decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpCallLegIdentifier:1.0 */
static void decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mpccs/TpAppCallLegCallBack:1.0 */
static void decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpCallSuperviseVolume:1.0 */
static void decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStreamRequest:1.0 */
static void decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStream:1.0 */
static void decode_org_csapi_cc_mmccs_TpMediaStream_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpNotificationMediaRequest:1.0 */
static void decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMediaNotificationRequested:1.0 */
static void decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallIdentifier:1.0 */
static void decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallLegIdentifier:1.0 */
static void decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallLegCallBack:1.0 */
static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpMonoMediaConfPolicy:1.0 */
static void decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpJoinEventInfo:1.0 */
static void decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchCriteria:1.0 */
static void decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchResult:1.0 */
static void decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpMultiMediaConfPolicy:1.0 */
static void decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpResourceReservation:1.0 */
static void decode_org_csapi_cc_cccs_TpResourceReservation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpConfCallIdentifier:1.0 */
static void decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cc/cccs/TpSubConfCallIdentifier:1.0 */
static void decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUIIdentifier:1.0 */
static void decode_org_csapi_ui_TpUIIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/ui/TpUICallIdentifier:1.0 */
static void decode_org_csapi_ui_TpUICallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpLocationResponseTime:1.0 */
static void decode_org_csapi_mm_TpLocationResponseTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpLocationTrigger:1.0 */
static void decode_org_csapi_mm_TpLocationTrigger_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpLocationRequest:1.0 */
static void decode_org_csapi_mm_TpLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpGeographicalPosition:1.0 */
static void decode_org_csapi_mm_TpGeographicalPosition_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpMobilityStopAssignmentData:1.0 */
static void decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUlExtendedData:1.0 */
static void decode_org_csapi_mm_TpUlExtendedData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocation:1.0 */
static void decode_org_csapi_mm_TpUserLocation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationExtended:1.0 */
static void decode_org_csapi_mm_TpUserLocationExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpLocationTriggerCamel:1.0 */
static void decode_org_csapi_mm_TpLocationTriggerCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationCamel:1.0 */
static void decode_org_csapi_mm_TpUserLocationCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationEmergencyRequest:1.0 */
static void decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserLocationEmergency:1.0 */
static void decode_org_csapi_mm_TpUserLocationEmergency_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatus:1.0 */
static void decode_org_csapi_mm_TpUserStatus_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequest:1.0 */
static void decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequestSetEntry:1.0 */
static void decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequest:1.0 */
static void decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequestSetEntry:1.0 */
static void decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequest:1.0 */
static void decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequestSetEntry:1.0 */
static void decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatusIndicatorExtended:1.0 */
static void decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserInfo:1.0 */
static void decode_org_csapi_mm_TpUserInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpNetworkStatusIndicator:1.0 */
static void decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpUserStatusExtended:1.0 */
static void decode_org_csapi_mm_TpUserStatusExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mm/TpBindingNotificationCriteria:1.0 */
static void decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilities:1.0 */
static void decode_org_csapi_termcap_TpTerminalCapabilities_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilityScope:1.0 */
static void decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpChargePerVolume:1.0 */
static void decode_org_csapi_dsc_TpChargePerVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionChargePlan:1.0 */
static void decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionError:1.0 */
static void decode_org_csapi_dsc_TpDataSessionError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteria:1.0 */
static void decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventInfo:1.0 */
static void decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReleaseCause:1.0 */
static void decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReport:1.0 */
static void decode_org_csapi_dsc_TpDataSessionReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionReportRequest:1.0 */
static void decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionSuperviseVolume:1.0 */
static void decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteriaResult:1.0 */
static void decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/dsc/TpDataSessionIdentifier:1.0 */
static void decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedInfo:1.0 */
static void decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedCriteria:1.0 */
static void decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/gms/TpMailboxIdentifier:1.0 */
static void decode_org_csapi_gms_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/gms/TpMailboxFolderIdentifier:1.0 */
static void decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimePeriod:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimeOfDay:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagString:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagString_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagMonth:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagInt:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagInt_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDir:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagDir_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDayOfWeek:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDateTime:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpLossDescriptor:1.0 */
static void decode_org_csapi_cm_TpLossDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpLoadDescriptor:1.0 */
static void decode_org_csapi_cm_TpLoadDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpJitterDescriptor:1.0 */
static void decode_org_csapi_cm_TpJitterDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpEndpoint:1.0 */
static void decode_org_csapi_cm_TpEndpoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpDelayDescriptor:1.0 */
static void decode_org_csapi_cm_TpDelayDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpNameDescrpTagExcessLoadAction:1.0 */
static void decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpValidityInfo:1.0 */
static void decode_org_csapi_cm_TpValidityInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpProvisionedQoSInfo:1.0 */
static void decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpPipeQoSInfo:1.0 */
static void decode_org_csapi_cm_TpPipeQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpDsCodepoint:1.0 */
static void decode_org_csapi_cm_TpDsCodepoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cm/TpIPSubnet:1.0 */
static void decode_org_csapi_cm_TpIPSubnet_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpBalanceInfo:1.0 */
static void decode_org_csapi_am_TpBalanceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventInfo:1.0 */
static void decode_org_csapi_am_TpChargingEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpBalance:1.0 */
static void decode_org_csapi_am_TpBalance_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpTransactionHistory:1.0 */
static void decode_org_csapi_am_TpTransactionHistory_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventCriteria:1.0 */
static void decode_org_csapi_am_TpChargingEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpChargingEventCriteriaResult:1.0 */
static void decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpBalanceExpiryDate:1.0 */
static void decode_org_csapi_am_TpBalanceExpiryDate_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/am/TpVoucher:1.0 */
static void decode_org_csapi_am_TpVoucher_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpMerchantAccountID:1.0 */
static void decode_org_csapi_cs_TpMerchantAccountID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpCorrelationID:1.0 */
static void decode_org_csapi_cs_TpCorrelationID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpAmount:1.0 */
static void decode_org_csapi_cs_TpAmount_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpChargingPrice:1.0 */
static void decode_org_csapi_cs_TpChargingPrice_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpVolume:1.0 */
static void decode_org_csapi_cs_TpVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpChargingSessionID:1.0 */
static void decode_org_csapi_cs_TpChargingSessionID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpPriceVolume:1.0 */
static void decode_org_csapi_cs_TpPriceVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpApplicationDescription:1.0 */
static void decode_org_csapi_cs_TpApplicationDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/cs/TpChargingParameter:1.0 */
static void decode_org_csapi_cs_TpChargingParameter_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyEvent:1.0 */
static void decode_org_csapi_policy_TpPolicyEvent_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyNameValue:1.0 */
static void decode_org_csapi_policy_TpPolicyNameValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyRecordType:1.0 */
static void decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyListType:1.0 */
static void decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyVar:1.0 */
static void decode_org_csapi_policy_TpPolicyVar_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyConditionListElement:1.0 */
static void decode_org_csapi_policy_TpPolicyConditionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/policy/TpPolicyActionListElement:1.0 */
static void decode_org_csapi_policy_TpPolicyActionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAttributeDef:1.0 */
static void decode_org_csapi_pam_TpPAMAttributeDef_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAttribute:1.0 */
static void decode_org_csapi_pam_TpPAMAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMPresenceData:1.0 */
static void decode_org_csapi_pam_TpPAMPresenceData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAvailabilityProfile:1.0 */
static void decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCommunicationContext:1.0 */
static void decode_org_csapi_pam_TpPAMCommunicationContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMContext:1.0 */
static void decode_org_csapi_pam_TpPAMContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAccessControlData:1.0 */
static void decode_org_csapi_pam_TpPAMAccessControlData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMICEventData:1.0 */
static void decode_org_csapi_pam_TpPAMICEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMICNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMICNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIDEventData:1.0 */
static void decode_org_csapi_pam_TpPAMIDEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIDNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMIDNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMGMCEventData:1.0 */
static void decode_org_csapi_pam_TpPAMGMCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMGMCNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACEventData:1.0 */
static void decode_org_csapi_pam_TpPAMACEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMACNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMADEventData:1.0 */
static void decode_org_csapi_pam_TpPAMADEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMADNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMADNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAAEventData:1.0 */
static void decode_org_csapi_pam_TpPAMAAEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAANotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMAANotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAUEventData:1.0 */
static void decode_org_csapi_pam_TpPAMAUEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAUNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMAUNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCCEventData:1.0 */
static void decode_org_csapi_pam_TpPAMCCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMCCNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMCCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACPSEventData:1.0 */
static void decode_org_csapi_pam_TpPAMACPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMACPSNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAPSEventData:1.0 */
static void decode_org_csapi_pam_TpPAMAPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAPSNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIPSEventData:1.0 */
static void decode_org_csapi_pam_TpPAMIPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMIPSNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAVCEventData:1.0 */
static void decode_org_csapi_pam_TpPAMAVCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMAVCNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMWCEventData:1.0 */
static void decode_org_csapi_pam_TpPAMWCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMWCNotificationData:1.0 */
static void decode_org_csapi_pam_TpPAMWCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/pam/TpPAMErrorInfo:1.0 */
static void decode_org_csapi_pam_TpPAMErrorInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMailboxIdentifier:1.0 */
static void decode_org_csapi_mmm_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMultiMediaMessagingIdentifier:1.0 */
static void decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpListMessagesCriteria:1.0 */
static void decode_org_csapi_mmm_TpListMessagesCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMailboxFolderStatusInformation:1.0 */
static void decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMessageDescription:1.0 */
static void decode_org_csapi_mmm_TpMessageDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpBodyPartDescription:1.0 */
static void decode_org_csapi_mmm_TpBodyPartDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpBodyPart:1.0 */
static void decode_org_csapi_mmm_TpBodyPart_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpGenericHeaderField:1.0 */
static void decode_org_csapi_mmm_TpGenericHeaderField_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMessageInfoPropertyError:1.0 */
static void decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedCriteria:1.0 */
static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedInfo:1.0 */
static void decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpQueryStatusReport:1.0 */
static void decode_org_csapi_mmm_TpQueryStatusReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpTerminatingAddressList:1.0 */
static void decode_org_csapi_mmm_TpTerminatingAddressList_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedCriteria:1.0 */
static void decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequested:1.0 */
static void decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequestedSetEntry:1.0 */
static void decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedInfo:1.0 */
static void decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Struct prototype declaration End */


/* Union prototype declaration Start */


/* Union = IDL:org/csapi/TpAoCOrder:1.0 */
static void decode_org_csapi_TpAoCOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/TpSimpleAttributeValue:1.0 */
static void decode_org_csapi_TpSimpleAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/TpAttributeValue:1.0 */
static void decode_org_csapi_TpAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpFwEventCriteria:1.0 */
static void decode_org_csapi_fw_TpFwEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0 */
static void decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpLoadStatisticInfo:1.0 */
static void decode_org_csapi_fw_TpLoadStatisticInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpDomainID:1.0 */
static void decode_org_csapi_fw_TpDomainID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0 */
static void decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/fw/TpFwEventInfo:1.0 */
static void decode_org_csapi_fw_TpFwEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/ui/TpUIVariableInfo:1.0 */
static void decode_org_csapi_ui_TpUIVariableInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/ui/TpUIInfo:1.0 */
static void decode_org_csapi_ui_TpUIInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0 */
static void decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0 */
static void decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0 */
static void decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0 */
static void decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0 */
static void decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0 */
static void decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0 */
static void decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0 */
static void decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0 */
static void decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/TpCallAppInfo:1.0 */
static void decode_org_csapi_cc_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0 */
static void decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0 */
static void decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0 */
static void decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cc/cccs/TpConfPolicy:1.0 */
static void decode_org_csapi_cc_cccs_TpConfPolicy_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/ui/TpUITargetObject:1.0 */
static void decode_org_csapi_ui_TpUITargetObject_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mm/TpBindingEntry:1.0 */
static void decode_org_csapi_mm_TpBindingEntry_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0 */
static void decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0 */
static void decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0 */
static void decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/gms/TpMessageInfoProperty:1.0 */
static void decode_org_csapi_gms_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/gms/TpMailboxInfoProperty:1.0 */
static void decode_org_csapi_gms_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/gms/TpMessagingEventInfo:1.0 */
static void decode_org_csapi_gms_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/gms/TpMessagingEventCriteria:1.0 */
static void decode_org_csapi_gms_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/gms/TpFolderInfoProperty:1.0 */
static void decode_org_csapi_gms_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cs/TpChargingParameterValue:1.0 */
static void decode_org_csapi_cs_TpChargingParameterValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/cs/TpAppInformation:1.0 */
static void decode_org_csapi_cs_TpAppInformation_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/policy/TpPolicyType:1.0 */
static void decode_org_csapi_policy_TpPolicyType_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/pam/TpPAMContextData:1.0 */
static void decode_org_csapi_pam_TpPAMContextData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/pam/TpPAMEventInfo:1.0 */
static void decode_org_csapi_pam_TpPAMEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/pam/TpPAMNotificationInfo:1.0 */
static void decode_org_csapi_pam_TpPAMNotificationInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/pam/TpPAMPreferenceData:1.0 */
static void decode_org_csapi_pam_TpPAMPreferenceData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpFolderInfoProperty:1.0 */
static void decode_org_csapi_mmm_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0 */
static void decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMessageInfoProperty:1.0 */
static void decode_org_csapi_mmm_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMessageHeaderField:1.0 */
static void decode_org_csapi_mmm_TpMessageHeaderField_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpDeliveryTime:1.0 */
static void decode_org_csapi_mmm_TpDeliveryTime_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMessageTreatment:1.0 */
static void decode_org_csapi_mmm_TpMessageTreatment_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0 */
static void decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union = IDL:org/csapi/mmm/TpMessagingEventInfo:1.0 */
static void decode_org_csapi_mmm_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_);


/* Union prototype declaration End */


/* Initialise the protocol and subtree pointers */

static int proto_parlay = -1;

static gint ett_parlay = -1;


/* Initialise the initial Alignment */

static guint32  boundary = GIOP_HEADER_SIZE;  /* initial value */



/* Initialise the Registered fields */

/* TODO - Use registered fields */

/*
 * IDL Attributes Start
 */


/*
 * IDL Attributes End
 */

/*
 * IDL Enums Start
 */

/*
 * Enum = IDL:org/csapi/TpAddressError:1.0
 */
static const value_string org_csapi_TpAddressError[] = {

   { 0, "P_ADDRESS_INVALID_UNDEFINED" },
   { 1, "P_ADDRESS_INVALID_MISSING" },
   { 2, "P_ADDRESS_INVALID_MISSING_ELEMENT" },
   { 3, "P_ADDRESS_INVALID_OUT_OF_RANGE" },
   { 4, "P_ADDRESS_INVALID_INCOMPLETE" },
   { 5, "P_ADDRESS_INVALID_CANNOT_DECODE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressPlan:1.0
 */
static const value_string org_csapi_TpAddressPlan[] = {

   { 0, "P_ADDRESS_PLAN_NOT_PRESENT" },
   { 1, "P_ADDRESS_PLAN_UNDEFINED" },
   { 2, "P_ADDRESS_PLAN_IP" },
   { 3, "P_ADDRESS_PLAN_MULTICAST" },
   { 4, "P_ADDRESS_PLAN_UNICAST" },
   { 5, "P_ADDRESS_PLAN_E164" },
   { 6, "P_ADDRESS_PLAN_AESA" },
   { 7, "P_ADDRESS_PLAN_URL" },
   { 8, "P_ADDRESS_PLAN_NSAP" },
   { 9, "P_ADDRESS_PLAN_SMTP" },
   { 10, "P_ADDRESS_PLAN_MSMAIL" },
   { 11, "P_ADDRESS_PLAN_X400" },
   { 12, "P_ADDRESS_PLAN_SIP" },
   { 13, "P_ADDRESS_PLAN_ANY" },
   { 14, "P_ADDRESS_PLAN_NATIONAL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressPresentation:1.0
 */
static const value_string org_csapi_TpAddressPresentation[] = {

   { 0, "P_ADDRESS_PRESENTATION_UNDEFINED" },
   { 1, "P_ADDRESS_PRESENTATION_ALLOWED" },
   { 2, "P_ADDRESS_PRESENTATION_RESTRICTED" },
   { 3, "P_ADDRESS_PRESENTATION_ADDRESS_NOT_AVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAddressScreening:1.0
 */
static const value_string org_csapi_TpAddressScreening[] = {

   { 0, "P_ADDRESS_SCREENING_UNDEFINED" },
   { 1, "P_ADDRESS_SCREENING_USER_VERIFIED_PASSED" },
   { 2, "P_ADDRESS_SCREENING_USER_NOT_VERIFIED" },
   { 3, "P_ADDRESS_SCREENING_USER_VERIFIED_FAILED" },
   { 4, "P_ADDRESS_SCREENING_NETWORK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpCallAoCOrderCategory:1.0
 */
static const value_string org_csapi_TpCallAoCOrderCategory[] = {

   { 0, "P_CHARGE_ADVICE_INFO" },
   { 1, "P_CHARGE_PER_TIME" },
   { 2, "P_CHARGE_NETWORK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpDataSessionQosClass:1.0
 */
static const value_string org_csapi_TpDataSessionQosClass[] = {

   { 0, "P_DATA_SESSION_QOS_CLASS_CONVERSATIONAL" },
   { 1, "P_DATA_SESSION_QOS_CLASS_STREAMING" },
   { 2, "P_DATA_SESSION_QOS_CLASS_INTERACTIVE" },
   { 3, "P_DATA_SESSION_QOS_CLASS_BACKGROUND" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpSimpleAttributeTypeInfo:1.0
 */
static const value_string org_csapi_TpSimpleAttributeTypeInfo[] = {

   { 0, "P_BOOLEAN" },
   { 1, "P_OCTET" },
   { 2, "P_CHAR" },
   { 3, "P_WCHAR" },
   { 4, "P_STRING" },
   { 5, "P_WSTRING" },
   { 6, "P_INT16" },
   { 7, "P_UNSIGNED_INT16" },
   { 8, "P_INT32" },
   { 9, "P_UNSIGNED_INT32" },
   { 10, "P_INT64" },
   { 11, "P_UNSIGNED_INT64" },
   { 12, "P_FLOAT" },
   { 13, "P_DOUBLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/TpAttributeTagInfo:1.0
 */
static const value_string org_csapi_TpAttributeTagInfo[] = {

   { 0, "P_SIMPLE_TYPE" },
   { 1, "P_STRUCTURED_TYPE" },
   { 2, "P_XML_TYPE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpAPIUnavailReason:1.0
 */
static const value_string org_csapi_fw_TpAPIUnavailReason[] = {

   { 0, "API_UNAVAILABLE_UNDEFINED" },
   { 1, "API_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "API_UNAVAILABLE_GATEWAY_FAILURE" },
   { 3, "API_UNAVAILABLE_OVERLOADED" },
   { 4, "API_UNAVAILABLE_CLOSED" },
   { 5, "API_UNAVAILABLE_PROTOCOL_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpDomainIDType:1.0
 */
static const value_string org_csapi_fw_TpDomainIDType[] = {

   { 0, "P_FW" },
   { 1, "P_CLIENT_APPLICATION" },
   { 2, "P_ENT_OP" },
   { 3, "P_SERVICE_INSTANCE" },
   { 4, "P_SERVICE_SUPPLIER" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwEventName:1.0
 */
static const value_string org_csapi_fw_TpFwEventName[] = {

   { 0, "P_EVENT_FW_NAME_UNDEFINED" },
   { 1, "P_EVENT_FW_SERVICE_AVAILABLE" },
   { 2, "P_EVENT_FW_SERVICE_UNAVAILABLE" },
   { 3, "P_EVENT_FW_MIGRATION_SERVICE_AVAILABLE" },
   { 4, "P_EVENT_FW_APP_SESSION_CREATED" },
   { 5, "P_EVENT_FW_APP_SESSION_TERMINATED" },
   { 6, "P_EVENT_FW_APP_AGREEMENT_SIGNED" },
   { 7, "P_EVENT_FW_APP_AGREEMENT_ENDED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFWExceptionType:1.0
 */
static const value_string org_csapi_fw_TpFWExceptionType[] = {

   { 0, "P_FW_DUMMY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwUnavailReason:1.0
 */
static const value_string org_csapi_fw_TpFwUnavailReason[] = {

   { 0, "FW_UNAVAILABLE_UNDEFINED" },
   { 1, "FW_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "FW_UNAVAILABLE_GATEWAY_FAILURE" },
   { 3, "FW_UNAVAILABLE_OVERLOADED" },
   { 4, "FW_UNAVAILABLE_CLOSED" },
   { 5, "FW_UNAVAILABLE_PROTOCOL_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpInterfaceFault:1.0
 */
static const value_string org_csapi_fw_TpInterfaceFault[] = {

   { 0, "INTERFACE_FAULT_UNDEFINED" },
   { 1, "INTERFACE_FAULT_LOCAL_FAILURE" },
   { 2, "INTERFACE_FAULT_GATEWAY_FAILURE" },
   { 3, "INTERFACE_FAULT_PROTOCOL_ERROR" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadLevel:1.0
 */
static const value_string org_csapi_fw_TpLoadLevel[] = {

   { 0, "LOAD_LEVEL_NORMAL" },
   { 1, "LOAD_LEVEL_OVERLOAD" },
   { 2, "LOAD_LEVEL_SEVERE_OVERLOAD" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticEntityType:1.0
 */
static const value_string org_csapi_fw_TpLoadStatisticEntityType[] = {

   { 0, "P_LOAD_STATISTICS_FW_TYPE" },
   { 1, "P_LOAD_STATISTICS_SVC_TYPE" },
   { 2, "P_LOAD_STATISTICS_APP_TYPE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticInfoType:1.0
 */
static const value_string org_csapi_fw_TpLoadStatisticInfoType[] = {

   { 0, "P_LOAD_STATISTICS_VALID" },
   { 1, "P_LOAD_STATISTICS_INVALID" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatusError:1.0
 */
static const value_string org_csapi_fw_TpLoadStatusError[] = {

   { 0, "LOAD_STATUS_ERROR_UNDEFINED" },
   { 1, "LOAD_STATUS_ERROR_UNAVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpServiceTypePropertyMode:1.0
 */
static const value_string org_csapi_fw_TpServiceTypePropertyMode[] = {

   { 0, "NORMAL" },
   { 1, "MANDATORY" },
   { 2, "READONLY" },
   { 3, "MANDATORY_READONLY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSvcUnavailReason:1.0
 */
static const value_string org_csapi_fw_TpSvcUnavailReason[] = {

   { 0, "SERVICE_UNAVAILABLE_UNDEFINED" },
   { 1, "SERVICE_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "SERVICE_UNAVAILABLE_GATEWAY_FAILURE" },
   { 3, "SERVICE_UNAVAILABLE_OVERLOADED" },
   { 4, "SERVICE_UNAVAILABLE_CLOSED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpLoadStatisticError:1.0
 */
static const value_string org_csapi_fw_TpLoadStatisticError[] = {

   { 0, "P_LOAD_INFO_ERROR_UNDEFINED" },
   { 1, "P_LOAD_INFO_UNAVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSubjectType:1.0
 */
static const value_string org_csapi_fw_TpSubjectType[] = {

   { 0, "P_SUBJECT_UNDEFINED" },
   { 1, "P_SUBJECT_CLIENT_APP" },
   { 2, "P_SUBJECT_FW" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFaultStatisticsError:1.0
 */
static const value_string org_csapi_fw_TpFaultStatisticsError[] = {

   { 0, "P_FAULT_INFO_ERROR_UNDEFINED" },
   { 1, "P_FAULT_INFO_UNAVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpSvcAvailStatusReason:1.0
 */
static const value_string org_csapi_fw_TpSvcAvailStatusReason[] = {

   { 0, "SVC_UNAVAILABLE_UNDEFINED" },
   { 1, "SVC_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "SVC_UNAVAILABLE_GATEWAY_FAILURE" },
   { 3, "SVC_UNAVAILABLE_OVERLOADED" },
   { 4, "SVC_UNAVAILABLE_CLOSED" },
   { 5, "SVC_UNAVAILABLE_NO_RESPONSE" },
   { 6, "SVC_UNAVAILABLE_SW_UPGRADE" },
   { 7, "SVC_AVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpAppAvailStatusReason:1.0
 */
static const value_string org_csapi_fw_TpAppAvailStatusReason[] = {

   { 0, "APP_UNAVAILABLE_UNDEFINED" },
   { 1, "APP_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "APP_UNAVAILABLE_REMOTE_FAILURE" },
   { 3, "APP_UNAVAILABLE_OVERLOADED" },
   { 4, "APP_UNAVAILABLE_CLOSED" },
   { 5, "APP_UNAVAILABLE_NO_RESPONSE" },
   { 6, "APP_UNAVAILABLE_SW_UPGRADE" },
   { 7, "APP_AVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpMigrationAdditionalInfoType:1.0
 */
static const value_string org_csapi_fw_TpMigrationAdditionalInfoType[] = {

   { 0, "P_MIGRATION_INFO_UNDEFINED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/fw/TpFwAvailStatusReason:1.0
 */
static const value_string org_csapi_fw_TpFwAvailStatusReason[] = {

   { 0, "FRAMEWORK_UNAVAILABLE_UNDEFINED" },
   { 1, "FRAMEWORK_UNAVAILABLE_LOCAL_FAILURE" },
   { 2, "FRAMEWORK_UNAVAILABLE_REMOTE_FAILURE" },
   { 3, "FRAMEWORK_UNAVAILABLE_OVERLOADED" },
   { 4, "FRAMEWORK_UNAVAILABLE_CLOSED" },
   { 5, "FRAMEWORK_UNAVAILABLE_PROTOCOL_FAILURE" },
   { 6, "FRAMEWORK_UNAVAILABLE_SW_UPGRADE" },
   { 7, "FRAMEWORK_AVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIVariablePartType:1.0
 */
static const value_string org_csapi_ui_TpUIVariablePartType[] = {

   { 0, "P_UI_VARIABLE_PART_INT" },
   { 1, "P_UI_VARIABLE_PART_ADDRESS" },
   { 2, "P_UI_VARIABLE_PART_TIME" },
   { 3, "P_UI_VARIABLE_PART_DATE" },
   { 4, "P_UI_VARIABLE_PART_PRICE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIReport:1.0
 */
static const value_string org_csapi_ui_TpUIReport[] = {

   { 0, "P_UI_REPORT_UNDEFINED" },
   { 1, "P_UI_REPORT_INFO_SENT" },
   { 2, "P_UI_REPORT_INFO_COLLECTED" },
   { 3, "P_UI_REPORT_NO_INPUT" },
   { 4, "P_UI_REPORT_TIMEOUT" },
   { 5, "P_UI_REPORT_MESSAGE_STORED" },
   { 6, "P_UI_REPORT_MESSAGE_NOT_STORED" },
   { 7, "P_UI_REPORT_MESSAGE_DELETED" },
   { 8, "P_UI_REPORT_MESSAGE_NOT_DELETED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIInfoType:1.0
 */
static const value_string org_csapi_ui_TpUIInfoType[] = {

   { 0, "P_UI_INFO_ID" },
   { 1, "P_UI_INFO_DATA" },
   { 2, "P_UI_INFO_ADDRESS" },
   { 3, "P_UI_INFO_BIN_DATA" },
   { 4, "P_UI_INFO_UUENCODED" },
   { 5, "P_UI_INFO_MIME" },
   { 6, "P_UI_INFO_WAVE" },
   { 7, "P_UI_INFO_AU" },
   { 8, "P_UI_INFO_VXML" },
   { 9, "P_UI_INFO_SYNTHESIS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIFault:1.0
 */
static const value_string org_csapi_ui_TpUIFault[] = {

   { 0, "P_UI_FAULT_UNDEFINED" },
   { 1, "P_UI_CALL_ENDED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIEventInfoDataType:1.0
 */
static const value_string org_csapi_ui_TpUIEventInfoDataType[] = {

   { 0, "P_UI_EVENT_DATA_TYPE_UNDEFINED" },
   { 1, "P_UI_EVENT_DATA_TYPE_UNSPECIFIED" },
   { 2, "P_UI_EVENT_DATA_TYPE_TEXT" },
   { 3, "P_UI_EVENT_DATA_TYPE_USSD_DATA" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIError:1.0
 */
static const value_string org_csapi_ui_TpUIError[] = {

   { 0, "P_UI_ERROR_UNDEFINED" },
   { 1, "P_UI_ERROR_ILLEGAL_INFO" },
   { 2, "P_UI_ERROR_ID_NOT_FOUND" },
   { 3, "P_UI_ERROR_RESOURCE_UNAVAILABLE" },
   { 4, "P_UI_ERROR_ILLEGAL_RANGE" },
   { 5, "P_UI_ERROR_IMPROPER_USER_RESPONSE" },
   { 6, "P_UI_ERROR_ABANDON" },
   { 7, "P_UI_ERROR_NO_OPERATION_ACTIVE" },
   { 8, "P_UI_ERROR_NO_SPACE_AVAILABLE" },
   { 9, "P_UI_ERROR_RESOURCE_TIMEOUT" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUICollectMode:1.0
 */
static const value_string org_csapi_ui_TpUICollectMode[] = {

   { 0, "P_UI_COLLECT_MODE_DTMF" },
   { 1, "P_UI_COLLECT_MODE_VOICE" },
   { 2, "P_UI_COLLECT_MODE_DTMFANDVOICE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUIPronounceType:1.0
 */
static const value_string org_csapi_ui_TpUIPronounceType[] = {

   { 0, "P_UI_PRONOUNCE_IPA" },
   { 1, "P_UI_PRONOUNCE_SOUNDSLIKE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisRange:1.0
 */
static const value_string org_csapi_ui_TpUISynthesisRange[] = {

   { 0, "P_UI_RANGE_CALMER" },
   { 1, "P_UI_RANGE_CALM" },
   { 2, "P_UI_RANGE_AVERAGE" },
   { 3, "P_UI_RANGE_EXCITED" },
   { 4, "P_UI_RANGE_MORE_EXCITED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisRate:1.0
 */
static const value_string org_csapi_ui_TpUISynthesisRate[] = {

   { 0, "P_UI_RATE_SLOW" },
   { 1, "P_UI_RATE_AVERAGE" },
   { 2, "P_UI_RATE_FAST" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisAge:1.0
 */
static const value_string org_csapi_ui_TpUISynthesisAge[] = {

   { 0, "P_UI_AGE_CHILD" },
   { 1, "P_UI_AGE_YOUNG_ADULT" },
   { 2, "P_UI_AGE_ADULT" },
   { 3, "P_UI_AGE_OLDER_ADULT" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUISynthesisGender:1.0
 */
static const value_string org_csapi_ui_TpUISynthesisGender[] = {

   { 0, "P_UI_GENDER_MALE" },
   { 1, "P_UI_GENDER_FEMALE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpReleaseCause:1.0
 */
static const value_string org_csapi_cc_TpReleaseCause[] = {

   { 0, "P_UNDEFINED" },
   { 1, "P_USER_NOT_AVAILABLE" },
   { 2, "P_BUSY" },
   { 3, "P_NO_ANSWER" },
   { 4, "P_NOT_REACHABLE" },
   { 5, "P_ROUTING_FAILURE" },
   { 6, "P_PREMATURE_DISCONNECT" },
   { 7, "P_DISCONNECTED" },
   { 8, "P_CALL_RESTRICTED" },
   { 9, "P_UNAVAILABLE_RESOURCE" },
   { 10, "P_GENERAL_FAILURE" },
   { 11, "P_TIMER_EXPIRY" },
   { 12, "P_UNSUPPORTED_MEDIA" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallMonitorMode:1.0
 */
static const value_string org_csapi_cc_TpCallMonitorMode[] = {

   { 0, "P_CALL_MONITOR_MODE_INTERRUPT" },
   { 1, "P_CALL_MONITOR_MODE_NOTIFY" },
   { 2, "P_CALL_MONITOR_MODE_DO_NOT_MONITOR" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallBearerService:1.0
 */
static const value_string org_csapi_cc_TpCallBearerService[] = {

   { 0, "P_CALL_BEARER_SERVICE_UNKNOWN" },
   { 1, "P_CALL_BEARER_SERVICE_SPEECH" },
   { 2, "P_CALL_BEARER_SERVICE_DIGITALUNRESTRICTED" },
   { 3, "P_CALL_BEARER_SERVICE_DIGITALRESTRICTED" },
   { 4, "P_CALL_BEARER_SERVICE_AUDIO" },
   { 5, "P_CALL_BEARER_SERVICE_DIGITALUNRESTRICTEDTONES" },
   { 6, "P_CALL_BEARER_SERVICE_VIDEO" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallChargeOrderCategory:1.0
 */
static const value_string org_csapi_cc_TpCallChargeOrderCategory[] = {

   { 0, "P_CALL_CHARGE_TRANSPARENT" },
   { 1, "P_CALL_CHARGE_PREDEFINED_SET" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallErrorType:1.0
 */
static const value_string org_csapi_cc_TpCallErrorType[] = {

   { 0, "P_CALL_ERROR_UNDEFINED" },
   { 1, "P_CALL_ERROR_INVALID_ADDRESS" },
   { 2, "P_CALL_ERROR_INVALID_STATE" },
   { 3, "P_CALL_ERROR_RESOURCE_UNAVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallLoadControlMechanismType:1.0
 */
static const value_string org_csapi_cc_TpCallLoadControlMechanismType[] = {

   { 0, "P_CALL_LOAD_CONTROL_PER_INTERVAL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallNetworkAccessType:1.0
 */
static const value_string org_csapi_cc_TpCallNetworkAccessType[] = {

   { 0, "P_CALL_NETWORK_ACCESS_TYPE_UNKNOWN" },
   { 1, "P_CALL_NETWORK_ACCESS_TYPE_POT" },
   { 2, "P_CALL_NETWORK_ACCESS_TYPE_ISDN" },
   { 3, "P_CALL_NETWORK_ACCESS_TYPE_DIALUPINTERNET" },
   { 4, "P_CALL_NETWORK_ACCESS_TYPE_XDSL" },
   { 5, "P_CALL_NETWORK_ACCESS_TYPE_WIRELESS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallPartyCategory:1.0
 */
static const value_string org_csapi_cc_TpCallPartyCategory[] = {

   { 0, "P_CALL_PARTY_CATEGORY_UNKNOWN" },
   { 1, "P_CALL_PARTY_CATEGORY_OPERATOR_F" },
   { 2, "P_CALL_PARTY_CATEGORY_OPERATOR_E" },
   { 3, "P_CALL_PARTY_CATEGORY_OPERATOR_G" },
   { 4, "P_CALL_PARTY_CATEGORY_OPERATOR_R" },
   { 5, "P_CALL_PARTY_CATEGORY_OPERATOR_S" },
   { 6, "P_CALL_PARTY_CATEGORY_ORDINARY_SUB" },
   { 7, "P_CALL_PARTY_CATEGORY_PRIORITY_SUB" },
   { 8, "P_CALL_PARTY_CATEGORY_DATA_CALL" },
   { 9, "P_CALL_PARTY_CATEGORY_TEST_CALL" },
   { 10, "P_CALL_PARTY_CATEGORY_PAYPHONE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallServiceCodeType:1.0
 */
static const value_string org_csapi_cc_TpCallServiceCodeType[] = {

   { 0, "P_CALL_SERVICE_CODE_UNDEFINED" },
   { 1, "P_CALL_SERVICE_CODE_DIGITS" },
   { 2, "P_CALL_SERVICE_CODE_FACILITY" },
   { 3, "P_CALL_SERVICE_CODE_U2U" },
   { 4, "P_CALL_SERVICE_CODE_HOOKFLASH" },
   { 5, "P_CALL_SERVICE_CODE_RECALL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallTeleService:1.0
 */
static const value_string org_csapi_cc_TpCallTeleService[] = {

   { 0, "P_CALL_TELE_SERVICE_UNKNOWN" },
   { 1, "P_CALL_TELE_SERVICE_TELEPHONY" },
   { 2, "P_CALL_TELE_SERVICE_FAX_2_3" },
   { 3, "P_CALL_TELE_SERVICE_FAX_4_I" },
   { 4, "P_CALL_TELE_SERVICE_FAX_4_II_III" },
   { 5, "P_CALL_TELE_SERVICE_VIDEOTEX_SYN" },
   { 6, "P_CALL_TELE_SERVICE_VIDEOTEX_INT" },
   { 7, "P_CALL_TELE_SERVICE_TELEX" },
   { 8, "P_CALL_TELE_SERVICE_MHS" },
   { 9, "P_CALL_TELE_SERVICE_OSI" },
   { 10, "P_CALL_TELE_SERVICE_FTAM" },
   { 11, "P_CALL_TELE_SERVICE_VIDEO" },
   { 12, "P_CALL_TELE_SERVICE_VIDEO_CONF" },
   { 13, "P_CALL_TELE_SERVICE_AUDIOGRAPH_CONF" },
   { 14, "P_CALL_TELE_SERVICE_MULTIMEDIA" },
   { 15, "P_CALL_TELE_SERVICE_CS_INI_H221" },
   { 16, "P_CALL_TELE_SERVICE_CS_SUB_H221" },
   { 17, "P_CALL_TELE_SERVICE_CS_INI_CALL" },
   { 18, "P_CALL_TELE_SERVICE_DATATRAFFIC" },
   { 19, "P_CALL_TELE_SERVICE_EMERGENCY_CALLS" },
   { 20, "P_CALL_TELE_SERVICE_SMS_MT_PP" },
   { 21, "P_CALL_TELE_SERVICE_SMS_MO_PP" },
   { 22, "P_CALL_TELE_SERVICE_CELL_BROADCAST" },
   { 23, "P_CALL_TELE_SERVICE_ALT_SPEECH_FAX_3" },
   { 24, "P_CALL_TELE_SERVICE_AUTOMATIC_FAX_3" },
   { 25, "P_CALL_TELE_SERVICE_VOICE_GROUP_CALL" },
   { 26, "P_CALL_TELE_SERVICE_VOICE_BROADCAST" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallTreatmentType:1.0
 */
static const value_string org_csapi_cc_TpCallTreatmentType[] = {

   { 0, "P_CALL_TREATMENT_DEFAULT" },
   { 1, "P_CALL_TREATMENT_RELEASE" },
   { 2, "P_CALL_TREATMENT_SIAR" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallPartyToChargeType:1.0
 */
static const value_string org_csapi_cc_TpCallPartyToChargeType[] = {

   { 0, "P_CALL_PARTY_ORIGINATING" },
   { 1, "P_CALL_PARTY_DESTINATION" },
   { 2, "P_CALL_PARTY_SPECIAL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallNotificationType:1.0
 */
static const value_string org_csapi_cc_gccs_TpCallNotificationType[] = {

   { 0, "P_ORIGINATING" },
   { 1, "P_TERMINATING" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallAppInfoType:1.0
 */
static const value_string org_csapi_cc_gccs_TpCallAppInfoType[] = {

   { 0, "P_CALL_APP_UNDEFINED" },
   { 1, "P_CALL_APP_ALERTING_MECHANISM" },
   { 2, "P_CALL_APP_NETWORK_ACCESS_TYPE" },
   { 3, "P_CALL_APP_TELE_SERVICE" },
   { 4, "P_CALL_APP_BEARER_SERVICE" },
   { 5, "P_CALL_APP_PARTY_CATEGORY" },
   { 6, "P_CALL_APP_PRESENTATION_ADDRESS" },
   { 7, "P_CALL_APP_GENERIC_INFO" },
   { 8, "P_CALL_APP_ADDITIONAL_ADDRESS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallReportType:1.0
 */
static const value_string org_csapi_cc_gccs_TpCallReportType[] = {

   { 0, "P_CALL_REPORT_UNDEFINED" },
   { 1, "P_CALL_REPORT_PROGRESS" },
   { 2, "P_CALL_REPORT_ALERTING" },
   { 3, "P_CALL_REPORT_ANSWER" },
   { 4, "P_CALL_REPORT_BUSY" },
   { 5, "P_CALL_REPORT_NO_ANSWER" },
   { 6, "P_CALL_REPORT_DISCONNECT" },
   { 7, "P_CALL_REPORT_REDIRECTED" },
   { 8, "P_CALL_REPORT_SERVICE_CODE" },
   { 9, "P_CALL_REPORT_ROUTING_FAILURE" },
   { 10, "P_CALL_REPORT_QUEUED" },
   { 11, "P_CALL_REPORT_NOT_REACHABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/gccs/TpCallFault:1.0
 */
static const value_string org_csapi_cc_gccs_TpCallFault[] = {

   { 0, "P_CALL_FAULT_UNDEFINED" },
   { 1, "P_CALL_TIMEOUT_ON_RELEASE" },
   { 2, "P_CALL_TIMEOUT_ON_INTERRUPT" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallAppInfoType:1.0
 */
static const value_string org_csapi_cc_TpCallAppInfoType[] = {

   { 0, "P_CALL_APP_UNDEFINED" },
   { 1, "P_CALL_APP_ALERTING_MECHANISM" },
   { 2, "P_CALL_APP_NETWORK_ACCESS_TYPE" },
   { 3, "P_CALL_APP_TELE_SERVICE" },
   { 4, "P_CALL_APP_BEARER_SERVICE" },
   { 5, "P_CALL_APP_PARTY_CATEGORY" },
   { 6, "P_CALL_APP_PRESENTATION_ADDRESS" },
   { 7, "P_CALL_APP_GENERIC_INFO" },
   { 8, "P_CALL_APP_ADDITIONAL_ADDRESS" },
   { 9, "P_CALL_APP_ORIGINAL_DESTINATION_ADDRESS" },
   { 10, "P_CALL_APP_REDIRECTING_ADDRESS" },
   { 11, "P_CALL_APP_HIGH_PROBABILITY_COMPLETION" },
   { 12, "P_CALL_APP_CARRIER" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallEventType:1.0
 */
static const value_string org_csapi_cc_TpCallEventType[] = {

   { 0, "P_CALL_EVENT_UNDEFINED" },
   { 1, "P_CALL_EVENT_ORIGINATING_CALL_ATTEMPT" },
   { 2, "P_CALL_EVENT_ORIGINATING_CALL_ATTEMPT_AUTHORISED" },
   { 3, "P_CALL_EVENT_ADDRESS_COLLECTED" },
   { 4, "P_CALL_EVENT_ADDRESS_ANALYSED" },
   { 5, "P_CALL_EVENT_ORIGINATING_SERVICE_CODE" },
   { 6, "P_CALL_EVENT_ORIGINATING_RELEASE" },
   { 7, "P_CALL_EVENT_TERMINATING_CALL_ATTEMPT" },
   { 8, "P_CALL_EVENT_TERMINATING_CALL_ATTEMPT_AUTHORISED" },
   { 9, "P_CALL_EVENT_ALERTING" },
   { 10, "P_CALL_EVENT_ANSWER" },
   { 11, "P_CALL_EVENT_TERMINATING_RELEASE" },
   { 12, "P_CALL_EVENT_REDIRECTED" },
   { 13, "P_CALL_EVENT_TERMINATING_SERVICE_CODE" },
   { 14, "P_CALL_EVENT_QUEUED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCallLegAttachMechanism:1.0
 */
static const value_string org_csapi_cc_TpCallLegAttachMechanism[] = {

   { 0, "P_CALLLEG_ATTACH_IMPLICITLY" },
   { 1, "P_CALLLEG_ATTACH_EXPLICITLY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/TpCarrierSelectionField:1.0
 */
static const value_string org_csapi_cc_TpCarrierSelectionField[] = {

   { 0, "P_CIC_UNDEFINED" },
   { 1, "P_CIC_NO_INPUT" },
   { 2, "P_CIC_INPUT" },
   { 3, "P_CIC_UNDETERMINED" },
   { 4, "P_CIC_NOT_PRESCRIBED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBackRefType:1.0
 */
static const value_string org_csapi_cc_mpccs_TpAppMultiPartyCallBackRefType[] = {

   { 0, "P_APP_CALLBACK_UNDEFINED" },
   { 1, "P_APP_MULTIPARTY_CALL_CALLBACK" },
   { 2, "P_APP_CALL_LEG_CALLBACK" },
   { 3, "P_APP_CALL_AND_CALL_LEG_CALLBACK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamDirection:1.0
 */
static const value_string org_csapi_cc_mmccs_TpMediaStreamDirection[] = {

   { 0, "P_SEND_ONLY" },
   { 1, "P_RECEIVE_ONLY" },
   { 2, "P_SEND_RECEIVE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamEventType:1.0
 */
static const value_string org_csapi_cc_mmccs_TpMediaStreamEventType[] = {

   { 0, "P_MEDIA_STREAM_ADDED" },
   { 1, "P_MEDIA_STREAM_SUBTRACTED" },
   { 2, "P_MEDIA_STREAM_QOS_CLASS_CHANGED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequestType:1.0
 */
static const value_string org_csapi_cc_mmccs_TpMediaStreamDataTypeRequestType[] = {

   { 0, "P_AUDIO_CAPABILITIES" },
   { 1, "P_VIDEO_CAPABILITIES" },
   { 2, "P_DATA_CAPABILITIES" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBackRefType:1.0
 */
static const value_string org_csapi_cc_mmccs_TpAppMultiMediaCallBackRefType[] = {

   { 0, "P_APP_CALLBACK_UNDEFINED" },
   { 1, "P_APP_MULTIMEDIA_CALL_CALLBACK" },
   { 2, "P_APP_CALL_LEG_CALLBACK" },
   { 3, "P_APP_CALL_AND_CALL_LEG_CALLBACK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/cccs/TpConfPolicyType:1.0
 */
static const value_string org_csapi_cc_cccs_TpConfPolicyType[] = {

   { 0, "P_CONFERENCE_POLICY_UNDEFINED" },
   { 1, "P_CONFERENCE_POLICY_MONOMEDIA" },
   { 2, "P_CONFERENCE_POLICY_MULTIMEDIA" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cc/cccs/TpVideoHandlingType:1.0
 */
static const value_string org_csapi_cc_cccs_TpVideoHandlingType[] = {

   { 0, "P_MIXED_VIDEO" },
   { 1, "P_SWITCHED_VIDEO_CHAIR_CONTROLLED" },
   { 2, "P_SWITCHED_VIDEO_VOICE_CONTROLLED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/ui/TpUITargetObjectType:1.0
 */
static const value_string org_csapi_ui_TpUITargetObjectType[] = {

   { 0, "P_UI_TARGET_OBJECT_CALL" },
   { 1, "P_UI_TARGET_OBJECT_MULTI_PARTY_CALL" },
   { 2, "P_UI_TARGET_OBJECT_CALL_LEG" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationPriority:1.0
 */
static const value_string org_csapi_mm_TpLocationPriority[] = {

   { 0, "P_M_NORMAL" },
   { 1, "P_M_HIGH" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationResponseIndicator:1.0
 */
static const value_string org_csapi_mm_TpLocationResponseIndicator[] = {

   { 0, "P_M_NO_DELAY" },
   { 1, "P_M_LOW_DELAY" },
   { 2, "P_M_DELAY_TOLERANT" },
   { 3, "P_M_USE_TIMER_VALUE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationTriggerCriteria:1.0
 */
static const value_string org_csapi_mm_TpLocationTriggerCriteria[] = {

   { 0, "P_UL_ENTERING_AREA" },
   { 1, "P_UL_LEAVING_AREA" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationType:1.0
 */
static const value_string org_csapi_mm_TpLocationType[] = {

   { 0, "P_M_CURRENT" },
   { 1, "P_M_CURRENT_OR_LAST_KNOWN" },
   { 2, "P_M_INITIAL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpLocationUncertaintyShape:1.0
 */
static const value_string org_csapi_mm_TpLocationUncertaintyShape[] = {

   { 0, "P_M_SHAPE_NONE" },
   { 1, "P_M_SHAPE_CIRCLE" },
   { 2, "P_M_SHAPE_CIRCLE_SECTOR" },
   { 3, "P_M_SHAPE_CIRCLE_ARC_STRIPE" },
   { 4, "P_M_SHAPE_ELLIPSE" },
   { 5, "P_M_SHAPE_ELLIPSE_SECTOR" },
   { 6, "P_M_SHAPE_ELLIPSE_ARC_STRIPE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityDiagnostic:1.0
 */
static const value_string org_csapi_mm_TpMobilityDiagnostic[] = {

   { 0, "P_M_NO_INFORMATION" },
   { 1, "P_M_APPL_NOT_IN_PRIV_EXCEPT_LST" },
   { 2, "P_M_CALL_TO_USER_NOT_SETUP" },
   { 3, "P_M_PRIVACY_OVERRIDE_NOT_APPLIC" },
   { 4, "P_M_DISALL_BY_LOCAL_REGULAT_REQ" },
   { 5, "P_M_CONGESTION" },
   { 6, "P_M_INSUFFICIENT_RESOURCES" },
   { 7, "P_M_INSUFFICIENT_MEAS_DATA" },
   { 8, "P_M_INCONSISTENT_MEAS_DATA" },
   { 9, "P_M_LOC_PROC_NOT_COMPLETED" },
   { 10, "P_M_LOC_PROC_NOT_SUPP_BY_USER" },
   { 11, "P_M_QOS_NOT_ATTAINABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityError:1.0
 */
static const value_string org_csapi_mm_TpMobilityError[] = {

   { 0, "P_M_OK" },
   { 1, "P_M_SYSTEM_FAILURE" },
   { 2, "P_M_UNAUTHORIZED_NETWORK" },
   { 3, "P_M_UNAUTHORIZED_APPLICATION" },
   { 4, "P_M_UNKNOWN_SUBSCRIBER" },
   { 5, "P_M_ABSENT_SUBSCRIBER" },
   { 6, "P_M_POSITION_METHOD_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpMobilityStopScope:1.0
 */
static const value_string org_csapi_mm_TpMobilityStopScope[] = {

   { 0, "P_M_ALL_IN_ASSIGNMENT" },
   { 1, "P_M_SPECIFIED_USERS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpTerminalType:1.0
 */
static const value_string org_csapi_mm_TpTerminalType[] = {

   { 0, "P_M_FIXED" },
   { 1, "P_M_MOBILE" },
   { 2, "P_M_IP" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpUserLocationEmergencyTrigger:1.0
 */
static const value_string org_csapi_mm_TpUserLocationEmergencyTrigger[] = {

   { 0, "P_ULE_CALL_ORIGINATION" },
   { 1, "P_ULE_CALL_RELEASE" },
   { 2, "P_ULE_LOCATION_REQUEST" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpUserStatusIndicator:1.0
 */
static const value_string org_csapi_mm_TpUserStatusIndicator[] = {

   { 0, "P_US_REACHABLE" },
   { 1, "P_US_NOT_REACHABLE" },
   { 2, "P_US_BUSY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpAuthStatusIndicator:1.0
 */
static const value_string org_csapi_mm_TpAuthStatusIndicator[] = {

   { 0, "P_AUTHENTICATED_FOR_NETWORK_ONLY" },
   { 1, "P_AUTHENTICATED_FOR_NETWORK_AND_IP_SERVICES" },
   { 2, "P_NOT_AUTHENTICATED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpAccessTechnology:1.0
 */
static const value_string org_csapi_mm_TpAccessTechnology[] = {

   { 0, "P_MOBILE_ACCESS_PS" },
   { 1, "P_MOBILE_ACCESS_CS" },
   { 2, "P_FIXED_ACCESS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpRoamingStatus:1.0
 */
static const value_string org_csapi_mm_TpRoamingStatus[] = {

   { 0, "P_UNKNOWN_ROAMING_STATUS" },
   { 1, "P_HOME_USER" },
   { 2, "P_NATIONAL_ROAMING" },
   { 3, "P_INTERNATIONAL_ROAMING" },
   { 4, "P_OPERATOR_ROAMING" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mm/TpBindingEntryType:1.0
 */
static const value_string org_csapi_mm_TpBindingEntryType[] = {

   { 0, "P_UB_UNDEFINED" },
   { 1, "P_UB_EXPIRES" },
   { 2, "P_UB_CONTACT_ADDRESS" },
   { 3, "P_UB_PREFERENCE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/termcap/TpTerminalCapabilitiesError:1.0
 */
static const value_string org_csapi_termcap_TpTerminalCapabilitiesError[] = {

   { 0, "P_TERMCAP_ERROR_UNDEFINED" },
   { 1, "P_TERMCAP_INVALID_TERMINALID" },
   { 2, "P_TERMCAP_SYSTEM_FAILURE" },
   { 3, "P_TERMCAP_INFO_UNAVAILABLE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/termcap/TpTerminalCapabilityScopeType:1.0
 */
static const value_string org_csapi_termcap_TpTerminalCapabilityScopeType[] = {

   { 0, "P_TERMINAL_CAPABILITY_SCOPE_TYPE_UNDEFINED" },
   { 1, "P_TERMINAL_CAPABILITY_SCOPE_TYPE_CCPP" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionChargeOrderCategory:1.0
 */
static const value_string org_csapi_dsc_TpDataSessionChargeOrderCategory[] = {

   { 0, "P_DATA_SESSION_CHARGE_PER_VOLUME" },
   { 1, "P_DATA_SESSION_CHARGE_NETWORK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionErrorType:1.0
 */
static const value_string org_csapi_dsc_TpDataSessionErrorType[] = {

   { 0, "P_DATA_SESSION_ERROR_UNDEFINED" },
   { 1, "P_DATA_SESSION_ERROR_INVALID_ADDRESS" },
   { 2, "P_DATA_SESSION_ERROR_INVALID_STATE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionFault:1.0
 */
static const value_string org_csapi_dsc_TpDataSessionFault[] = {

   { 0, "P_DATA_SESSION_FAULT_UNDEFINED" },
   { 1, "P_DATA_SESSION_FAULT_USER_ABORTED" },
   { 2, "P_DATA_SESSION_TIMEOUT_ON_RELEASE" },
   { 3, "P_DATA_SESSION_TIMEOUT_ON_INTERRUPT" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionMonitorMode:1.0
 */
static const value_string org_csapi_dsc_TpDataSessionMonitorMode[] = {

   { 0, "P_DATA_SESSION_MONITOR_MODE_INTERRUPT" },
   { 1, "P_DATA_SESSION_MONITOR_MODE_NOTIFY" },
   { 2, "P_DATA_SESSION_MONITOR_MODE_DO_NOT_MONITOR" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/dsc/TpDataSessionReportType:1.0
 */
static const value_string org_csapi_dsc_TpDataSessionReportType[] = {

   { 0, "P_DATA_SESSION_REPORT_UNDEFINED" },
   { 1, "P_DATA_SESSION_REPORT_CONNECTED" },
   { 2, "P_DATA_SESSION_REPORT_DISCONNECT" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagingFault:1.0
 */
static const value_string org_csapi_gms_TpMessagingFault[] = {

   { 0, "P_MESSAGING_FAULT_UNDEFINED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagingEventName:1.0
 */
static const value_string org_csapi_gms_TpMessagingEventName[] = {

   { 0, "P_EVENT_GMS_NAME_UNDEFINED" },
   { 1, "P_EVENT_GMS_NEW_MESSAGE_ARRIVED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageStatus:1.0
 */
static const value_string org_csapi_gms_TpMessageStatus[] = {

   { 0, "P_MESSAGING_MESSAGE_STATUS_READ_MESSAGE" },
   { 1, "P_MESSAGING_MESSAGE_STATUS_UNREAD_MESSAGE" },
   { 2, "P_MESSAGING_MESSAGE_STATUS_FORWARDED_MESSAGE" },
   { 3, "P_MESSAGING_MESSAGE_STATUS_REPLIED_TO_MESSAGE" },
   { 4, "P_MESSAGING_MESSAGE_STATUS_SAVED_OR_UNSENT_MESSAGE" },
   { 5, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_DELIVERED" },
   { 6, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_READ" },
   { 7, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_NOT_DELIVERED" },
   { 8, "P_MESSAGING_MESSAGE_STATUS_NOTIFICATION_THAT_A_MESSAGE_WAS_NOT_READ" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessagePriority:1.0
 */
static const value_string org_csapi_gms_TpMessagePriority[] = {

   { 0, "P_MESSAGING_MESSAGE_PRIORITY_UNDEFINED" },
   { 1, "P_MESSAGING_MESSAGE_PRIORITY_HIGH" },
   { 2, "P_MESSAGING_MESSAGE_PRIORITY_LOW" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageInfoPropertyName:1.0
 */
static const value_string org_csapi_gms_TpMessageInfoPropertyName[] = {

   { 0, "P_MESSAGING_MESSAGE_UNDEFINED" },
   { 1, "P_MESSAGING_MESSAGE_ID" },
   { 2, "P_MESSAGING_MESSAGE_SUBJECT" },
   { 3, "P_MESSAGING_MESSAGE_DATE_SENT" },
   { 4, "P_MESSAGING_MESSAGE_DATE_RECEIVED" },
   { 5, "P_MESSAGING_MESSAGE_DATE_CHANGED" },
   { 6, "P_MESSAGING_MESSAGE_SENT_FROM" },
   { 7, "P_MESSAGING_MESSAGE_SENT_TO" },
   { 8, "P_MESSAGING_MESSAGE_CC_TO" },
   { 9, "P_MESSAGING_MESSAGE_BCC_TO" },
   { 10, "P_MESSAGING_MESSAGE_SIZE" },
   { 11, "P_MESSAGING_MESSAGE_PRIORITY" },
   { 12, "P_MESSAGING_MESSAGE_FORMAT" },
   { 13, "P_MESSAGING_MESSAGE_FOLDER" },
   { 14, "P_MESSAGING_MESSAGE_STATUS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMessageFormat:1.0
 */
static const value_string org_csapi_gms_TpMessageFormat[] = {

   { 0, "P_MESSAGING_MESSAGE_FORMAT_UNDEFINED" },
   { 1, "P_MESSAGING_MESSAGE_FORMAT_TEXT" },
   { 2, "P_MESSAGING_MESSAGE_FORMAT_BINARY" },
   { 3, "P_MESSAGING_MESSAGE_FORMAT_UUENCODED" },
   { 4, "P_MESSAGING_MESSAGE_FORMAT_MIME" },
   { 5, "P_MESSAGING_MESSAGE_FORMAT_WAVE" },
   { 6, "P_MESSAGING_MESSAGE_FORMAT_AU" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpMailboxInfoPropertyName:1.0
 */
static const value_string org_csapi_gms_TpMailboxInfoPropertyName[] = {

   { 0, "P_MESSAGING_MAILBOX_UNDEFINED" },
   { 1, "P_MESSAGING_MAILBOX_ID" },
   { 2, "P_MESSAGING_MAILBOX_OWNER" },
   { 3, "P_MESSAGING_MAILBOX_FOLDER" },
   { 4, "P_MESSAGING_MAILBOX_DATE_CREATED" },
   { 5, "P_MESSAGING_MAILBOX_DATE_CHANGED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/gms/TpFolderInfoPropertyName:1.0
 */
static const value_string org_csapi_gms_TpFolderInfoPropertyName[] = {

   { 0, "P_MESSAGING_FOLDER_UNDEFINED" },
   { 1, "P_MESSAGING_FOLDER_ID" },
   { 2, "P_MESSAGING_FOLDER_MESSAGE" },
   { 3, "P_MESSAGING_FOLDER_SUBFOLDER" },
   { 4, "P_MESSAGING_FOLDER_DATE_CREATED" },
   { 5, "P_MESSAGING_FOLDER_DATE_CHANGED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpTrafficDirection:1.0
 */
static const value_string org_csapi_cm_TpTrafficDirection[] = {

   { 0, "UNIDIRECTIONAL" },
   { 1, "BIDIRECTIONAL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpTagValue:1.0
 */
static const value_string org_csapi_cm_TpTagValue[] = {

   { 0, "PROVIDER_SPECIFIED" },
   { 1, "OPERATOR_SPECIFIED" },
   { 2, "UNSPECIFIED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpSiteOrSap:1.0
 */
static const value_string org_csapi_cm_TpSiteOrSap[] = {

   { 0, "SITE" },
   { 1, "SAP" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpIPVersion:1.0
 */
static const value_string org_csapi_cm_TpIPVersion[] = {

   { 0, "VERSION_UNKNOWN" },
   { 1, "VERSION_IPV4" },
   { 2, "VERSION_IPV6" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpIPv4AddType:1.0
 */
static const value_string org_csapi_cm_TpIPv4AddType[] = {

   { 0, "IPV4_ADD_CLASS_A" },
   { 1, "IPV4_ADD_CLASS_B" },
   { 2, "IPV4_ADD_CLASS_C" },
   { 3, "IPV4_ADD_CLASS_D" },
   { 4, "IPV4_ADD_CLASS_E" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpAction:1.0
 */
static const value_string org_csapi_cm_TpAction[] = {

   { 0, "DROP" },
   { 1, "TRANSMIT" },
   { 2, "RESHAPE" },
   { 3, "REMARK" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cm/TpVprpStatus:1.0
 */
static const value_string org_csapi_cm_TpVprpStatus[] = {

   { 0, "ACTIVE" },
   { 1, "PENDING" },
   { 2, "DISALLOWED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpChargingEventName:1.0
 */
static const value_string org_csapi_am_TpChargingEventName[] = {

   { 0, "P_AM_CHARGING" },
   { 1, "P_AM_RECHARGING" },
   { 2, "P_AM_ACCOUNT_LOW" },
   { 3, "P_AM_ACCOUNT_ZERO" },
   { 4, "P_AM_ACCOUNT_DISABLED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpBalanceQueryError:1.0
 */
static const value_string org_csapi_am_TpBalanceQueryError[] = {

   { 0, "P_BALANCE_QUERY_OK" },
   { 1, "P_BALANCE_QUERY_ERROR_UNDEFINED" },
   { 2, "P_BALANCE_QUERY_UNKNOWN_SUBSCRIBER" },
   { 3, "P_BALANCE_QUERY_UNAUTHORIZED_APPLICATION" },
   { 4, "P_BALANCE_QUERY_SYSTEM_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpTransactionHistoryStatus:1.0
 */
static const value_string org_csapi_am_TpTransactionHistoryStatus[] = {

   { 0, "P_AM_TRANSACTION_ERROR_UNSPECIFIED" },
   { 1, "P_AM_TRANSACTION_INVALID_INTERVAL" },
   { 2, "P_AM_TRANSACTION_UNKNOWN_ACCOUNT" },
   { 3, "P_AM_TRANSACTION_UNAUTHORIZED_APPLICATION" },
   { 4, "P_AM_TRANSACTION_PROCESSING_ERROR" },
   { 5, "P_AM_TRANSACTION_SYSTEM_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/am/TpVoucherError:1.0
 */
static const value_string org_csapi_am_TpVoucherError[] = {

   { 0, "P_VOUCHER_OK" },
   { 1, "P_VOUCHER_UNDEFINED" },
   { 2, "P_VOUCHER_UNKNOWN_SUBSCRIBER" },
   { 3, "P_VOUCHER_UNAUTHORIZED_APPLICATION" },
   { 4, "P_VOUCHER_SYSTEM_FAILURE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpChargingParameterValueType:1.0
 */
static const value_string org_csapi_cs_TpChargingParameterValueType[] = {

   { 0, "P_CHS_PARAMETER_INT32" },
   { 1, "P_CHS_PARAMETER_FLOAT" },
   { 2, "P_CHS_PARAMETER_STRING" },
   { 3, "P_CHS_PARAMETER_BOOLEAN" },
   { 4, "P_CHS_PARAMETER_OCTETSET" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpChargingError:1.0
 */
static const value_string org_csapi_cs_TpChargingError[] = {

   { 0, "P_CHS_ERR_UNDEFINED" },
   { 1, "P_CHS_ERR_ACCOUNT" },
   { 2, "P_CHS_ERR_USER" },
   { 3, "P_CHS_ERR_PARAMETER" },
   { 4, "P_CHS_ERR_NO_DEBIT" },
   { 5, "P_CHS_ERR_NO_CREDIT" },
   { 6, "P_CHS_ERR_VOLUMES" },
   { 7, "P_CHS_ERR_CURRENCY" },
   { 8, "P_CHS_ERR_NO_EXTEND" },
   { 9, "P_CHS_ERR_RESERVATION_LIMIT" },
   { 10, "P_CHS_ERR_CONFIRMATION_REQUIRED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpSessionEndedCause:1.0
 */
static const value_string org_csapi_cs_TpSessionEndedCause[] = {

   { 0, "P_CHS_CAUSE_UNDEFINED" },
   { 1, "P_CHS_CAUSE_TIMER_EXPIRED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/cs/TpAppInformationType:1.0
 */
static const value_string org_csapi_cs_TpAppInformationType[] = {

   { 0, "P_APP_INF_TIMESTAMP" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyConditionListType:1.0
 */
static const value_string org_csapi_policy_TpPolicyConditionListType[] = {

   { 0, "P_PM_DNF" },
   { 1, "P_PM_CNF" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyConditionType:1.0
 */
static const value_string org_csapi_policy_TpPolicyConditionType[] = {

   { 0, "P_PM_TIME_PERIOD_CONDITION" },
   { 1, "P_PM_EVENT_CONDITION" },
   { 2, "P_PM_EXPRESSION_CONDITION" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyActionType:1.0
 */
static const value_string org_csapi_policy_TpPolicyActionType[] = {

   { 0, "P_PM_EVENT_ACTION" },
   { 1, "P_PM_EXPRESSION_ACTION" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/policy/TpPolicyTypeInfo:1.0
 */
static const value_string org_csapi_policy_TpPolicyTypeInfo[] = {

   { 0, "P_PM_SIMPLE_TYPE" },
   { 1, "P_PM_TYPE_RECORD" },
   { 2, "P_PM_TYPE_LIST" },
   { 3, "P_PM_STRUCTURED_TYPE" },
   { 4, "P_PM_XML_TYPE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMContextName:1.0
 */
static const value_string org_csapi_pam_TpPAMContextName[] = {

   { 0, "PAM_CONTEXT_ANY" },
   { 1, "PAM_CONTEXT_COMMUNICATION" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMACLDefault:1.0
 */
static const value_string org_csapi_pam_TpPAMACLDefault[] = {

   { 0, "PAM_ACCESS_ALLOW" },
   { 1, "PAM_ACCESS_DENY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMPreferenceType:1.0
 */
static const value_string org_csapi_pam_TpPAMPreferenceType[] = {

   { 0, "PAM_ACCESS_LIST" },
   { 1, "PAM_EXTERNAL_CONTROL" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMEventName:1.0
 */
static const value_string org_csapi_pam_TpPAMEventName[] = {

   { 0, "PAM_CE_IDENTITY_PRESENCE_SET" },
   { 1, "PAM_CE_AVAILABILITY_CHANGED" },
   { 2, "PAM_CE_WATCHERS_CHANGED" },
   { 3, "PAM_CE_IDENTITY_CREATED" },
   { 4, "PAM_CE_IDENTITY_DELETED" },
   { 5, "PAM_CE_GROUP_MEMBERSHIP_CHANGED" },
   { 6, "PAM_CE_AGENT_CREATED" },
   { 7, "PAM_CE_AGENT_DELETED" },
   { 8, "PAM_CE_AGENT_ASSIGNED" },
   { 9, "PAM_CE_AGENT_UNASSIGNED" },
   { 10, "PAM_CE_CAPABILITY_CHANGED" },
   { 11, "PAM_CE_AGENT_CAPABILITY_PRESENCE_SET" },
   { 12, "PAM_CE_AGENT_PRESENCE_SET" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMwatcherChangeType:1.0
 */
static const value_string org_csapi_pam_TpPAMwatcherChangeType[] = {

   { 0, "PAM_WATCHERS_PERIODIC" },
   { 1, "PAM_WATCHERS_ADDED" },
   { 2, "PAM_WATCHERS_DELETED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/pam/TpPAMErrorCause:1.0
 */
static const value_string org_csapi_pam_TpPAMErrorCause[] = {

   { 0, "P_PAM_CAUSE_UNDEFINED" },
   { 1, "P_PAM_CAUSE_INVALID_ADDRESS" },
   { 2, "P_PAM_CAUSE_SYSTEM_FAILURE" },
   { 3, "P_PAM_CAUSE_INFO_UNAVAILABLE" },
   { 4, "P_PAM_CAUSE_EVENT_REGISTRATION_CANCELLED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpFolderInfoPropertyName:1.0
 */
static const value_string org_csapi_mmm_TpFolderInfoPropertyName[] = {

   { 0, "P_MMM_FOLDER_UNDEFINED" },
   { 1, "P_MMM_FOLDER_DATE_CREATED" },
   { 2, "P_MMM_FOLDER_DATE_CHANGED" },
   { 3, "P_MMM_FOLDER_SIZE" },
   { 4, "P_MMM_FOLDER_NUMBER_OF_MESSAGES" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMailboxInfoPropertyName:1.0
 */
static const value_string org_csapi_mmm_TpMailboxInfoPropertyName[] = {

   { 0, "P_MMM_MAILBOX_UNDEFINED" },
   { 1, "P_MMM_MAILBOX_OWNER" },
   { 2, "P_MMM_MAILBOX_DATE_CREATED" },
   { 3, "P_MMM_MAILBOX_DATE_CHANGED" },
   { 4, "P_MMM_MAILBOX_SIZE" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageInfoPropertyName:1.0
 */
static const value_string org_csapi_mmm_TpMessageInfoPropertyName[] = {

   { 0, "P_MMM_MESSAGE_UNDEFINED" },
   { 1, "P_MMM_MESSAGE_DATE_CREATED" },
   { 2, "P_MMM_MESSAGE_DATE_RECEIVED" },
   { 3, "P_MMM_MESSAGE_DATE_CHANGED" },
   { 4, "P_MMM_MESSAGE_SIZE" },
   { 5, "P_MMM_MESSAGE_STATUS" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagePriority:1.0
 */
static const value_string org_csapi_mmm_TpMessagePriority[] = {

   { 0, "P_MMM_MESSAGE_PRIORITY_UNDEFINED" },
   { 1, "P_MMM_MESSAGE_PRIORITY_HIGH" },
   { 2, "P_MMM_MESSAGE_PRIORITY_LOW" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageHeaderFieldType:1.0
 */
static const value_string org_csapi_mmm_TpMessageHeaderFieldType[] = {

   { 0, "P_MESSAGE_DATE_SENT" },
   { 1, "P_MESSAGE_SENT_FROM" },
   { 2, "P_MESSAGE_SENDER" },
   { 3, "P_MESSAGE_REPLY_TO" },
   { 4, "P_MESSAGE_SENT_TO" },
   { 5, "P_MESSAGE_CC_TO" },
   { 6, "P_MESSAGE_BCC_TO" },
   { 7, "P_MESSAGE_RFC822_MESSAGE_ID" },
   { 8, "P_MESSAGE_IN_REPLY_TO" },
   { 9, "P_MESSAGE_REFERENCES" },
   { 10, "P_MESSAGE_SUBJECT" },
   { 11, "P_MESSAGE_COMMENTS" },
   { 12, "P_MESSAGE_KEYWORDS" },
   { 13, "P_MESSAGE_TRACE_FIELD" },
   { 14, "P_MESSAGE_RESENT_FIELD" },
   { 15, "P_MESSAGE_MIME_VERSION" },
   { 16, "P_MESSAGE_MIME_CONTENT" },
   { 17, "P_MESSAGE_MIME_ENCODING" },
   { 18, "P_MESSAGE_MIME_ID" },
   { 19, "P_MESSAGE_MIME_DESCRIPTION" },
   { 20, "P_MESSAGE_MIME_DISPOSITION" },
   { 21, "P_MESSAGE_MIME_EXTENSION_FIELD" },
   { 22, "P_MESSAGE_EXTENSION_FIELD" },
   { 23, "P_MESSAGE_PRIORITY" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMailboxMessageStatus:1.0
 */
static const value_string org_csapi_mmm_TpMailboxMessageStatus[] = {

   { 0, "P_MMM_RECEIVED_MSG_STATUS_READ" },
   { 1, "P_MMM_RECEIVED_MSG_STATUS_UNREAD" },
   { 2, "P_MMM_RECEIVED_MSG_STATUS_FORWARDED" },
   { 3, "P_MMM_RECEIVED_MSG_STATUS_REPLIED_TO" },
   { 4, "P_MMM_DRAFT_MSG_STATUS_SAVED_OR_UNSENT" },
   { 5, "P_MMM_SENT_MSG_STATUS_SENT" },
   { 6, "P_MMM_SENT_MSG_STATUS_DELIVERED" },
   { 7, "P_MMM_SENT_MSG_STATUS_READ" },
   { 8, "P_MMM_SENT_MSG_STATUS_DELETED_UNREAD" },
   { 9, "P_MMM_SENT_MSG_STATUS_NOT_DELIVERABLE" },
   { 10, "P_MMM_SENT_MSG_STATUS_EXPIRED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpSetPropertyError:1.0
 */
static const value_string org_csapi_mmm_TpSetPropertyError[] = {

   { 0, "P_MMM_PROPERTY_NOT_SET" },
   { 1, "P_MMM_PROPERTY_READONLY" },
   { 2, "P_MMM_PROPERTY_INSUFFICIENT_PRIVILEGE" },
   { 3, "P_MMM_PROPERTY_NAME_UNKNOWN" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagingEventName:1.0
 */
static const value_string org_csapi_mmm_TpMessagingEventName[] = {

   { 0, "P_EVENT_MSG_NAME_UNDEFINED" },
   { 1, "P_EVENT_MSG_NEW_MAILBOX_MESSAGE_ARRIVED" },
   { 2, "P_EVENT_MSG_NEW_MESSAGE_ARRIVED" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpDeliveryTimeType:1.0
 */
static const value_string org_csapi_mmm_TpDeliveryTimeType[] = {

   { 0, "P_MMM_SEND_IMMEDIATE" },
   { 1, "P_MMM_DELIVERY_TIME" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessageTreatmentType:1.0
 */
static const value_string org_csapi_mmm_TpMessageTreatmentType[] = {

   { 0, "P_MMM_TREATMENT_UNDEFINED" },
   { 1, "P_MMM_TREATMENT_REPORT_REQUESTED" },
   { 2, "P_MMM_TREATMENT_BILLING_ID" },
   { 3, "P_MMM_TREATMENT_DELIVERY_TIME" },
   { 4, "P_MMM_TREATMENT_VALIDITY_TIME" },
   { 0,       NULL },
};

/*
 * Enum = IDL:org/csapi/mmm/TpMessagingError:1.0
 */
static const value_string org_csapi_mmm_TpMessagingError[] = {

   { 0, "P_MMM_ERROR_UNDEFINED" },
   { 1, "P_MMM_ERROR_INVALID_AUTHENTICATION_INFORMATION" },
   { 2, "P_MMM_ERROR_INVALID_MAILBOX" },
   { 3, "P_MMM_ERROR_INVALID_DELIVERY_TYPE" },
   { 4, "P_MMM_ERROR_MAX_MESSAGE_SIZE_EXCEEDED" },
   { 5, "P_MMM_ERROR_INVALID_FOLDER_ID" },
   { 6, "P_MMM_ERROR_INVALID_MESSAGE_ID" },
   { 7, "P_MMM_ERROR_INVALID_PART_ID" },
   { 8, "P_MMM_ERROR_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH" },
   { 9, "P_MMM_ERROR_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH" },
   { 10, "P_MMM_ERROR_INVALID_DELIVERY_TIME" },
   { 11, "P_MMM_ERROR_INVALID_VALIDITY_TIME" },
   { 12, "P_MMM_ERROR_MAX_SUBJECT_SIZE_EXCEEDED" },
   { 13, "P_MMM_ERROR_INVALID_ID" },
   { 14, "P_MMM_ERROR_INVALID_NESTING_LEVEL" },
   { 15, "P_MMM_ERROR_INVALID_CRITERIA" },
   { 16, "P_MMM_ERROR_INFORMATION_NOT_AVAILABLE" },
   { 17, "P_MMM_ERROR_CANNOT_CANCEL" },
   { 18, "P_MMM_ERROR_INVALID_HEADER" },
   { 19, "P_MMM_INVALID_NETWORK_STATE" },
   { 20, "P_MMM_ERROR_RESOURCE_UNAVAILABLE" },
   { 21, "P_MMM_ERROR_RESOURCE_TIMEOUT" },
   { 0,       NULL },
};

/*
 * IDL Enums End
 */

/*  Begin Exception Helper Functions  */


/* Exception = IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0 */
static void
decode_ex_org_csapi_P_INVALID_ASSIGNMENT_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ASSIGNMENT_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0 */
static void
decode_ex_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_TIME_AND_DATE_FORMAT_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0 */
static void
decode_ex_org_csapi_P_INVALID_EVENT_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_EVENT_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0 */
static void
decode_ex_org_csapi_P_INVALID_INTERFACE_NAME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_INTERFACE_NAME_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0 */
static void
decode_ex_org_csapi_P_INVALID_INTERFACE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_INTERFACE_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0 */
static void
decode_ex_org_csapi_P_UNKNOWN_SUBSCRIBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SUBSCRIBER_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0 */
static void
decode_ex_org_csapi_P_INFORMATION_NOT_AVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INFORMATION_NOT_AVAILABLE_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_CRITERIA:1.0 */
static void
decode_ex_org_csapi_P_INVALID_CRITERIA(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_CRITERIA_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_SESSION_ID:1.0 */
static void
decode_ex_org_csapi_P_INVALID_SESSION_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SESSION_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/TpCommonExceptions:1.0 */
static void
decode_ex_org_csapi_TpCommonExceptions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCommonExceptions_ExceptionType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCommonExceptions_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_CURRENCY:1.0 */
static void
decode_ex_org_csapi_P_INVALID_CURRENCY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_CURRENCY_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_AMOUNT:1.0 */
static void
decode_ex_org_csapi_P_INVALID_AMOUNT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_AMOUNT_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0 */
static void
decode_ex_org_csapi_P_APPLICATION_NOT_ACTIVATED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_APPLICATION_NOT_ACTIVATED_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_ADDRESS:1.0 */
static void
decode_ex_org_csapi_P_INVALID_ADDRESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ADDRESS_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0 */
static void
decode_ex_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNSUPPORTED_ADDRESS_PLAN_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0 */
static void
decode_ex_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNAUTHORISED_PARAMETER_VALUE_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_VERSION:1.0 */
static void
decode_ex_org_csapi_P_INVALID_VERSION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_VERSION_ExtraInformation");

}

/* Exception = IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0 */
static void
decode_ex_org_csapi_P_INVALID_NETWORK_STATE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_NETWORK_STATE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SERVICE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0 */
static void
decode_ex_org_csapi_fw_P_SERVICE_ACCESS_DENIED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_SERVICE_ACCESS_DENIED_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_ACCESS_DENIED:1.0 */
static void
decode_ex_org_csapi_fw_P_ACCESS_DENIED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ACCESS_DENIED_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0 */
static void
decode_ex_org_csapi_fw_P_SERVICE_NOT_ENABLED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_SERVICE_NOT_ENABLED_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0 */
static void
decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_AGREEMENT_TEXT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_AGREEMENT_TEXT_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SERVICE_TOKEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SERVICE_TOKEN_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SIGNATURE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SIGNATURE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SIGNING_ALGORITHM_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_DOMAIN_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_DOMAIN_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_PROPERTY_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_ACCESS_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ACCESS_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0 */
static void
decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_SERVICE_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0 */
static void
decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SERVICE_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0 */
static void
decode_ex_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MISSING_MANDATORY_PROPERTY_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0 */
static void
decode_ex_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_DUPLICATE_PROPERTY_NAME_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0 */
static void
decode_ex_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PROPERTY_TYPE_MISMATCH_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_CLIENT_APP_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_CLIENT_APP_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_AUTH_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_AUTH_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SAG_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SAG_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SERVICE_PROFILE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SERVICE_CONTRACT_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ACTIVITY_TEST_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_SERVICE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0 */
static void
decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SERVICE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0 */
static void
decode_ex_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_SERVICE_TYPE_UNAVAILABLE_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_ADDITION_TO_SAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ADDITION_TO_SAG_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0 */
static void
decode_ex_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0 */
static void
decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM_ExtraInformation");

}

/* Exception = IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0 */
static void
decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_NO_ACCEPTABLE_SIGNING_ALGORITHM_ExtraInformation");

}

/* Exception = IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0 */
static void
decode_ex_org_csapi_ui_P_ID_NOT_FOUND(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ID_NOT_FOUND_ExtraInformation");

}

/* Exception = IDL:org/csapi/ui/P_ILLEGAL_ID:1.0 */
static void
decode_ex_org_csapi_ui_P_ILLEGAL_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0 */
static void
decode_ex_org_csapi_ui_P_ILLEGAL_RANGE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_RANGE_ExtraInformation");

}

/* Exception = IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0 */
static void
decode_ex_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_COLLECTION_CRITERIA_ExtraInformation");

}

/* Exception = IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0 */
static void
decode_ex_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED_ExtraInformation");

}

/* Exception = IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0 */
static void
decode_ex_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED_ExtraInformation");

}

/* Exception = IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0 */
static void
decode_ex_org_csapi_mm_P_INVALID_REPORTING_INTERVAL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_REPORTING_INTERVAL_ExtraInformation");

}

/* Exception = IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0 */
static void
decode_ex_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED_ExtraInformation");

}

/* Exception = IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0 */
static void
decode_ex_org_csapi_termcap_P_INVALID_TERMINAL_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_TERMINAL_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_INVALID_FOLDER_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_INVALID_FOLDER_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_INSUFFICIENT_PRIVILEGE_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_INVALID_AUTHENTICATION_INFORMATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_INVALID_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_INVALID_MAILBOX_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_INVALID_MESSAGE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_LOCKING_LOCKED_MAILBOX_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_MESSAGE_NOT_REMOVED_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_NUMBER_NOT_POSITIVE_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_UNLOCKING_UNLOCKED_MAILBOX_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_MAILBOX_LOCKED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_MAILBOX_LOCKED_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_CANNOT_UNLOCK_MAILBOX_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_PROPERTY_NOT_SET(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_PROPERTY_NOT_SET_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_FOLDER_IS_OPEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_FOLDER_IS_OPEN_ExtraInformation");

}

/* Exception = IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0 */
static void
decode_ex_org_csapi_gms_P_GMS_MAILBOX_OPEN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_GMS_MAILBOX_OPEN_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_VPRP_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_VPRP_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SLA_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SLA_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_STATUS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_STATUS_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_QOS_INFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_QOS_INFO_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_VALIDITY_INFO_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_PIPEQOSINFO_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_DSCODEPOINT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_DSCODEPOINT_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_VPRPID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_VPRPID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_REF_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_REF_VALUE_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_INTERFACE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_INTERFACE_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0 */
static void
decode_ex_org_csapi_cm_P_CANT_DELETE_VPRP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_CANT_DELETE_VPRP_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_TEMPLATES_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_MENU(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_MENU_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_ENTERPRISE_NETWORK_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_TEMPLATE_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_DESCRIPTION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_DESCRIPTION_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_SLA_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_SLA_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_TAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_TAG_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_VALUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_VALUE_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_COMBINATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_COMBINATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SITES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SITES_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_VPRN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_VPRN_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0 */
static void
decode_ex_org_csapi_cm_P_ILLEGAL_SITE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ILLEGAL_SITE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SITE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SITE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SAPS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SAPS_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SITE_LOCATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SITE_LOCATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SITE_DESCRIPTION_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_IPSUBNET(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_IPSUBNET_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_SAP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_SAP_ExtraInformation");

}

/* Exception = IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0 */
static void
decode_ex_org_csapi_cm_P_UNKNOWN_VPRP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNKNOWN_VPRP_ExtraInformation");

}

/* Exception = IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0 */
static void
decode_ex_org_csapi_am_P_UNAUTHORIZED_APPLICATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_UNAUTHORIZED_APPLICATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/cs/P_INVALID_USER:1.0 */
static void
decode_ex_org_csapi_cs_P_INVALID_USER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_USER_ExtraInformation");

}

/* Exception = IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0 */
static void
decode_ex_org_csapi_cs_P_INVALID_ACCOUNT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_ACCOUNT_ExtraInformation");

}

/* Exception = IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0 */
static void
decode_ex_org_csapi_cs_P_INVALID_REQUEST_NUMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_REQUEST_NUMBER_ExtraInformation");

}

/* Exception = IDL:org/csapi/cs/P_INVALID_VOLUME:1.0 */
static void
decode_ex_org_csapi_cs_P_INVALID_VOLUME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_INVALID_VOLUME_ExtraInformation");

}

/* Exception = IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0 */
static void
decode_ex_org_csapi_policy_P_ACCESS_VIOLATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_ACCESS_VIOLATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0 */
static void
decode_ex_org_csapi_policy_P_SYNTAX_ERROR(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_SYNTAX_ERROR_ExtraInformation");

}

/* Exception = IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0 */
static void
decode_ex_org_csapi_policy_P_NAME_SPACE_ERROR(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_NAME_SPACE_ERROR_ExtraInformation");

}

/* Exception = IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0 */
static void
decode_ex_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_NO_TRANSACTION_IN_PROCESS_ExtraInformation");

}

/* Exception = IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0 */
static void
decode_ex_org_csapi_policy_P_TRANSACTION_IN_PROCESS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_TRANSACTION_IN_PROCESS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_MEMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_MEMBER_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_IDENTITY_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_GROUP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_GROUP_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_CAPABILITY_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_ATTRIBUTES_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_ATTRIBUTE_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_ASSIGNMENT_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ALIAS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_ALIAS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNKNOWN_AGENT(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNKNOWN_AGENT_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNASSIGNED_ALIAS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_TYPE_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_TYPE_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_TYPE_ASSOCIATED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_TYPE_ASSOCIATED_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_NOT_REGISTERED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_NOT_REGISTERED_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_NOT_MEMBER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_NOT_MEMBER_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_NO_CAPABILITY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_NO_CAPABILITY_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_MEMBER_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_MEMBER_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_IS_CYCLIC(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_IS_CYCLIC_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_IDENTITY_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_IDENTITY_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_DISASSOCIATED_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_ATTRIBUTE_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_ALIAS_NOT_UNIQUE_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_ALIAS_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_ALIAS_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_AGENT_EXISTS(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_AGENT_EXISTS_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_UNAVAILABLE_INTERFACE_ExtraInformation");

}

/* Exception = IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0 */
static void
decode_ex_org_csapi_pam_P_PAM_INVALID_CREDENTIAL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_PAM_INVALID_CREDENTIAL_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_AUTHENTICATION_INFORMATION_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_MAILBOX(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_MAILBOX_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_DELIVERY_TYPE_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_MAX_MESSAGE_SIZE_EXCEEDED_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_FOLDER_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_MESSAGE_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_PART_ID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_PART_ID_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_PROPERTY(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_PROPERTY_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_DELIVERY_TIME_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_VALIDITY_TIME_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_MAX_SUBJECT_SIZE_EXCEEDED_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INFORMATION_NOT_AVAILABLE_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_CANNOT_CANCEL(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_CANNOT_CANCEL_ExtraInformation");

}

/* Exception = IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0 */
static void
decode_ex_org_csapi_mmm_P_MMM_INVALID_HEADER(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "P_MMM_INVALID_HEADER_ExtraInformation");

}


/*  End Exception Helper Functions  */

/*
 * Main delegator for exception handling
 *
 */
static gboolean
decode_user_exception(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *ptree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    /*gboolean stream_is_big_endian _U_;*/                        /* big endianess */
    proto_tree *tree _U_;

    if (!header->exception_id)
        return FALSE;

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_ASSIGNMENT_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_ASSIGNMENT_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_TIME_AND_DATE_FORMAT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_TIME_AND_DATE_FORMAT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_EVENT_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_EVENT_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_INTERFACE_NAME(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_INTERFACE_NAME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_INTERFACE_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_INTERFACE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNKNOWN_SUBSCRIBER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_UNKNOWN_SUBSCRIBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INFORMATION_NOT_AVAILABLE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INFORMATION_NOT_AVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_CRITERIA:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_CRITERIA(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_CRITERIA:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_SESSION_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_SESSION_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_SESSION_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/TpCommonExceptions:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_TpCommonExceptions(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/TpCommonExceptions:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_CURRENCY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_CURRENCY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_CURRENCY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_AMOUNT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_AMOUNT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_AMOUNT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_APPLICATION_NOT_ACTIVATED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_APPLICATION_NOT_ACTIVATED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_ADDRESS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_ADDRESS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_ADDRESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNSUPPORTED_ADDRESS_PLAN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_UNSUPPORTED_ADDRESS_PLAN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_UNAUTHORISED_PARAMETER_VALUE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_UNAUTHORISED_PARAMETER_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_VERSION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_VERSION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_VERSION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_P_INVALID_NETWORK_STATE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/P_INVALID_NETWORK_STATE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_ACCESS_DENIED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_SERVICE_ACCESS_DENIED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_ACCESS_DENIED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ACCESS_DENIED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_ACCESS_DENIED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_NOT_ENABLED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_SERVICE_NOT_ENABLED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_ENCRYPTION_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_AGREEMENT_TEXT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_AGREEMENT_TEXT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_TOKEN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_TOKEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SIGNATURE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SIGNATURE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SIGNING_ALGORITHM(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SIGNING_ALGORITHM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_DOMAIN_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_DOMAIN_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_PROPERTY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ACCESS_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_ACCESS_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_ILLEGAL_SERVICE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_UNKNOWN_SERVICE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_MISSING_MANDATORY_PROPERTY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_MISSING_MANDATORY_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_DUPLICATE_PROPERTY_NAME(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_DUPLICATE_PROPERTY_NAME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_PROPERTY_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_PROPERTY_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_CLIENT_APP_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_CLIENT_APP_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_AUTH_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_AUTH_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SAG_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SAG_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_PROFILE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_PROFILE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SERVICE_CONTRACT_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SERVICE_CONTRACT_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ACTIVITY_TEST_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_ACTIVITY_TEST_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_ILLEGAL_SERVICE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_ILLEGAL_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_UNKNOWN_SERVICE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_UNKNOWN_SERVICE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_SERVICE_TYPE_UNAVAILABLE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_SERVICE_TYPE_UNAVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_ADDITION_TO_SAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_ADDITION_TO_SAG:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_INVALID_SAG_TO_SERVICE_PROFILE_ASSIGNMENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_AUTHENTICATION_MECHANISM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_fw_P_NO_ACCEPTABLE_SIGNING_ALGORITHM(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/fw/P_NO_ACCEPTABLE_SIGNING_ALGORITHM:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ID_NOT_FOUND(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/ui/P_ID_NOT_FOUND:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/ui/P_ILLEGAL_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ILLEGAL_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/ui/P_ILLEGAL_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_ILLEGAL_RANGE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/ui/P_ILLEGAL_RANGE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_ui_P_INVALID_COLLECTION_CRITERIA(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/ui/P_INVALID_COLLECTION_CRITERIA:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mm/P_REQUESTED_ACCURACY_CANNOT_BE_DELIVERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mm/P_REQUESTED_RESPONSE_TIME_CANNOT_BE_DELIVERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_INVALID_REPORTING_INTERVAL(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mm/P_INVALID_REPORTING_INTERVAL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mm_P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mm/P_TRIGGER_CONDITIONS_NOT_SUBSCRIBED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_termcap_P_INVALID_TERMINAL_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/termcap/P_INVALID_TERMINAL_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_FOLDER_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_INVALID_FOLDER_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INSUFFICIENT_PRIVILEGE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_INSUFFICIENT_PRIVILEGE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_AUTHENTICATION_INFORMATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_INVALID_AUTHENTICATION_INFORMATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_MAILBOX(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_INVALID_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_INVALID_MESSAGE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_INVALID_MESSAGE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_LOCKING_LOCKED_MAILBOX(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_LOCKING_LOCKED_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MESSAGE_NOT_REMOVED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_MESSAGE_NOT_REMOVED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_NUMBER_NOT_POSITIVE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_NUMBER_NOT_POSITIVE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_UNLOCKING_UNLOCKED_MAILBOX(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_UNLOCKING_UNLOCKED_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MAILBOX_LOCKED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_MAILBOX_LOCKED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_CANNOT_UNLOCK_MAILBOX(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_CANNOT_UNLOCK_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_PROPERTY_NOT_SET(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_PROPERTY_NOT_SET:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_FOLDER_IS_OPEN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_FOLDER_IS_OPEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_gms_P_GMS_MAILBOX_OPEN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/gms/P_GMS_MAILBOX_OPEN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRP_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRP_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SLA_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SLA_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_STATUS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_STATUS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_QOS_INFO(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_QOS_INFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VALIDITY_INFO(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_VALIDITY_INFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_PIPEQOSINFO(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_PIPEQOSINFO:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_DSCODEPOINT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_DSCODEPOINT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_VPRPID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_VPRPID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_REF_VALUE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_REF_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_INTERFACE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_INTERFACE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_CANT_DELETE_VPRP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_CANT_DELETE_VPRP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATES(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_TEMPLATES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_MENU(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_MENU:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_ENTERPRISE_NETWORK(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_ENTERPRISE_NETWORK:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_TEMPLATE_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_TEMPLATE_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_DESCRIPTION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_DESCRIPTION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_SLA_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_SLA_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_TAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_TAG:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_VALUE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_VALUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_COMBINATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_COMBINATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITES(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRN:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_ILLEGAL_SITE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_ILLEGAL_SITE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SAPS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SAPS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_LOCATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_LOCATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SITE_DESCRIPTION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SITE_DESCRIPTION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_IPSUBNET(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_IPSUBNET:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_SAP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_SAP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cm_P_UNKNOWN_VPRP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cm/P_UNKNOWN_VPRP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_am_P_UNAUTHORIZED_APPLICATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/am/P_UNAUTHORIZED_APPLICATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cs/P_INVALID_USER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_USER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cs/P_INVALID_USER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_ACCOUNT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cs/P_INVALID_ACCOUNT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_REQUEST_NUMBER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cs/P_INVALID_REQUEST_NUMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/cs/P_INVALID_VOLUME:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_cs_P_INVALID_VOLUME(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/cs/P_INVALID_VOLUME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_ACCESS_VIOLATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/policy/P_ACCESS_VIOLATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_SYNTAX_ERROR(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/policy/P_SYNTAX_ERROR:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_NAME_SPACE_ERROR(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/policy/P_NAME_SPACE_ERROR:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_NO_TRANSACTION_IN_PROCESS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/policy/P_NO_TRANSACTION_IN_PROCESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_policy_P_TRANSACTION_IN_PROCESS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/policy/P_TRANSACTION_IN_PROCESS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_MEMBER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_MEMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_IDENTITY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_IDENTITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_GROUP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_GROUP:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_CAPABILITY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTES(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTES:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ATTRIBUTE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ATTRIBUTE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ASSIGNMENT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ASSIGNMENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_ALIAS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_ALIAS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNKNOWN_AGENT(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNKNOWN_AGENT:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNASSIGNED_ALIAS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNASSIGNED_ALIAS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_TYPE_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_TYPE_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_TYPE_ASSOCIATED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_TYPE_ASSOCIATED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NOT_REGISTERED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_NOT_REGISTERED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NOT_MEMBER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_NOT_MEMBER:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_NO_CAPABILITY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_NO_CAPABILITY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_MEMBER_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_MEMBER_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_IS_CYCLIC(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_IS_CYCLIC:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_IDENTITY_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_IDENTITY_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_DISASSOCIATED_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_DISASSOCIATED_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ATTRIBUTE_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_ATTRIBUTE_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ALIAS_NOT_UNIQUE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_ALIAS_NOT_UNIQUE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_ALIAS_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_ALIAS_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_AGENT_EXISTS(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_AGENT_EXISTS:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_UNAVAILABLE_INTERFACE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_UNAVAILABLE_INTERFACE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_pam_P_PAM_INVALID_CREDENTIAL(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/pam/P_PAM_INVALID_CREDENTIAL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_AUTHENTICATION_INFORMATION(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_AUTHENTICATION_INFORMATION:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_MAILBOX(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_MAILBOX:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TYPE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TYPE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_MAX_MESSAGE_SIZE_EXCEEDED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_MAX_MESSAGE_SIZE_EXCEEDED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_FOLDER_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_FOLDER_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_MESSAGE_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_MESSAGE_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_PART_ID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_PART_ID:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_ADDRESS_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_DELIVERY_TYPE_MESSAGE_TYPE_MISMATCH:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_PROPERTY(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_PROPERTY:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_DELIVERY_TIME(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_DELIVERY_TIME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_VALIDITY_TIME(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_VALIDITY_TIME:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_MAX_SUBJECT_SIZE_EXCEEDED(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_MAX_SUBJECT_SIZE_EXCEEDED:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INFORMATION_NOT_AVAILABLE(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INFORMATION_NOT_AVAILABLE:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_CANNOT_CANCEL(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_CANNOT_CANCEL:1.0  */
       return TRUE;
    }

    if (strcmp(header->exception_id, "IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0") == 0) {
       tree = start_dissecting(tvb, pinfo, ptree, offset);
       decode_ex_org_csapi_mmm_P_MMM_INVALID_HEADER(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);   /*  IDL:org/csapi/mmm/P_MMM_INVALID_HEADER:1.0  */
       return TRUE;
    }



    return FALSE;    /* user exception not found */

}

/*  Begin Attribute Helper Functions  */


/*  End Attribute Helper Functions  */

/*
 * IDL:org/csapi/IpService/setCallback:1.0
 */

static void
decode_org_csapi_IpService_setCallback(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/IpService/setCallbackWithSessionID:1.0
 */

static void
decode_org_csapi_IpService_setCallbackWithSessionID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpInitial/initiateAuthentication:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

        

        decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpAuthDomain"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authType");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

            

            decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpAuthDomain"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpInitial/initiateAuthenticationWithVersion:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

        

        decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpAuthDomain"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authType");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "frameworkVersion");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpAuthDomain"  */

            

            decode_org_csapi_fw_TpAuthDomain_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpAuthDomain"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAuthentication/requestAccess:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "accessType");

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAccess/terminateAccess:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminationText");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signingAlgorithm");

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/obtainInterface:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/obtainInterfaceWithCallback:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/endAccess:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_endAccessProperties;
    guint32   i_endAccessProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_endAccessProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of endAccessProperties = %u",u_octet4_loop_endAccessProperties);
        }

        for (i_endAccessProperties=0; i_endAccessProperties < u_octet4_loop_endAccessProperties; i_endAccessProperties++) {

            /*  Begin struct "org_csapi_fw_TpProperty"  */

            

            decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/listInterfaces:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpInterfaceNameList;
    guint32   i_TpInterfaceNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpInterfaceNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpInterfaceNameList = %u",u_octet4_loop_TpInterfaceNameList);
            }

            for (i_TpInterfaceNameList=0; i_TpInterfaceNameList < u_octet4_loop_TpInterfaceNameList; i_TpInterfaceNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpInterfaceNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/releaseInterface:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/selectSigningAlgorithm:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signingAlgorithmCaps");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSigningAlgorithm");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/terminateAccess:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminationText");

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAccess/relinquishInterface:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminationText");

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/authenticate:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/abortAuthentication:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/authenticationSucceeded:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication/challenge:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/selectEncryptionMethod:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "encryptionCaps");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpEncryptionCapability");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/authenticate:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/abortAuthentication:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/authenticationSucceeded:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/selectAuthenticationMechanism:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authMechanismList");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAuthMechanism");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication/challenge:1.0
 */

static void
decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_challenge;
    guint32   i_challenge;
    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_challenge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of challenge = %u",u_octet4_loop_challenge);
        }

        for (i_challenge=0; i_challenge < u_octet4_loop_challenge; i_challenge++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"challenge = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpAppEventNotification/reportNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpAppEventNotification/notificationTerminated:1.0
 */

static void
decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpEventNotification/createNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_notification_IpEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/notification/IpEventNotification/destroyNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/activityTestRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "activityTestResult");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/appActivityTestReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwFaultReportInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwFaultRecoveryInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/svcUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/activityTestErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/appUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/genFaultStatsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/svcAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_faultStatistics;
    guint32   i_faultStatistics;
    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_faultStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of faultStatistics = %u",u_octet4_loop_faultStatistics);
        }

        for (i_faultStatistics=0; i_faultStatistics < u_octet4_loop_faultStatistics; i_faultStatistics++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatistics  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
            }

        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppFaultManager/fwAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryAppLoadReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/loadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/resumeNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/suspendNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/createLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/destroyLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryAppLoadStatsReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadStatsRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppLoadManager/queryLoadStatsErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/reportLoad:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadLevel  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryLoadReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/createLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/destroyLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/resumeNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/suspendNotification:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryLoadStatsReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadStatsRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpLoadManager/queryAppLoadStatsErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppOAM/systemDateTimeQuery:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "systemDateAndTime");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDateAndTime");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpOAM/systemDateTimeQuery:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientDateAndTime");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDateAndTime");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/activityTestReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "svcID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appActivityTestRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "activityTestResult");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/svcUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appActivityTestErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/genFaultStatsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/appAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpAppAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/enableHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/disableHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt/changeInterval:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeat/pulse:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpHeartBeat/pulse:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/enableAppHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/disableAppHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt/changeInterval:1.0
 */

static void
decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/listServiceTypes:1.0
 */

static void
decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeNameList;
    guint32   i_TpServiceTypeNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeNameList);
            }

            for (i_TpServiceTypeNameList=0; i_TpServiceTypeNameList < u_octet4_loop_TpServiceTypeNameList; i_TpServiceTypeNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypeNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/describeServiceType:1.0
 */

static void
decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "name");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceTypeDescription"  */

            

            decode_org_csapi_fw_TpServiceTypeDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceTypeDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/discoverService:1.0
 */

static void
decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_desiredPropertyList;
    guint32   i_desiredPropertyList;
    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceTypeName");

        u_octet4_loop_desiredPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of desiredPropertyList = %u",u_octet4_loop_desiredPropertyList);
        }

        for (i_desiredPropertyList=0; i_desiredPropertyList < u_octet4_loop_desiredPropertyList; i_desiredPropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"max = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/discovery/IpServiceDiscovery/listSubscribedServices:1.0
 */

static void
decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement/signServiceAgreement:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpOctetSet;
    guint32   i_TpOctetSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceToken");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agreementText");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signingAlgorithm");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpOctetSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpOctetSet = %u",u_octet4_loop_TpOctetSet);
            }

            for (i_TpOctetSet=0; i_TpOctetSet < u_octet4_loop_TpOctetSet; i_TpOctetSet++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpOctetSet = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement/terminateServiceAgreement:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceToken");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminationText");

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/signServiceAgreement:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceToken");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agreementText");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signingAlgorithm");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpSignatureAndServiceMgr"  */

            

            decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpSignatureAndServiceMgr"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/terminateServiceAgreement:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_digitalSignature;
    guint32   i_digitalSignature;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceToken");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminationText");

        u_octet4_loop_digitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of digitalSignature = %u",u_octet4_loop_digitalSignature);
        }

        for (i_digitalSignature=0; i_digitalSignature < u_octet4_loop_digitalSignature; i_digitalSignature++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"digitalSignature = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/selectService:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceToken");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement/initiateSignServiceAgreement:1.0
 */

static void
decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceToken");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/createServiceProfile:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

        

        decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileID");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/modifyServiceProfile:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceProfile"  */

        

        decode_org_csapi_fw_TpServiceProfile_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceProfile"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/deleteServiceProfile:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceProfileID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/assign:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceProfileID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/deassign:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceProfileID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement/requestConflictInfo:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAssignSagToServiceProfileConflictList;
    guint32   i_TpAssignSagToServiceProfileConflictList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAssignSagToServiceProfileConflictList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAssignSagToServiceProfileConflictList = %u",u_octet4_loop_TpAssignSagToServiceProfileConflictList);
            }

            for (i_TpAssignSagToServiceProfileConflictList=0; i_TpAssignSagToServiceProfileConflictList < u_octet4_loop_TpAssignSagToServiceProfileConflictList; i_TpAssignSagToServiceProfileConflictList++) {

                /*  Begin struct "org_csapi_fw_TpAssignSagToServiceProfileConflict"  */

                

                decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpAssignSagToServiceProfileConflict"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/listServiceProfiles:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceProfileIDList;
    guint32   i_TpServiceProfileIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceProfileIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileIDList = %u",u_octet4_loop_TpServiceProfileIDList);
            }

            for (i_TpServiceProfileIDList=0; i_TpServiceProfileIDList < u_octet4_loop_TpServiceProfileIDList; i_TpServiceProfileIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/describeServiceProfile:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceProfileID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

            

            decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery/listAssignedMembers:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceProfileID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/createServiceContract:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

        

        decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractID");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/modifyServiceContract:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpServiceContract"  */

        

        decode_org_csapi_fw_TpServiceContract_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceContract"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement/deleteServiceContract:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceContractID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/describeServiceContract:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceContractID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

            

            decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/listServiceContracts:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceContractIDList;
    guint32   i_TpServiceContractIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceContractIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceContractIDList = %u",u_octet4_loop_TpServiceContractIDList);
            }

            for (i_TpServiceContractIDList=0; i_TpServiceContractIDList < u_octet4_loop_TpServiceContractIDList; i_TpServiceContractIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery/listServiceProfiles:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceProfileIDList;
    guint32   i_TpServiceProfileIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceContractID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceProfileIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileIDList = %u",u_octet4_loop_TpServiceProfileIDList);
            }

            for (i_TpServiceProfileIDList=0; i_TpServiceProfileIDList < u_octet4_loop_TpServiceProfileIDList; i_TpServiceProfileIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement/modifyEntOpAccount:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_enterpriseOperatorProperties;
    guint32   i_enterpriseOperatorProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_enterpriseOperatorProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of enterpriseOperatorProperties = %u",u_octet4_loop_enterpriseOperatorProperties);
        }

        for (i_enterpriseOperatorProperties=0; i_enterpriseOperatorProperties < u_octet4_loop_enterpriseOperatorProperties; i_enterpriseOperatorProperties++) {

            /*  Begin struct "org_csapi_fw_TpProperty"  */

            

            decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement/deleteEntOpAccount:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery/describeEntOpAccount:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpEntOp"  */

            

            decode_org_csapi_fw_TpEntOp_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpEntOp"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/createClientApp:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

        

        decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpClientAppDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/modifyClientApp:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

        

        decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpClientAppDescription"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/deleteClientApp:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/createSAG:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_clientAppIDs;
    guint32   i_clientAppIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpSag"  */

        

        decode_org_csapi_fw_TpSag_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpSag"  */

        u_octet4_loop_clientAppIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDs = %u",u_octet4_loop_clientAppIDs);
        }

        for (i_clientAppIDs=0; i_clientAppIDs < u_octet4_loop_clientAppIDs; i_clientAppIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/modifySAG:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpSag"  */

        

        decode_org_csapi_fw_TpSag_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpSag"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/deleteSAG:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/addSAGMembers:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_clientAppIDs;
    guint32   i_clientAppIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        u_octet4_loop_clientAppIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDs = %u",u_octet4_loop_clientAppIDs);
        }

        for (i_clientAppIDs=0; i_clientAppIDs < u_octet4_loop_clientAppIDs; i_clientAppIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/removeSAGMembers:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_clientAppIDList;
    guint32   i_clientAppIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        u_octet4_loop_clientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of clientAppIDList = %u",u_octet4_loop_clientAppIDList);
        }

        for (i_clientAppIDList=0; i_clientAppIDList < u_octet4_loop_clientAppIDList; i_clientAppIDList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppIDList");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement/requestConflictInfo:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAddSagMembersConflictList;
    guint32   i_TpAddSagMembersConflictList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAddSagMembersConflictList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAddSagMembersConflictList = %u",u_octet4_loop_TpAddSagMembersConflictList);
            }

            for (i_TpAddSagMembersConflictList=0; i_TpAddSagMembersConflictList < u_octet4_loop_TpAddSagMembersConflictList; i_TpAddSagMembersConflictList++) {

                /*  Begin struct "org_csapi_fw_TpAddSagMembersConflict"  */

                

                decode_org_csapi_fw_TpAddSagMembersConflict_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpAddSagMembersConflict"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/describeClientApp:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpClientAppDescription"  */

            

            decode_org_csapi_fw_TpClientAppDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpClientAppDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listClientApps:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpClientAppIDList;
    guint32   i_TpClientAppIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpClientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppIDList = %u",u_octet4_loop_TpClientAppIDList);
            }

            for (i_TpClientAppIDList=0; i_TpClientAppIDList < u_octet4_loop_TpClientAppIDList; i_TpClientAppIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpClientAppIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/describeSAG:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagDescription");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listSAGs:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listSAGMembers:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpClientAppIDList;
    guint32   i_TpClientAppIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sagID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpClientAppIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppIDList = %u",u_octet4_loop_TpClientAppIDList);
            }

            for (i_TpClientAppIDList=0; i_TpClientAppIDList < u_octet4_loop_TpClientAppIDList; i_TpClientAppIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpClientAppIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery/listClientAppMembership:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSagIDList;
    guint32   i_TpSagIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientAppID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSagIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSagIDList = %u",u_octet4_loop_TpSagIDList);
            }

            for (i_TpSagIDList=0; i_TpSagIDList < u_octet4_loop_TpSagIDList; i_TpSagIDList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagIDList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification/reportNotification:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification/notificationTerminated:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification/createNotification:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification/destroyNotification:1.0
 */

static void
decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/listServiceTypes:1.0
 */

static void
decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeNameList;
    guint32   i_TpServiceTypeNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeNameList);
            }

            for (i_TpServiceTypeNameList=0; i_TpServiceTypeNameList < u_octet4_loop_TpServiceTypeNameList; i_TpServiceTypeNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypeNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/describeServiceType:1.0
 */

static void
decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "name");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceTypeDescription"  */

            

            decode_org_csapi_fw_TpServiceTypeDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceTypeDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/discoverService:1.0
 */

static void
decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_desiredPropertyList;
    guint32   i_desiredPropertyList;
    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceTypeName");

        u_octet4_loop_desiredPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of desiredPropertyList = %u",u_octet4_loop_desiredPropertyList);
        }

        for (i_desiredPropertyList=0; i_desiredPropertyList < u_octet4_loop_desiredPropertyList; i_desiredPropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"max = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery/listRegisteredServices:1.0
 */

static void
decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceList;
    guint32   i_TpServiceList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpServiceList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceList = %u",u_octet4_loop_TpServiceList);
            }

            for (i_TpServiceList=0; i_TpServiceList < u_octet4_loop_TpServiceList; i_TpServiceList++) {

                /*  Begin struct "org_csapi_fw_TpService"  */

                

                decode_org_csapi_fw_TpService_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_fw_TpService"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager/createServiceManager:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceProperties;
    guint32   i_serviceProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "application");

        u_octet4_loop_serviceProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceProperties = %u",u_octet4_loop_serviceProperties);
        }

        for (i_serviceProperties=0; i_serviceProperties < u_octet4_loop_serviceProperties; i_serviceProperties++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceInstanceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager/destroyServiceManager:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceInstance");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/registerService:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_servicePropertyList;
    guint32   i_servicePropertyList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceTypeName");

        u_octet4_loop_servicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of servicePropertyList = %u",u_octet4_loop_servicePropertyList);
        }

        for (i_servicePropertyList=0; i_servicePropertyList < u_octet4_loop_servicePropertyList; i_servicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceID");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/announceServiceAvailability:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/unregisterService:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/describeService:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_fw_TpServiceDescription"  */

            

            decode_org_csapi_fw_TpServiceDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceDescription"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/unannounceService:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration/registerServiceSubType:1.0
 */

static void
decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_servicePropertyList;
    guint32   i_servicePropertyList;
    guint32   u_octet4_loop_extendedServicePropertyList;
    guint32   i_extendedServicePropertyList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceTypeName");

        u_octet4_loop_servicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of servicePropertyList = %u",u_octet4_loop_servicePropertyList);
        }

        for (i_servicePropertyList=0; i_servicePropertyList < u_octet4_loop_servicePropertyList; i_servicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

            

            decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceProperty"  */

        }

        u_octet4_loop_extendedServicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of extendedServicePropertyList = %u",u_octet4_loop_extendedServicePropertyList);
        }

        for (i_extendedServicePropertyList=0; i_extendedServicePropertyList < u_octet4_loop_extendedServicePropertyList; i_extendedServicePropertyList++) {

            /*  Begin struct "org_csapi_fw_TpServiceTypePropertyValue"  */

            

            decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpServiceTypePropertyValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceID");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/querySvcLoadReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/loadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/suspendNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/resumeNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/createLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/destroyLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/querySvcLoadStatsReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadStatsRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcLoadManager/queryLoadStatsErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/reportLoad:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadLevel  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/queryLoadReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"querySubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/createLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"notificationSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/destroyLoadLevelNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"notificationSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/suspendNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"notificationSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/resumeNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"notificationSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/queryLoadStatsReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"querySubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadStatsRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_loadStatistics;
    guint32   i_loadStatistics;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_loadStatistics = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of loadStatistics = %u",u_octet4_loop_loadStatistics);
        }

        for (i_loadStatistics=0; i_loadStatistics < u_octet4_loop_loadStatistics; i_loadStatistics++) {

            /*  Begin struct "org_csapi_fw_TpLoadStatistic"  */

            

            decode_org_csapi_fw_TpLoadStatistic_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_fw_TpLoadStatistic"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwLoadManager/querySvcLoadStatsErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"loadStatisticError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/activityTestRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "activityTestResult");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/svcActivityTestReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwFaultReportInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwFaultRecoveryInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/svcUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/appUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/activityTestErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/genFaultStatsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/appAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpAppAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcFaultManager/fwAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/activityTestReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"testSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcActivityTestRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "activityTestResult");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/appUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcUnavailableInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcUnavailReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcActivityTestErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"activityTestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/genFaultStatsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_serviceIDs;
    guint32   i_serviceIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        u_octet4_loop_serviceIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of serviceIDs = %u",u_octet4_loop_serviceIDs);
        }

        for (i_serviceIDs=0; i_serviceIDs < u_octet4_loop_serviceIDs; i_serviceIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "serviceIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/svcAvailStatusInd:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reason  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSvcAvailStatusReason,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordReq:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"recordSubject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpSubjectType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordRes:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_fw_TpFaultStatsRecord"  */

        

        decode_org_csapi_fw_TpFaultStatsRecord_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStatsRecord"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwFaultManager/generateFaultStatisticsRecordErr:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatsReqID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"faultStatisticsError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFaultStatisticsError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcOAM/systemDateTimeQuery:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "systemDateAndTime");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDateAndTime");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwOAM/systemDateTimeQuery:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "clientDateAndTime");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDateAndTime");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/enableHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/disableHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt/changeInterval:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeat/pulse:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpFwHeartBeat/pulse:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/enableSvcHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/disableSvcHeartBeat:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt/changeInterval:1.0
 */

static void
decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"interval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpFwEventNotification/createNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventCriteria"  */

        
        decode_org_csapi_fw_TpFwEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpFwEventNotification/destroyNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpSvcEventNotification/reportNotification:1.0
 */

static void
decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin union "org_csapi_fw_TpFwEventInfo"  */

        
        decode_org_csapi_fw_TpFwEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpFwEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/fw/fw_service/notification/IpSvcEventNotification/notificationTerminated:1.0
 */

static void
decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/routeRes:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_routeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallReport"  */

        

        decode_org_csapi_cc_gccs_TpCallReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReport"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/routeErr:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_routeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getCallInfoRes:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_getCallInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallInfoReport"  */

        

        decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getCallInfoErr:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_getCallInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/superviseCallRes:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_superviseCallRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/superviseCallErr:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_superviseCallErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/callFaultDetected:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_callFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getMoreDialledDigitsRes:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "digits");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/getMoreDialledDigitsErr:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCall/callEnded:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCall_callEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallEndedReport"  */

        

        decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallEndedReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/routeReq:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_routeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_responseRequested;
    guint32   i_responseRequested;
    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_responseRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of responseRequested = %u",u_octet4_loop_responseRequested);
        }

        for (i_responseRequested=0; i_responseRequested < u_octet4_loop_responseRequested; i_responseRequested++) {

            /*  Begin struct "org_csapi_cc_gccs_TpCallReportRequest"  */

            

            decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_gccs_TpCallReportRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_gccs_TpCallAppInfo"  */

            
            decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_cc_gccs_TpCallAppInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/release:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/deassignCall:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_deassignCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/getCallInfoReq:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_getCallInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callInfoRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/setCallChargePlan:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_setCallChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/setAdviceOfCharge:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAoCInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/getMoreDialledDigitsReq:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"length = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/superviseCallReq:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_superviseCallReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCall/continueProcessing:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCall_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callAborted:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callReference = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callEventNotify:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        

        decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        /*  Begin struct "org_csapi_cc_gccs_TpCallEventInfo"  */

        

        decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callNotificationInterrupted:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callNotificationContinued:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callOverloadEncountered:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/callOverloadCeased:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpAppCallControlManager/abortMultipleCalls:1.0
 */

static void
decode_org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callReferenceSet;
    guint32   i_callReferenceSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_callReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callReferenceSet = %u",u_octet4_loop_callReferenceSet);
        }

        for (i_callReferenceSet=0; i_callReferenceSet < u_octet4_loop_callReferenceSet; i_callReferenceSet++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callReferenceSet = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/createCall:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_createCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

            

            decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/enableCallNotification:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_enableCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        

        decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/disableCallNotification:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_disableCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/setCallLoadControl:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_cc_TpCallLoadControlMechanism"  */

        
        decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_TpCallLoadControlMechanism"  */

        /*  Begin struct "org_csapi_cc_gccs_TpCallTreatment"  */

        

        decode_org_csapi_cc_gccs_TpCallTreatment_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallTreatment"  */

        /*  Begin struct "org_csapi_TpAddressRange"  */

        

        decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddressRange"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/changeCallNotification:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_changeCallNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        

        decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/gccs/IpCallControlManager/getCriteria:1.0
 */

static void
decode_org_csapi_cc_gccs_IpCallControlManager_getCriteria(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallEventCriteriaResultSet;
    guint32   i_TpCallEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallEventCriteriaResultSet = %u",u_octet4_loop_TpCallEventCriteriaResultSet);
            }

            for (i_TpCallEventCriteriaResultSet=0; i_TpCallEventCriteriaResultSet < u_octet4_loop_TpCallEventCriteriaResultSet; i_TpCallEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteriaResult"  */

                

                decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_gccs_TpCallEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/eventReportRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallEventInfo"  */

        

        decode_org_csapi_cc_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallEventInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/eventReportErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/attachMediaRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/attachMediaErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/detachMediaRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/detachMediaErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/getInfoRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallLegInfoReport"  */

        

        decode_org_csapi_cc_TpCallLegInfoReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallLegInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/getInfoErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/routeErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_routeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/superviseRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/superviseErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppCallLeg/callLegEnded:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/createCall:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/createNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

        

        decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/destroyNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/changeNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

        

        decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/getNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationRequestedSet;
    guint32   i_TpNotificationRequestedSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationRequestedSet = %u",u_octet4_loop_TpNotificationRequestedSet);
            }

            for (i_TpNotificationRequestedSet=0; i_TpNotificationRequestedSet < u_octet4_loop_TpNotificationRequestedSet; i_TpNotificationRequestedSet++) {

                /*  Begin struct "org_csapi_cc_TpNotificationRequested"  */

                

                decode_org_csapi_cc_TpNotificationRequested_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_TpNotificationRequested"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/setCallLoadControl:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_cc_TpCallLoadControlMechanism"  */

        
        decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_TpCallLoadControlMechanism"  */

        /*  Begin struct "org_csapi_cc_TpCallTreatment"  */

        

        decode_org_csapi_cc_TpCallTreatment_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallTreatment"  */

        /*  Begin struct "org_csapi_TpAddressRange"  */

        

        decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddressRange"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/enableNotifications:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/disableNotifications:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCallControlManager/getNextNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_TpNotificationRequestedSetEntry"  */

            

            decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpNotificationRequestedSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/routeReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_routeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

            
            decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_cc_TpCallAppInfo"  */

        }

        /*  Begin struct "org_csapi_cc_TpCallLegConnectionProperties"  */

        

        decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallLegConnectionProperties"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/eventReportReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_eventReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventsRequested;
    guint32   i_eventsRequested;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventsRequested = %u",u_octet4_loop_eventsRequested);
        }

        for (i_eventsRequested=0; i_eventsRequested < u_octet4_loop_eventsRequested; i_eventsRequested++) {

            /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

            

            decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCallEventRequest"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/release:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getInfoReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_getInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegInfoRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getCall:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_getCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/attachMediaReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_attachMediaReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/detachMediaReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_detachMediaReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getCurrentDestinationAddress:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/continueProcessing:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setChargePlan:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_setChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setAdviceOfCharge:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAoCInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/superviseReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_superviseReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/deassign:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_deassign(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/getProperties:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_getProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_propertyNames;
    guint32   i_propertyNames;
    guint32   u_octet4_loop_TpCallLegPropertyList;
    guint32   i_TpCallLegPropertyList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_propertyNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertyNames = %u",u_octet4_loop_propertyNames);
        }

        for (i_propertyNames=0; i_propertyNames < u_octet4_loop_propertyNames; i_propertyNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "propertyNames");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallLegPropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegPropertyList = %u",u_octet4_loop_TpCallLegPropertyList);
            }

            for (i_TpCallLegPropertyList=0; i_TpCallLegPropertyList < u_octet4_loop_TpCallLegPropertyList; i_TpCallLegPropertyList++) {

                /*  Begin struct "org_csapi_cc_TpCallLegProperty"  */

                

                decode_org_csapi_cc_TpCallLegProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_TpCallLegProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpCallLeg/setProperties:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpCallLeg_setProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_properties;
    guint32   i_properties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of properties = %u",u_octet4_loop_properties);
        }

        for (i_properties=0; i_properties < u_octet4_loop_properties; i_properties++) {

            /*  Begin struct "org_csapi_cc_TpCallLegProperty"  */

            

            decode_org_csapi_cc_TpCallLegProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCallLegProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/getInfoRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallInfoReport"  */

        

        decode_org_csapi_cc_TpCallInfoReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallInfoReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/getInfoErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/superviseRes:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usedTime = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/superviseErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/callEnded:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallEndedReport"  */

        

        decode_org_csapi_cc_TpCallEndedReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallEndedReport"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCall/createAndRouteCallLegErr:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/getCallLegs:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallLegIdentifierSet;
    guint32   i_TpCallLegIdentifierSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpCallLegIdentifierSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegIdentifierSet = %u",u_octet4_loop_TpCallLegIdentifierSet);
            }

            for (i_TpCallLegIdentifierSet=0; i_TpCallLegIdentifierSet < u_octet4_loop_TpCallLegIdentifierSet; i_TpCallLegIdentifierSet++) {

                /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

                

                decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/createCallLeg:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/createAndRouteCallLegReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventsRequested;
    guint32   i_eventsRequested;
    guint32   u_octet4_loop_appInfo;
    guint32   i_appInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventsRequested = %u",u_octet4_loop_eventsRequested);
        }

        for (i_eventsRequested=0; i_eventsRequested < u_octet4_loop_eventsRequested; i_eventsRequested++) {

            /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

            

            decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCallEventRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_appInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of appInfo = %u",u_octet4_loop_appInfo);
        }

        for (i_appInfo=0; i_appInfo < u_octet4_loop_appInfo; i_appInfo++) {

            /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

            
            decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_cc_TpCallAppInfo"  */

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/release:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/deassignCall:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/getInfoReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callInfoRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/setChargePlan:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallChargePlan"  */

        

        decode_org_csapi_cc_TpCallChargePlan_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/setAdviceOfCharge:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAoCInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpMultiPartyCall/superviseReq:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"time = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/reportNotification:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callLegReferenceSet;
    guint32   i_callLegReferenceSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        u_octet4_loop_callLegReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegReferenceSet = %u",u_octet4_loop_callLegReferenceSet);
        }

        for (i_callLegReferenceSet=0; i_callLegReferenceSet < u_octet4_loop_callLegReferenceSet; i_callLegReferenceSet++) {

            /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

            

            decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        }

        /*  Begin struct "org_csapi_cc_TpCallNotificationInfo"  */

        

        decode_org_csapi_cc_TpCallNotificationInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallNotificationInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_cc_mpccs_TpAppMultiPartyCallBack"  */

            
            decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_cc_mpccs_TpAppMultiPartyCallBack"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callAborted:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callReference = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/managerInterrupted:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/managerResumed:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callOverloadEncountered:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/callOverloadCeased:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager/abortMultipleCalls:1.0
 */

static void
decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callReferenceSet;
    guint32   i_callReferenceSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_callReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callReferenceSet = %u",u_octet4_loop_callReferenceSet);
        }

        for (i_callReferenceSet=0; i_callReferenceSet < u_octet4_loop_callReferenceSet; i_callReferenceSet++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callReferenceSet = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCall/superviseVolumeRes:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        

        decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"qualityOfService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCall/superviseVolumeErr:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_TpCallError"  */

        

        decode_org_csapi_cc_TpCallError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCallLeg/mediaStreamMonitorRes:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_streams;
    guint32   i_streams;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_streams = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of streams = %u",u_octet4_loop_streams);
        }

        for (i_streams=0; i_streams < u_octet4_loop_streams; i_streams++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"type  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaStream/subtract:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaStream_subtract(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mediaStreamSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/mediaStreamAllow:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_mediaStreamList;
    guint32   i_mediaStreamList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_mediaStreamList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreamList = %u",u_octet4_loop_mediaStreamList);
        }

        for (i_mediaStreamList=0; i_mediaStreamList < u_octet4_loop_mediaStreamList; i_mediaStreamList++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"mediaStreamList = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/mediaStreamMonitorReq:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_mediaStreamEventCriteria;
    guint32   i_mediaStreamEventCriteria;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_mediaStreamEventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreamEventCriteria = %u",u_octet4_loop_mediaStreamEventCriteria);
        }

        for (i_mediaStreamEventCriteria=0; i_mediaStreamEventCriteria < u_octet4_loop_mediaStreamEventCriteria; i_mediaStreamEventCriteria++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallLeg/getMediaStreams:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMediaStreamSet;
    guint32   i_TpMediaStreamSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMediaStreamSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMediaStreamSet = %u",u_octet4_loop_TpMediaStreamSet);
            }

            for (i_TpMediaStreamSet=0; i_TpMediaStreamSet < u_octet4_loop_TpMediaStreamSet; i_TpMediaStreamSet++) {

                /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

                

                decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCall/superviseVolumeReq:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        

        decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpCallSuperviseVolume"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager/reportMediaNotification:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callLegReferenceSet;
    guint32   i_callLegReferenceSet;
    guint32   u_octet4_loop_mediaStreams;
    guint32   i_mediaStreams;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_mmccs_TpMultiMediaCallIdentifier"  */

        

        decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpMultiMediaCallIdentifier"  */

        u_octet4_loop_callLegReferenceSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegReferenceSet = %u",u_octet4_loop_callLegReferenceSet);
        }

        for (i_callLegReferenceSet=0; i_callLegReferenceSet < u_octet4_loop_callLegReferenceSet; i_callLegReferenceSet++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier"  */

            

            decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier"  */

        }

        u_octet4_loop_mediaStreams = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mediaStreams = %u",u_octet4_loop_mediaStreams);
        }

        for (i_mediaStreams=0; i_mediaStreams < u_octet4_loop_mediaStreams; i_mediaStreams++) {

            /*  Begin struct "org_csapi_cc_mmccs_TpMediaStream"  */

            

            decode_org_csapi_cc_mmccs_TpMediaStream_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_mmccs_TpMediaStream"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"type  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"qualityOfService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_cc_mmccs_TpAppMultiMediaCallBack"  */

            
            decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_cc_mmccs_TpAppMultiMediaCallBack"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/createMediaNotification:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        

        decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/destroyMediaNotification:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/changeMediaNotification:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        

        decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/mmccs/IpMultiMediaCallControlManager/getMediaNotification:1.0
 */

static void
decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMediaNotificationRequestedSet;
    guint32   i_TpMediaNotificationRequestedSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMediaNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMediaNotificationRequestedSet = %u",u_octet4_loop_TpMediaNotificationRequestedSet);
            }

            for (i_TpMediaNotificationRequestedSet=0; i_TpMediaNotificationRequestedSet < u_octet4_loop_TpMediaNotificationRequestedSet; i_TpMediaNotificationRequestedSet++) {

                /*  Begin struct "org_csapi_cc_mmccs_TpMediaNotificationRequested"  */

                

                decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_mmccs_TpMediaNotificationRequested"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppSubConfCall/chairSelection:1.0
 */

static void
decode_org_csapi_cc_cccs_IpAppSubConfCall_chairSelection(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppSubConfCall/floorRequest:1.0
 */

static void
decode_org_csapi_cc_cccs_IpAppSubConfCall_floorRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCall/partyJoined:1.0
 */

static void
decode_org_csapi_cc_cccs_IpAppConfCall_partyJoined(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        /*  Begin struct "org_csapi_cc_cccs_TpJoinEventInfo"  */

        

        decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpJoinEventInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCall/leaveMonitorRes:1.0
 */

static void
decode_org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLeg = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/createConference:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCallControlManager_createConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfSubConferences = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfParticipants = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/checkResources:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCallControlManager_checkResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpConfSearchCriteria"  */

        

        decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpConfSearchCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpConfSearchResult"  */

            

            decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_cccs_TpConfSearchResult"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/reserveResources:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCallControlManager_reserveResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "startTime");

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfParticipants = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"duration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpResourceReservation"  */

            

            decode_org_csapi_cc_cccs_TpResourceReservation_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_cccs_TpResourceReservation"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCallControlManager/freeResources:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCallControlManager_freeResources(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpResourceReservation"  */

        

        decode_org_csapi_cc_cccs_TpResourceReservation_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpResourceReservation"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpAppConfCallControlManager/conferenceCreated:1.0
 */

static void
decode_org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

        

        decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpConfCallIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/splitSubConference:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_splitSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_callLegList;
    guint32   i_callLegList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_callLegList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of callLegList = %u",u_octet4_loop_callLegList);
        }

        for (i_callLegList=0; i_callLegList < u_octet4_loop_callLegList; i_callLegList++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"callLegList = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/mergeSubConference:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_mergeSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceCallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"targetSubConferenceCall = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/moveCallLeg:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_moveCallLeg(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceCallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"targetSubConferenceCall = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"callLeg = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/inspectVideo:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"inspectedCallLeg = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/inspectVideoCancel:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/appointSpeaker:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_appointSpeaker(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"speakerCallLeg = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/chairSelection:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_chairSelection(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"chairCallLeg = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpSubConfCall/changeConferencePolicy:1.0
 */

static void
decode_org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"subConferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/getSubConferences:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCall_getSubConferences(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSubConfCallIdentifierSet;
    guint32   i_TpSubConfCallIdentifierSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpSubConfCallIdentifierSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSubConfCallIdentifierSet = %u",u_octet4_loop_TpSubConfCallIdentifierSet);
            }

            for (i_TpSubConfCallIdentifierSet=0; i_TpSubConfCallIdentifierSet < u_octet4_loop_TpSubConfCallIdentifierSet; i_TpSubConfCallIdentifierSet++) {

                /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

                

                decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/createSubConference:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCall_createSubConference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_cc_cccs_TpConfPolicy"  */

        
        decode_org_csapi_cc_cccs_TpConfPolicy_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_cccs_TpConfPolicy"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            

            decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_cccs_TpSubConfCallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/leaveMonitorReq:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCall_leaveMonitorReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cc/cccs/IpConfCall/getConferenceAddress:1.0
 */

static void
decode_org_csapi_cc_cccs_IpConfCall_getConferenceAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conferenceSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUI_sendInfoRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"response  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUI_sendInfoErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoAndCollectRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUI_sendInfoAndCollectRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"response  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "collectedInfo");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/sendInfoAndCollectErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUI_sendInfoAndCollectErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUI/userInteractionFaultDetected:1.0
 */

static void
decode_org_csapi_ui_IpAppUI_userInteractionFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/recordMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_recordMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"response  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/recordMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_recordMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/deleteMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"response  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/deleteMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/abortActionRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_abortActionRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/abortActionErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_abortActionErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/getMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_getMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUICall/getMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUICall_getMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionAborted:1.0
 */

static void
decode_org_csapi_ui_IpAppUIManager_userInteractionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

        

        decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionNotificationInterrupted:1.0
 */

static void
decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/userInteractionNotificationContinued:1.0
 */

static void
decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/reportEventNotification:1.0
 */

static void
decode_org_csapi_ui_IpAppUIManager_reportEventNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

        

        decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        /*  Begin struct "org_csapi_ui_TpUIEventNotificationInfo"  */

        

        decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIEventNotificationInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIManager/abortMultipleUserInteractions:1.0
 */

static void
decode_org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_userInteractionSet;
    guint32   i_userInteractionSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_userInteractionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of userInteractionSet = %u",u_octet4_loop_userInteractionSet);
        }

        for (i_userInteractionSet=0; i_userInteractionSet < u_octet4_loop_userInteractionSet; i_userInteractionSet++) {

            /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

            

            decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_ui_TpUIIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/sendInfoReq:1.0
 */

static void
decode_org_csapi_ui_IpUI_sendInfoReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_variableInfo;
    guint32   i_variableInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "language");

        u_octet4_loop_variableInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of variableInfo = %u",u_octet4_loop_variableInfo);
        }

        for (i_variableInfo=0; i_variableInfo < u_octet4_loop_variableInfo; i_variableInfo++) {

            /*  Begin union "org_csapi_ui_TpUIVariableInfo"  */

            
            decode_org_csapi_ui_TpUIVariableInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_ui_TpUIVariableInfo"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"repeatIndicator = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"responseRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/sendInfoAndCollectReq:1.0
 */

static void
decode_org_csapi_ui_IpUI_sendInfoAndCollectReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_variableInfo;
    guint32   i_variableInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "language");

        u_octet4_loop_variableInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of variableInfo = %u",u_octet4_loop_variableInfo);
        }

        for (i_variableInfo=0; i_variableInfo < u_octet4_loop_variableInfo; i_variableInfo++) {

            /*  Begin union "org_csapi_ui_TpUIVariableInfo"  */

            
            decode_org_csapi_ui_TpUIVariableInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_ui_TpUIVariableInfo"  */

        }

        /*  Begin struct "org_csapi_ui_TpUICollectCriteria"  */

        

        decode_org_csapi_ui_TpUICollectCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUICollectCriteria"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"responseRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/release:1.0
 */

static void
decode_org_csapi_ui_IpUI_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/setOriginatingAddress:1.0
 */

static void
decode_org_csapi_ui_IpUI_setOriginatingAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "origin");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUI/getOriginatingAddress:1.0
 */

static void
decode_org_csapi_ui_IpUI_getOriginatingAddress(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/recordMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUICall_recordMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        /*  Begin struct "org_csapi_ui_TpUIMessageCriteria"  */

        

        decode_org_csapi_ui_TpUIMessageCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIMessageCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/deleteMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUICall_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/abortActionReq:1.0
 */

static void
decode_org_csapi_ui_IpUICall_abortActionReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUICall/getMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUICall_getMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"userInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createUI:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_createUI(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_ui_TpUIIdentifier"  */

            

            decode_org_csapi_ui_TpUIIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_ui_TpUIIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createUICall:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_createUICall(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_ui_TpUITargetObject"  */

        
        decode_org_csapi_ui_TpUITargetObject_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUITargetObject"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_ui_TpUICallIdentifier"  */

            

            decode_org_csapi_ui_TpUICallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_ui_TpUICallIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/createNotification:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

        

        decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/destroyNotification:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/changeNotification:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

        

        decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/getNotification:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpUIEventCriteriaResultSet;
    guint32   i_TpUIEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpUIEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIEventCriteriaResultSet = %u",u_octet4_loop_TpUIEventCriteriaResultSet);
            }

            for (i_TpUIEventCriteriaResultSet=0; i_TpUIEventCriteriaResultSet < u_octet4_loop_TpUIEventCriteriaResultSet; i_TpUIEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_ui_TpUIEventCriteriaResult"  */

                

                decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_ui_TpUIEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/enableNotifications:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIManager/disableNotifications:1.0
 */

static void
decode_org_csapi_ui_IpUIManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_getMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_getMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/deleteMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"response  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIReport,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/deleteMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/putMessageRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_putMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/putMessageErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_putMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageListRes:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_getMessageListRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_messageIDList;
    guint32   i_messageIDList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_messageIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageIDList = %u",u_octet4_loop_messageIDList);
        }

        for (i_messageIDList=0; i_messageIDList < u_octet4_loop_messageIDList; i_messageIDList++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"messageIDList = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"final = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpAppUIAdminManager/getMessageListErr:1.0
 */

static void
decode_org_csapi_ui_IpAppUIAdminManager_getMessageListErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/getMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUIAdminManager_getMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/putMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUIAdminManager_putMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/deleteMessageReq:1.0
 */

static void
decode_org_csapi_ui_IpUIAdminManager_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"messageID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/ui/IpUIAdminManager/getMessageListReq:1.0
 */

static void
decode_org_csapi_ui_IpUIAdminManager_getMessageListReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"usrInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/locationReportRes:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_locationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocation"  */

            

            decode_org_csapi_mm_TpUserLocation_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserLocation"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/locationReportErr:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_locationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/extendedLocationReportRes:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

            

            decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/extendedLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/periodicLocationReport:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

            

            decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppUserLocation/periodicLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/locationReportReq:1.0
 */

static void
decode_org_csapi_mm_ul_IpUserLocation_locationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/extendedLocationReportReq:1.0
 */

static void
decode_org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/periodicLocationReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reportingInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/periodicLocationReportingStop:1.0
 */

static void
decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpUserLocation/getNextPeriodicLocationRequest:1.0
 */

static void
decode_org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppTriggeredUserLocation/triggeredLocationReport:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationExtended"  */

        

        decode_org_csapi_mm_TpUserLocationExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserLocationExtended"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"criterion  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationTriggerCriteria,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpAppTriggeredUserLocation/triggeredLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/triggeredLocationReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    guint32   u_octet4_loop_triggers;
    guint32   i_triggers;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

        

        decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpLocationRequest"  */

        u_octet4_loop_triggers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of triggers = %u",u_octet4_loop_triggers);
        }

        for (i_triggers=0; i_triggers < u_octet4_loop_triggers; i_triggers++) {

            /*  Begin struct "org_csapi_mm_TpLocationTrigger"  */

            

            decode_org_csapi_mm_TpLocationTrigger_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpLocationTrigger"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/triggeredLocationReportingStop:1.0
 */

static void
decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ul/IpTriggeredUserLocation/getNextTriggeredLocationRequest:1.0
 */

static void
decode_org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/locationReportRes:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

            

            decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/locationReportErr:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/periodicLocationReport:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_locations;
    guint32   i_locations;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of locations = %u",u_octet4_loop_locations);
        }

        for (i_locations=0; i_locations < u_octet4_loop_locations; i_locations++) {

            /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

            

            decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/periodicLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/triggeredLocationReport:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationCamel"  */

        

        decode_org_csapi_mm_TpUserLocationCamel_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserLocationCamel"  */

        /*  Begin struct "org_csapi_mm_TpLocationTriggerCamel"  */

        

        decode_org_csapi_mm_TpLocationTriggerCamel_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpLocationTriggerCamel"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpAppUserLocationCamel/triggeredLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/locationReportReq:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/periodicLocationReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"reportingInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/periodicLocationReportingStop:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/triggeredLocationReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_mm_TpLocationTriggerCamel"  */

        

        decode_org_csapi_mm_TpLocationTriggerCamel_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpLocationTriggerCamel"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/triggeredLocationReportingStop:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/getNextPeriodicLocationRequest:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpPeriodicLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ulc/IpUserLocationCamel/getNextTriggeredLocationRequest:1.0
 */

static void
decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpTriggeredLocationRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpAppUserLocationEmergency/emergencyLocationReport:1.0
 */

static void
decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_mm_TpUserLocationEmergency"  */

        

        decode_org_csapi_mm_TpUserLocationEmergency_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserLocationEmergency"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpAppUserLocationEmergency/emergencyLocationReportErr:1.0
 */

static void
decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/emergencyLocationReportReq:1.0
 */

static void
decode_org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_mm_TpUserLocationEmergencyRequest"  */

        

        decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserLocationEmergencyRequest"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/subscribeEmergencyLocationReports:1.0
 */

static void
decode_org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ule/IpUserLocationEmergency/unSubscribeEmergencyLocationReports:1.0
 */

static void
decode_org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/statusReportRes:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_statusReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_status;
    guint32   i_status;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_status = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of status = %u",u_octet4_loop_status);
        }

        for (i_status=0; i_status < u_octet4_loop_status; i_status++) {

            /*  Begin struct "org_csapi_mm_TpUserStatus"  */

            

            decode_org_csapi_mm_TpUserStatus_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserStatus"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/statusReportErr:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_statusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/triggeredStatusReport:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_mm_TpUserStatus"  */

        

        decode_org_csapi_mm_TpUserStatus_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserStatus"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/triggeredStatusReportErr:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extendedStatusReportRes:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_status;
    guint32   i_status;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_status = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of status = %u",u_octet4_loop_status);
        }

        for (i_status=0; i_status < u_octet4_loop_status; i_status++) {

            /*  Begin struct "org_csapi_mm_TpUserStatusExtended"  */

            

            decode_org_csapi_mm_TpUserStatusExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpUserStatusExtended"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extendedStatusReportErr:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extTriggeredStatusReport:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_mm_TpUserStatusExtended"  */

        

        decode_org_csapi_mm_TpUserStatusExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUserStatusExtended"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpAppUserStatus/extTriggeredStatusReportErr:1.0
 */

static void
decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/statusReportReq:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_statusReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/triggeredStatusReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/triggeredStatusReportingStop:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/getNextTriggeredStatusRequest:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mm_TpTriggeredStatusRequestSetEntry"  */

            

            decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpTriggeredStatusRequestSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extendedStatusReportReq:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_extendedStatusReportReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extTriggeredStatusReportingStartReq:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/us/IpUserStatus/extTriggeredStatusReportingStop:1.0
 */

static void
decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        

        decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpMobilityStopAssignmentData"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpAppUserBinding/triggeredBindingRequestNotification:1.0
 */

static void
decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_contactInformation;
    guint32   i_contactInformation;
    guint32   u_octet4_loop_TpBindingSet;
    guint32   i_TpBindingSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        u_octet4_loop_contactInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of contactInformation = %u",u_octet4_loop_contactInformation);
        }

        for (i_contactInformation=0; i_contactInformation < u_octet4_loop_contactInformation; i_contactInformation++) {

            u_octet4_loop_contactInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of contactInformation = %u",u_octet4_loop_contactInformation);
            }

            for (i_contactInformation=0; i_contactInformation < u_octet4_loop_contactInformation; i_contactInformation++) {

                /*  Begin union "org_csapi_mm_TpBindingEntry"  */

                
                decode_org_csapi_mm_TpBindingEntry_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End union "org_csapi_mm_TpBindingEntry"  */

            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpBindingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingSet = %u",u_octet4_loop_TpBindingSet);
            }

            for (i_TpBindingSet=0; i_TpBindingSet < u_octet4_loop_TpBindingSet; i_TpBindingSet++) {

                u_octet4_loop_TpBindingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingSet = %u",u_octet4_loop_TpBindingSet);
                }

                for (i_TpBindingSet=0; i_TpBindingSet < u_octet4_loop_TpBindingSet; i_TpBindingSet++) {

                    /*  Begin union "org_csapi_mm_TpBindingEntry"  */

                    
                    decode_org_csapi_mm_TpBindingEntry_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                    /*  End union "org_csapi_mm_TpBindingEntry"  */

                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpAppUserBinding/triggeredBindingRequestNotificationStartErr:1.0
 */

static void
decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"diagnostic  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityDiagnostic,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpUserBinding/triggeredBindingRequestNotificationStartReq:1.0
 */

static void
decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    guint32   u_octet4_loop_criteria;
    guint32   i_criteria;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        u_octet4_loop_criteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of criteria = %u",u_octet4_loop_criteria);
        }

        for (i_criteria=0; i_criteria < u_octet4_loop_criteria; i_criteria++) {

            /*  Begin struct "org_csapi_mm_TpBindingNotificationCriteria"  */

            

            decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mm_TpBindingNotificationCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mm/ub/IpUserBinding/triggeredBindingRequestNotificationStop:1.0
 */

static void
decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpTerminalCapabilities/getTerminalCapabilities:1.0
 */

static void
decode_org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "terminalIdentity");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_termcap_TpTerminalCapabilities"  */

            

            decode_org_csapi_termcap_TpTerminalCapabilities_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_termcap_TpTerminalCapabilities"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpAppExtendedTerminalCapabilities/triggeredTerminalCapabilityReport:1.0
 */

static void
decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"criteria = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_termcap_TpTerminalCapabilities"  */

        

        decode_org_csapi_termcap_TpTerminalCapabilities_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_termcap_TpTerminalCapabilities"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpAppExtendedTerminalCapabilities/triggeredTerminalCapabilityReportErr:1.0
 */

static void
decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_termcap_TpTerminalCapabilitiesError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpExtendedTerminalCapabilities/triggeredTerminalCapabilityStartReq:1.0
 */

static void
decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_terminals;
    guint32   i_terminals;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_terminals = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of terminals = %u",u_octet4_loop_terminals);
        }

        for (i_terminals=0; i_terminals < u_octet4_loop_terminals; i_terminals++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_termcap_TpTerminalCapabilityScope"  */

        

        decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_termcap_TpTerminalCapabilityScope"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"criteria = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/termcap/IpExtendedTerminalCapabilities/triggeredTerminalCapabilityStop:1.0
 */

static void
decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/connectRes:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSession_connectRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionReport"  */

        

        decode_org_csapi_dsc_TpDataSessionReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionReport"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/connectErr:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSession_connectErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionError"  */

        

        decode_org_csapi_dsc_TpDataSessionError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionError"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/superviseDataSessionRes:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        

        decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"qualityOfService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/superviseDataSessionErr:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionError"  */

        

        decode_org_csapi_dsc_TpDataSessionError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionError"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSession/dataSessionFaultDetected:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionAborted:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSession = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/reportNotification:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSessionControlManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_dsc_TpDataSessionIdentifier"  */

        

        decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionIdentifier"  */

        /*  Begin struct "org_csapi_dsc_TpDataSessionEventInfo"  */

        

        decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionNotificationContinued:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/dataSessionNotificationInterrupted:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpAppDataSessionControlManager/abortMultipleDataSessions:1.0
 */

static void
decode_org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_dataSessionSet;
    guint32   i_dataSessionSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_dataSessionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of dataSessionSet = %u",u_octet4_loop_dataSessionSet);
        }

        for (i_dataSessionSet=0; i_dataSessionSet < u_octet4_loop_dataSessionSet; i_dataSessionSet++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionSet = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/connectReq:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_connectReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_responseRequested;
    guint32   i_responseRequested;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_responseRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of responseRequested = %u",u_octet4_loop_responseRequested);
        }

        for (i_responseRequested=0; i_responseRequested < u_octet4_loop_responseRequested; i_responseRequested++) {

            /*  Begin struct "org_csapi_dsc_TpDataSessionReportRequest"  */

            

            decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_dsc_TpDataSessionReportRequest"  */

        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/release:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        

        decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/superviseDataSessionReq:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_superviseDataSessionReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"treatment = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        

        decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionSuperviseVolume"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/setDataSessionChargePlan:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_setDataSessionChargePlan(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionChargePlan"  */

        

        decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionChargePlan"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/setAdviceOfCharge:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_setAdviceOfCharge(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAoCInfo"  */

        

        decode_org_csapi_TpAoCInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAoCInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"tariffSwitch = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/deassignDataSession:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_deassignDataSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSession/continueProcessing:1.0
 */

static void
decode_org_csapi_dsc_IpDataSession_continueProcessing(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"dataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/createNotification:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/destroyNotification:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/changeNotification:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/enableNotifications:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/disableNotifications:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/getNotifications:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_getNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpDataSessionEventCriteriaResultSet;
    guint32   i_TpDataSessionEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpDataSessionEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpDataSessionEventCriteriaResultSet = %u",u_octet4_loop_TpDataSessionEventCriteriaResultSet);
            }

            for (i_TpDataSessionEventCriteriaResultSet=0; i_TpDataSessionEventCriteriaResultSet < u_octet4_loop_TpDataSessionEventCriteriaResultSet; i_TpDataSessionEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteriaResult"  */

                

                decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_dsc_TpDataSessionEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/dsc/IpDataSessionControlManager/createNotifications:1.0
 */

static void
decode_org_csapi_dsc_IpDataSessionControlManager_createNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        

        decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/openMailbox:1.0
 */

static void
decode_org_csapi_gms_IpMessagingManager_openMailbox(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authenticationInfo");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_gms_TpMailboxIdentifier"  */

            

            decode_org_csapi_gms_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_gms_TpMailboxIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/enableMessagingNotification:1.0
 */

static void
decode_org_csapi_gms_IpMessagingManager_enableMessagingNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_gms_TpMessagingEventCriteria"  */

        
        decode_org_csapi_gms_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_gms_TpMessagingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessagingManager/disableMessagingNotification:1.0
 */

static void
decode_org_csapi_gms_IpMessagingManager_disableMessagingNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/mailboxTerminated:1.0
 */

static void
decode_org_csapi_gms_IpAppMessagingManager_mailboxTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/mailboxFaultDetected:1.0
 */

static void
decode_org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingFault,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/messagingEventNotify:1.0
 */

static void
decode_org_csapi_gms_IpAppMessagingManager_messagingEventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin union "org_csapi_gms_TpMessagingEventInfo"  */

        
        decode_org_csapi_gms_TpMessagingEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_gms_TpMessagingEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpAppMessagingManager/messagingNotificationTerminated:1.0
 */

static void
decode_org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/close:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/lock:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_lock(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/unlock:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_unlock(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/getInfoAmount:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/getInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMailboxInfoPropertySet;
    guint32   i_TpMailboxInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMailboxInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMailboxInfoPropertySet = %u",u_octet4_loop_TpMailboxInfoPropertySet);
            }

            for (i_TpMailboxInfoPropertySet=0; i_TpMailboxInfoPropertySet < u_octet4_loop_TpMailboxInfoPropertySet; i_TpMailboxInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpMailboxInfoProperty"  */

                
                decode_org_csapi_gms_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End union "org_csapi_gms_TpMailboxInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/setInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_mailboxInfoProperties;
    guint32   i_mailboxInfoProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_mailboxInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mailboxInfoProperties = %u",u_octet4_loop_mailboxInfoProperties);
        }

        for (i_mailboxInfoProperties=0; i_mailboxInfoProperties < u_octet4_loop_mailboxInfoProperties; i_mailboxInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMailboxInfoProperty"  */

            
            decode_org_csapi_gms_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_gms_TpMailboxInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/openFolder:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_openFolder(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_gms_TpMailboxFolderIdentifier"  */

            

            decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_gms_TpMailboxFolderIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/createFolder:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_createFolder(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailbox/remove:1.0
 */

static void
decode_org_csapi_gms_IpMailbox_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authenticationInfo");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getInfoAmount:1.0
 */

static void
decode_org_csapi_gms_IpMessage_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMessage_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessageInfoPropertySet;
    guint32   i_TpMessageInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpMessageInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessageInfoPropertySet = %u",u_octet4_loop_TpMessageInfoPropertySet);
            }

            for (i_TpMessageInfoPropertySet=0; i_TpMessageInfoPropertySet < u_octet4_loop_TpMessageInfoPropertySet; i_TpMessageInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

                
                decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/setInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMessage_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_messageInfoProperties;
    guint32   i_messageInfoProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_messageInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageInfoProperties = %u",u_octet4_loop_messageInfoProperties);
        }

        for (i_messageInfoProperties=0; i_messageInfoProperties < u_octet4_loop_messageInfoProperties; i_messageInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

            
            decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/remove:1.0
 */

static void
decode_org_csapi_gms_IpMessage_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMessage/getContent:1.0
 */

static void
decode_org_csapi_gms_IpMessage_getContent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpMessage");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getInfoAmount:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_getInfoAmount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_getInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpFolderInfoPropertySet;
    guint32   i_TpFolderInfoPropertySet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberOfProperties = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpFolderInfoPropertySet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFolderInfoPropertySet = %u",u_octet4_loop_TpFolderInfoPropertySet);
            }

            for (i_TpFolderInfoPropertySet=0; i_TpFolderInfoPropertySet < u_octet4_loop_TpFolderInfoPropertySet; i_TpFolderInfoPropertySet++) {

                /*  Begin union "org_csapi_gms_TpFolderInfoProperty"  */

                
                decode_org_csapi_gms_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End union "org_csapi_gms_TpFolderInfoProperty"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/setInfoProperties:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_setInfoProperties(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_folderInfoProperties;
    guint32   i_folderInfoProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"firstProperty = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_folderInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of folderInfoProperties = %u",u_octet4_loop_folderInfoProperties);
        }

        for (i_folderInfoProperties=0; i_folderInfoProperties < u_octet4_loop_folderInfoProperties; i_folderInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpFolderInfoProperty"  */

            
            decode_org_csapi_gms_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_gms_TpFolderInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/putMessage:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_putMessage(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_messageInfoProperties;
    guint32   i_messageInfoProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "message");

        u_octet4_loop_messageInfoProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageInfoProperties = %u",u_octet4_loop_messageInfoProperties);
        }

        for (i_messageInfoProperties=0; i_messageInfoProperties < u_octet4_loop_messageInfoProperties; i_messageInfoProperties++) {

            /*  Begin union "org_csapi_gms_TpMessageInfoProperty"  */

            
            decode_org_csapi_gms_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_gms_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/getMessage:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_getMessage(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/close:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"folderSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/gms/IpMailboxFolder/remove:1.0
 */

static void
decode_org_csapi_gms_IpMailboxFolder_remove(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getVPrPID:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getVPrPID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getSlaID:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getSlaID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getStatus:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getStatus(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"Operation_Return_Value  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpVprpStatus,"Unknown Enum Value"));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getProvisionedQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            

            decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getValidityInfo:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

            

            decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpValidityInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getPipeQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

            

            decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrP/getDsCodepoint:1.0
 */

static void
decode_org_csapi_cm_IpVPrP_getDsCodepoint(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpDsCodepoint"  */

            

            decode_org_csapi_cm_TpDsCodepoint_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpDsCodepoint"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/getVPrPList:1.0
 */

static void
decode_org_csapi_cm_IpVPrN_getVPrPList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/getVPrP:1.0
 */

static void
decode_org_csapi_cm_IpVPrN_getVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "vPrPID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/createVPrP:1.0
 */

static void
decode_org_csapi_cm_IpVPrN_createVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpVPrN/deleteVPrP:1.0
 */

static void
decode_org_csapi_cm_IpVPrN_deleteVPrP(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "vPrPID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSMenu/getTemplate:1.0
 */

static void
decode_org_csapi_cm_IpQoSMenu_getTemplate(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "templateType");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSMenu/getTemplateList:1.0
 */

static void
decode_org_csapi_cm_IpQoSMenu_getTemplateList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpConnectivityManager/getQoSMenu:1.0
 */

static void
decode_org_csapi_cm_IpConnectivityManager_getQoSMenu(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpConnectivityManager/getEnterpriseNetwork:1.0
 */

static void
decode_org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getTemplateType:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getTemplateType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getDescription:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getDescription(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setSlaID:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_setSlaID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "slaID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getPipeQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

            

            decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setPipeQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_setPipeQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpPipeQoSInfo"  */

        

        decode_org_csapi_cm_TpPipeQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cm_TpPipeQoSInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getValidityInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

            

            decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpValidityInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setValidityInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_setValidityInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpValidityInfo"  */

        

        decode_org_csapi_cm_TpValidityInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cm_TpValidityInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/setProvisionedQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

        

        decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getProvisionedQoSInfo:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            

            decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpProvisionedQoSInfo"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpQoSTemplate/getDsCodepoint:1.0
 */

static void
decode_org_csapi_cm_IpQoSTemplate_getDsCodepoint(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpDsCodepoint"  */

            

            decode_org_csapi_cm_TpDsCodepoint_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpDsCodepoint"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getSiteList:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetwork_getSiteList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getVPrN:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetwork_getVPrN(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetwork/getSite:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetwork_getSite(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "siteID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSAPList:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteID:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteID(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteLocation:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSiteDescription:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpString");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getIPSubnet:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpIPSubnet"  */

            

            decode_org_csapi_cm_TpIPSubnet_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpIPSubnet"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cm/IpEnterpriseNetworkSite/getSAPIPSubnet:1.0
 */

static void
decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sapID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cm_TpIPSubnet"  */

            

            decode_org_csapi_cm_TpIPSubnet_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cm_TpIPSubnet"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/reportNotification:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_am_TpChargingEventInfo"  */

        

        decode_org_csapi_am_TpChargingEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpChargingEventInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryBalanceRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_balances;
    guint32   i_balances;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_balances = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of balances = %u",u_octet4_loop_balances);
        }

        for (i_balances=0; i_balances < u_octet4_loop_balances; i_balances++) {

            /*  Begin struct "org_csapi_am_TpBalance"  */

            

            decode_org_csapi_am_TpBalance_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_am_TpBalance"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryBalanceErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/retrieveTransactionHistoryRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_transactionHistory;
    guint32   i_transactionHistory;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"retrievalID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_transactionHistory = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of transactionHistory = %u",u_octet4_loop_transactionHistory);
        }

        for (i_transactionHistory=0; i_transactionHistory < u_octet4_loop_transactionHistory; i_transactionHistory++) {

            /*  Begin struct "org_csapi_am_TpTransactionHistory"  */

            

            decode_org_csapi_am_TpTransactionHistory_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_am_TpTransactionHistory"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/retrieveTransactionHistoryErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"retrievalID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"transactionHistoryError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpTransactionHistoryStatus,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceExpiryDateRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_dates;
    guint32   i_dates;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_dates = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of dates = %u",u_octet4_loop_dates);
        }

        for (i_dates=0; i_dates < u_octet4_loop_dates; i_dates++) {

            /*  Begin struct "org_csapi_am_TpBalanceExpiryDate"  */

            

            decode_org_csapi_am_TpBalanceExpiryDate_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_am_TpBalanceExpiryDate"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryBalanceExpiryDateErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/updateBalanceRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_updateBalanceRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_am_TpBalance"  */

        

        decode_org_csapi_am_TpBalance_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpBalance"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/updateBalanceErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_updateBalanceErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/createVoucherRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_createVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/createVoucherErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_createVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/destroyVoucherRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_destroyVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/destroyVoucherErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_destroyVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryVoucherRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryVoucherRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_am_TpVoucher"  */

        

        decode_org_csapi_am_TpVoucher_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpVoucher"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryVoucherErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryVoucherErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryUserVouchersRes:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryUserVouchersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_vouchers;
    guint32   i_vouchers;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_vouchers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of vouchers = %u",u_octet4_loop_vouchers);
        }

        for (i_vouchers=0; i_vouchers < u_octet4_loop_vouchers; i_vouchers++) {

            /*  Begin struct "org_csapi_am_TpVoucher"  */

            

            decode_org_csapi_am_TpVoucher_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_am_TpVoucher"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAppAccountManager/queryUserVouchersErr:1.0
 */

static void
decode_org_csapi_am_IpAppAccountManager_queryUserVouchersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"queryId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpVoucherError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/createNotification:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

        

        decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/destroyNotification:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryBalanceReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_queryBalanceReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/changeNotification:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

        

        decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/getNotification:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_getNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpChargingEventCriteriaResultSet;
    guint32   i_TpChargingEventCriteriaResultSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpChargingEventCriteriaResultSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteriaResultSet = %u",u_octet4_loop_TpChargingEventCriteriaResultSet);
            }

            for (i_TpChargingEventCriteriaResultSet=0; i_TpChargingEventCriteriaResultSet < u_octet4_loop_TpChargingEventCriteriaResultSet; i_TpChargingEventCriteriaResultSet++) {

                /*  Begin struct "org_csapi_am_TpChargingEventCriteriaResult"  */

                

                decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_am_TpChargingEventCriteriaResult"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/retrieveTransactionHistoryReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_TpTimeInterval"  */

        

        decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpTimeInterval"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/enableNotifications:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/disableNotifications:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryBalanceExpiryDateReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/updateBalanceReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_updateBalanceReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"debit = %u",get_CDR_boolean(tvb,offset));
        }

        /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

        

        decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpBalanceInfo"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"period = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/createVoucherReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_createVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

        

        decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_am_TpBalanceInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/destroyVoucherReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_destroyVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryVoucherReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_queryVoucherReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"voucherId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/am/IpAccountManager/queryUserVouchersReq:1.0
 */

static void
decode_org_csapi_am_IpAccountManager_queryUserVouchersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditAmountErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_creditAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditAmountRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_creditAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditUnitErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_creditUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/creditUnitRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_creditUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_creditedVolumes;
    guint32   i_creditedVolumes;
    guint32   u_octet4_loop_reservedUnitsLeft;
    guint32   i_reservedUnitsLeft;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_creditedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of creditedVolumes = %u",u_octet4_loop_creditedVolumes);
        }

        for (i_creditedVolumes=0; i_creditedVolumes < u_octet4_loop_creditedVolumes; i_creditedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet4_loop_reservedUnitsLeft = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnitsLeft = %u",u_octet4_loop_reservedUnitsLeft);
        }

        for (i_reservedUnitsLeft=0; i_reservedUnitsLeft < u_octet4_loop_reservedUnitsLeft; i_reservedUnitsLeft++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitAmountErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_debitAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitAmountRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_debitAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitUnitErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_debitUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/debitUnitRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_debitUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_debitedVolumes;
    guint32   i_debitedVolumes;
    guint32   u_octet4_loop_reservedUnitsLeft;
    guint32   i_reservedUnitsLeft;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_debitedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of debitedVolumes = %u",u_octet4_loop_debitedVolumes);
        }

        for (i_debitedVolumes=0; i_debitedVolumes < u_octet4_loop_debitedVolumes; i_debitedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        u_octet4_loop_reservedUnitsLeft = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnitsLeft = %u",u_octet4_loop_reservedUnitsLeft);
        }

        for (i_reservedUnitsLeft=0; i_reservedUnitsLeft < u_octet4_loop_reservedUnitsLeft; i_reservedUnitsLeft++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditAmountErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directCreditAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditAmountRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directCreditAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditUnitErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directCreditUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directCreditUnitRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directCreditUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_creditedVolumes;
    guint32   i_creditedVolumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_creditedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of creditedVolumes = %u",u_octet4_loop_creditedVolumes);
        }

        for (i_creditedVolumes=0; i_creditedVolumes < u_octet4_loop_creditedVolumes; i_creditedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitAmountErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directDebitAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitAmountRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directDebitAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitUnitErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directDebitUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/directDebitUnitRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_directDebitUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_debitedVolumes;
    guint32   i_debitedVolumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_debitedVolumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of debitedVolumes = %u",u_octet4_loop_debitedVolumes);
        }

        for (i_debitedVolumes=0; i_debitedVolumes < u_octet4_loop_debitedVolumes; i_debitedVolumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/extendLifeTimeErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/extendLifeTimeRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/rateErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_rateErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/rateRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_rateRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_rates;
    guint32   i_rates;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_rates = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of rates = %u",u_octet4_loop_rates);
        }

        for (i_rates=0; i_rates < u_octet4_loop_rates; i_rates++) {

            /*  Begin struct "org_csapi_cs_TpPriceVolume"  */

            

            decode_org_csapi_cs_TpPriceVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpPriceVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"validityTimeLeft = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveAmountErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_reserveAmountErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveAmountRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_reserveAmountRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveUnitErr:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_reserveUnitErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingError,"Unknown Enum Value"));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/reserveUnitRes:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_reserveUnitRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_reservedUnits;
    guint32   i_reservedUnits;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_reservedUnits = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of reservedUnits = %u",u_octet4_loop_reservedUnits);
        }

        for (i_reservedUnits=0; i_reservedUnits < u_octet4_loop_reservedUnits; i_reservedUnits++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionTimeLeft = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumberNextRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingSession/sessionEnded:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingSession_sessionEnded(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"report  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpSessionEndedCause,"Unknown Enum Value"));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/creditAmountReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_creditAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",get_CDR_boolean(tvb,offset));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/creditUnitReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_creditUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",get_CDR_boolean(tvb,offset));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/debitAmountReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_debitAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",get_CDR_boolean(tvb,offset));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/debitUnitReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_debitUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"closeReservation = %u",get_CDR_boolean(tvb,offset));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directCreditAmountReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_directCreditAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directCreditUnitReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_directCreditUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directDebitAmountReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_directDebitAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/directDebitUnitReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_directDebitUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/extendLifeTimeReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_extendLifeTimeReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getAmountLeft:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_getAmountLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

            

            decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingPrice"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getLifeTimeLeft:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_getLifeTimeLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/getUnitLeft:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_getUnitLeft(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpVolumeSet;
    guint32   i_TpVolumeSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpVolumeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpVolumeSet = %u",u_octet4_loop_TpVolumeSet);
            }

            for (i_TpVolumeSet=0; i_TpVolumeSet < u_octet4_loop_TpVolumeSet; i_TpVolumeSet++) {

                /*  Begin struct "org_csapi_cs_TpVolume"  */

                

                decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_cs_TpVolume"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/rateReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_rateReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/release:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_release(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/reserveAmountReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_reserveAmountReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

        

        decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpChargingPrice"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingSession/reserveUnitReq:1.0
 */

static void
decode_org_csapi_cs_IpChargingSession_reserveUnitReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingParameters;
    guint32   i_chargingParameters;
    guint32   u_octet4_loop_volumes;
    guint32   i_volumes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_cs_TpApplicationDescription"  */

        

        decode_org_csapi_cs_TpApplicationDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpApplicationDescription"  */

        u_octet4_loop_chargingParameters = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingParameters = %u",u_octet4_loop_chargingParameters);
        }

        for (i_chargingParameters=0; i_chargingParameters < u_octet4_loop_chargingParameters; i_chargingParameters++) {

            /*  Begin struct "org_csapi_cs_TpChargingParameter"  */

            

            decode_org_csapi_cs_TpChargingParameter_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingParameter"  */

        }

        u_octet4_loop_volumes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of volumes = %u",u_octet4_loop_volumes);
        }

        for (i_volumes=0; i_volumes < u_octet4_loop_volumes; i_volumes++) {

            /*  Begin struct "org_csapi_cs_TpVolume"  */

            

            decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpVolume"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingManager/sessionAborted:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingManager_sessionAborted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpAppChargingManager/abortMultipleChargingSessions:1.0
 */

static void
decode_org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_chargingSessionSet;
    guint32   i_chargingSessionSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_chargingSessionSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of chargingSessionSet = %u",u_octet4_loop_chargingSessionSet);
        }

        for (i_chargingSessionSet=0; i_chargingSessionSet < u_octet4_loop_chargingSessionSet; i_chargingSessionSet++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"chargingSessionSet = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingManager/createChargingSession:1.0
 */

static void
decode_org_csapi_cs_IpChargingManager_createChargingSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sessionDescription");

        /*  Begin struct "org_csapi_cs_TpMerchantAccountID"  */

        

        decode_org_csapi_cs_TpMerchantAccountID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpMerchantAccountID"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_cs_TpCorrelationID"  */

        

        decode_org_csapi_cs_TpCorrelationID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpCorrelationID"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingSessionID"  */

            

            decode_org_csapi_cs_TpChargingSessionID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingSessionID"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/cs/IpChargingManager/createSplitChargingSession:1.0
 */

static void
decode_org_csapi_cs_IpChargingManager_createSplitChargingSession(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_users;
    guint32   i_users;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sessionDescription");

        /*  Begin struct "org_csapi_cs_TpMerchantAccountID"  */

        

        decode_org_csapi_cs_TpMerchantAccountID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpMerchantAccountID"  */

        u_octet4_loop_users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of users = %u",u_octet4_loop_users);
        }

        for (i_users=0; i_users < u_octet4_loop_users; i_users++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        /*  Begin struct "org_csapi_cs_TpCorrelationID"  */

        

        decode_org_csapi_cs_TpCorrelationID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cs_TpCorrelationID"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_cs_TpChargingSessionID"  */

            

            decode_org_csapi_cs_TpChargingSessionID_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cs_TpChargingSessionID"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/reportNotification:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_policy_TpPolicyEvent"  */

        

        decode_org_csapi_policy_TpPolicyEvent_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_policy_TpPolicyEvent"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/evalPolicyRes:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_outputVariables;
    guint32   i_outputVariables;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_outputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of outputVariables = %u",u_octet4_loop_outputVariables);
        }

        for (i_outputVariables=0; i_outputVariables < u_octet4_loop_outputVariables; i_outputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpAppPolicyDomain/evalPolicyErr:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/evalPolicy:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    guint32   u_octet4_loop_TpPolicyNameValueList;
    guint32   i_TpPolicyNameValueList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signatureName");

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyNameValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyNameValueList = %u",u_octet4_loop_TpPolicyNameValueList);
            }

            for (i_TpPolicyNameValueList=0; i_TpPolicyNameValueList < u_octet4_loop_TpPolicyNameValueList; i_TpPolicyNameValueList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

                

                decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/evalPolicyReq:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signatureName");

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            /*  Begin struct "org_csapi_policy_TpPolicyNameValue"  */

            

            decode_org_csapi_policy_TpPolicyNameValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyNameValue"  */

        }

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/abortEvalPolicyReq:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/generateEvent:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "eventDefinitionName");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/createNotification:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_events;
    guint32   i_events;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of events = %u",u_octet4_loop_events);
        }

        for (i_events=0; i_events < u_octet4_loop_events; i_events++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "events");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/evaluation/IpPolicyEvalManager/destroyNotification:1.0
 */

static void
decode_org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_events;
    guint32   i_events;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of events = %u",u_octet4_loop_events);
        }

        for (i_events=0; i_events < u_octet4_loop_events; i_events++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "events");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/getAttribute:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicy_getAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/setAttribute:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicy_setAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAttribute"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/getAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicy_getAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicy/setAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicy_setAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_targetAttributes;
    guint32   i_targetAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_targetAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of targetAttributes = %u",u_octet4_loop_targetAttributes);
        }

        for (i_targetAttributes=0; i_targetAttributes < u_octet4_loop_targetAttributes; i_targetAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyIterator/getList:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyIterator_getList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"startIndex = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"numberRequested = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getParentRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_createRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_removeRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepositoryCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getRepositoryIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_createCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_conditionAttributes;
    guint32   i_conditionAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conditionType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyConditionType,"Unknown Enum Value"));
        }

        u_octet4_loop_conditionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionAttributes = %u",u_octet4_loop_conditionAttributes);
        }

        for (i_conditionAttributes=0; i_conditionAttributes < u_octet4_loop_conditionAttributes; i_conditionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_removeCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getConditionCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getConditionIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/createAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_createAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_actionAttributes;
    guint32   i_actionAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"actionType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyActionType,"Unknown Enum Value"));
        }

        u_octet4_loop_actionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionAttributes = %u",u_octet4_loop_actionAttributes);
        }

        for (i_actionAttributes=0; i_actionAttributes < u_octet4_loop_actionAttributes; i_actionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/removeAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_removeAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getActionCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRepository/getActionIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getParentGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getParentGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getParentDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/createCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_createCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_conditionAttributes;
    guint32   i_conditionAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"conditionType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyConditionType,"Unknown Enum Value"));
        }

        u_octet4_loop_conditionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionAttributes = %u",u_octet4_loop_conditionAttributes);
        }

        for (i_conditionAttributes=0; i_conditionAttributes < u_octet4_loop_conditionAttributes; i_conditionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/removeCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_removeCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/createAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_createAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_actionAttributes;
    guint32   i_actionAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"actionType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyActionType,"Unknown Enum Value"));
        }

        u_octet4_loop_actionAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionAttributes = %u",u_octet4_loop_actionAttributes);
        }

        for (i_actionAttributes=0; i_actionAttributes < u_octet4_loop_actionAttributes; i_actionAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/removeAction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_removeAction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "actionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getActionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getActionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setValidityPeriodConditionByName:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "conditionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setValidityPeriodCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getValidityPeriodCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/unsetValidityPeriodCondition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setConditionList:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_setConditionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_conditionList;
    guint32   i_conditionList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_conditionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of conditionList = %u",u_octet4_loop_conditionList);
        }

        for (i_conditionList=0; i_conditionList < u_octet4_loop_conditionList; i_conditionList++) {

            /*  Begin struct "org_csapi_policy_TpPolicyConditionListElement"  */

            

            decode_org_csapi_policy_TpPolicyConditionListElement_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyConditionListElement"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getConditionList:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyConditionList;
    guint32   i_TpPolicyConditionList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyConditionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyConditionList = %u",u_octet4_loop_TpPolicyConditionList);
            }

            for (i_TpPolicyConditionList=0; i_TpPolicyConditionList < u_octet4_loop_TpPolicyConditionList; i_TpPolicyConditionList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyConditionListElement"  */

                

                decode_org_csapi_policy_TpPolicyConditionListElement_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_policy_TpPolicyConditionListElement"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/setActionList:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_setActionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_actionList;
    guint32   i_actionList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_actionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of actionList = %u",u_octet4_loop_actionList);
        }

        for (i_actionList=0; i_actionList < u_octet4_loop_actionList; i_actionList++) {

            /*  Begin struct "org_csapi_policy_TpPolicyActionListElement"  */

            

            decode_org_csapi_policy_TpPolicyActionListElement_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyActionListElement"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyRule/getActionList:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyRule_getActionList(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyActionList;
    guint32   i_TpPolicyActionList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyActionList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyActionList = %u",u_octet4_loop_TpPolicyActionList);
            }

            for (i_TpPolicyActionList=0; i_TpPolicyActionList < u_octet4_loop_TpPolicyActionList; i_TpPolicyActionList++) {

                /*  Begin struct "org_csapi_policy_TpPolicyActionListElement"  */

                

                decode_org_csapi_policy_TpPolicyActionListElement_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_policy_TpPolicyActionListElement"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/createDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_createDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/removeDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_removeDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomainCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getDomainIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/findMatchingDomains:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_matchingAttributes;
    guint32   i_matchingAttributes;
    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_matchingAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of matchingAttributes = %u",u_octet4_loop_matchingAttributes);
        }

        for (i_matchingAttributes=0; i_matchingAttributes < u_octet4_loop_matchingAttributes; i_matchingAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/createRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_createRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/removeRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_removeRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "repositoryName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepositoryCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/getRepositoryIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/startTransaction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_startTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/commitTransaction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_commitTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyManager/abortTransaction:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyManager_abortTransaction(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getParentDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getParentGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/createGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_createGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/removeGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_removeGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroupCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getGroupIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/createRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_createRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/removeRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_removeRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRuleCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyGroup/getRuleIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/setRequiredAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_requiredAttributes;
    guint32   i_requiredAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_requiredAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of requiredAttributes = %u",u_octet4_loop_requiredAttributes);
        }

        for (i_requiredAttributes=0; i_requiredAttributes < u_octet4_loop_requiredAttributes; i_requiredAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/setOptionalAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_optionalAttributes;
    guint32   i_optionalAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_optionalAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of optionalAttributes = %u",u_octet4_loop_optionalAttributes);
        }

        for (i_optionalAttributes=0; i_optionalAttributes < u_octet4_loop_optionalAttributes; i_optionalAttributes++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getRequiredAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getOptionalAttributes:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAttributeSet;
    guint32   i_TpAttributeSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpAttributeSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAttributeSet = %u",u_octet4_loop_TpAttributeSet);
            }

            for (i_TpAttributeSet=0; i_TpAttributeSet < u_octet4_loop_TpAttributeSet; i_TpAttributeSet++) {

                /*  Begin struct "org_csapi_TpAttribute"  */

                

                decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_TpAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyEventDefinition/getParentDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyCondition/getParentRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyCondition/getParentRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyAction/getParentRepository:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRepository(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyAction/getParentRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setInputVariables:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_setInputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_inputVariables;
    guint32   i_inputVariables;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_inputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of inputVariables = %u",u_octet4_loop_inputVariables);
        }

        for (i_inputVariables=0; i_inputVariables < u_octet4_loop_inputVariables; i_inputVariables++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "inputVariables");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setOutputVariables:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_outputVariables;
    guint32   i_outputVariables;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_outputVariables = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of outputVariables = %u",u_octet4_loop_outputVariables);
        }

        for (i_outputVariables=0; i_outputVariables < u_octet4_loop_outputVariables; i_outputVariables++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "outputVariables");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getInputVariables:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_getInputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getOutputVariables:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setGroupNames:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_setGroupNames(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_groupNames;
    guint32   i_groupNames;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_groupNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of groupNames = %u",u_octet4_loop_groupNames);
        }

        for (i_groupNames=0; i_groupNames < u_octet4_loop_groupNames; i_groupNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupNames");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/setPolicyRoles:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_roleNames;
    guint32   i_roleNames;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_roleNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of roleNames = %u",u_octet4_loop_roleNames);
        }

        for (i_roleNames=0; i_roleNames < u_octet4_loop_roleNames; i_roleNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "roleNames");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getGroupNames:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_getGroupNames(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getPolicyRoles:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpStringSet;
    guint32   i_TpStringSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringSet = %u",u_octet4_loop_TpStringSet);
            }

            for (i_TpStringSet=0; i_TpStringSet < u_octet4_loop_TpStringSet; i_TpStringSet++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringSet");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicySignature/getParentDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicySignature_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getParentDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeDomain:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeDomain(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "domainName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomainCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getDomainIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeGroup:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "groupName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroupCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getGroupIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeRule:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeRule(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ruleName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRuleCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getRuleIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createEventDefinition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_requiredAttributes;
    guint32   i_requiredAttributes;
    guint32   u_octet4_loop_optionalAttributes;
    guint32   i_optionalAttributes;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "eventDefinitionName");

        u_octet4_loop_requiredAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of requiredAttributes = %u",u_octet4_loop_requiredAttributes);
        }

        for (i_requiredAttributes=0; i_requiredAttributes < u_octet4_loop_requiredAttributes; i_requiredAttributes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "requiredAttributes");

        }

        u_octet4_loop_optionalAttributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of optionalAttributes = %u",u_octet4_loop_optionalAttributes);
        }

        for (i_optionalAttributes=0; i_optionalAttributes < u_octet4_loop_optionalAttributes; i_optionalAttributes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "optionalAttributes");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "eventDefinitionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeEventDefinition:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "eventDefinitionName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinitionCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getEventDefinitionIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createVariableSet:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSet:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyVarSet;
    guint32   i_TpPolicyVarSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPolicyVarSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyVarSet = %u",u_octet4_loop_TpPolicyVarSet);
            }

            for (i_TpPolicyVarSet=0; i_TpPolicyVarSet < u_octet4_loop_TpPolicyVarSet; i_TpPolicyVarSet++) {

                /*  Begin struct "org_csapi_policy_TpPolicyVar"  */

                

                decode_org_csapi_policy_TpPolicyVar_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_policy_TpPolicyVar"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeVariableSet:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSetCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableSetIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createVariable:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_policy_TpPolicyType"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/setVariableValue:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableType:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_policy_TpPolicyType"  */

            
            decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_policy_TpPolicyType"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariableValue:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getVariable:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_policy_TpPolicyVar"  */

            

            decode_org_csapi_policy_TpPolicyVar_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_policy_TpPolicyVar"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeVariable:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariable(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variablSetName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "variableName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/createSignature:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_createSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signatureName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignature:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signatureName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/removeSignature:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_removeSignature(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "signatureName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignatureCount:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpInt32 = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/policy/provisioning/IpPolicyDomain/getSignatureIterator:1.0
 */

static void
decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/createIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/deleteIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/isIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/createGroupIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/deleteGroupIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/addToGroup:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "group");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "member");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/removeFromGroup:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "group");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listMembers:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/isGroupIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listGroupMembership:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/addAlias:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "alias");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/removeAliases:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "alias");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listAliases:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/lookupByAlias:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "alias");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQName");

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/associateTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/disassociateTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_identityTypes;
    guint32   i_identityTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_identityTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of identityTypes = %u",u_octet4_loop_identityTypes);
        }

        for (i_identityTypes=0; i_identityTypes < u_octet4_loop_identityTypes; i_identityTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/listTypesOfIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/hasType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/getIdentityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityManagement/setIdentityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityType");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/createAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/deleteAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/isAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/enableCapabilities:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilities");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/disableCapabilities:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilities");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listEnabledCapabilities:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCapabilityList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listAllCapabilities:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCapabilityList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/isCapableOf:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/associateTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/disassociateTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_agentTypes;
    guint32   i_agentTypes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_agentTypes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of agentTypes = %u",u_octet4_loop_agentTypes);
        }

        for (i_agentTypes=0; i_agentTypes < u_octet4_loop_agentTypes; i_agentTypes++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentTypes");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/listTypesOfAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/hasType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_hasType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/getAgentAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentManagement/setAgentAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/assignAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/unassignAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssignedAgents:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssociatedIdentitiesOfAgent:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listAssignedAgentsByCapability:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMFQNameList;
    guint32   i_TpPAMFQNameList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMFQNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMFQNameList = %u",u_octet4_loop_TpPAMFQNameList);
            }

            for (i_TpPAMFQNameList=0; i_TpPAMFQNameList < u_octet4_loop_TpPAMFQNameList; i_TpPAMFQNameList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMFQNameList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/listCapabilitiesOfIdentity:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCapabilityList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentAssignment/isIdentityCapableOf:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/createIdentityAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/deleteIdentityAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/getIdentityAttributeDefinition:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listAllIdentityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/createIdentityType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/deleteIdentityType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listIdentityTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/addIdentityTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/removeIdentityTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMIdentityTypeManagement/listIdentityTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/createAgentAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/deleteAgentAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/getAgentAttributeDefinition:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAllAgentAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/createAgentType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/deleteAgentType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAgentTypes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/addAgentTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/removeAgentTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMAgentTypeManagement/listAgentTypeAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "typeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/createCapabilityAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

        

        decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/deleteCapabilityAttribute:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/getCapabilityAttributeDefinition:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAttributeDef"  */

            

            decode_org_csapi_pam_TpPAMAttributeDef_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttributeDef"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listAllCapabilityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/createCapability:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilityName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/deleteCapability:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilityName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilities:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCapabilityList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/addCapabilityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilityName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/removeCapabilityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilityName");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilityAttributes:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpStringList;
    guint32   i_TpStringList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilityName");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpStringList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpStringList = %u",u_octet4_loop_TpStringList);
            }

            for (i_TpStringList=0; i_TpStringList < u_octet4_loop_TpStringList; i_TpStringList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStringList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/assignCapabilitiesToType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilities");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/unassignCapabilitiesFromType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_capabilities;
    guint32   i_capabilities;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of capabilities = %u",u_octet4_loop_capabilities);
        }

        for (i_capabilities=0; i_capabilities < u_octet4_loop_capabilities; i_capabilities++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capabilities");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMCapabilityManagement/listCapabilitiesOfType:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMCapabilityList;
    guint32   i_TpPAMCapabilityList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCapabilityList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCapabilityList = %u",u_octet4_loop_TpPAMCapabilityList);
            }

            for (i_TpPAMCapabilityList=0; i_TpPAMCapabilityList < u_octet4_loop_TpPAMCapabilityList; i_TpPAMCapabilityList++) {

                giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCapabilityList");

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/getAuthToken:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/obtainInterface:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/getAccessControl:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/provisioning/IpPAMProvisioningManager/setAccessControl:1.0
 */

static void
decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "operation");

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/setIdentityPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityType");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/setIdentityPresenceExpiration:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMIdentityPresence/getIdentityPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identityType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setAgentPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setCapabilityPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributes;
    guint32   i_attributes;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributes = %u",u_octet4_loop_attributes);
        }

        for (i_attributes=0; i_attributes < u_octet4_loop_attributes; i_attributes++) {

            /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

            

            decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAttribute"  */

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setAgentPresenceExpiration:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/setCapabilityPresenceExpiration:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"expiresIn = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/getAgentPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agentType");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAgentPresence/getCapabilityPresence:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAttributeList;
    guint32   i_TpPAMAttributeList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "agent");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "capability");

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAttributeList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAttributeList = %u",u_octet4_loop_TpPAMAttributeList);
            }

            for (i_TpPAMAttributeList=0; i_TpPAMAttributeList < u_octet4_loop_TpPAMAttributeList; i_TpPAMAttributeList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAttribute"  */

                

                decode_org_csapi_pam_TpPAMAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAttribute"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpAppPAMPreferenceCheck/computeAvailability:1.0
 */

static void
decode_org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAvailabilityProfileList;
    guint32   i_TpPAMAvailabilityProfileList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAvailabilityProfileList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAvailabilityProfileList = %u",u_octet4_loop_TpPAMAvailabilityProfileList);
            }

            for (i_TpPAMAvailabilityProfileList=0; i_TpPAMAvailabilityProfileList < u_octet4_loop_TpPAMAvailabilityProfileList; i_TpPAMAvailabilityProfileList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

                

                decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/getAvailability:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAvailability_getAvailability(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_attributeNames;
    guint32   i_attributeNames;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    guint32   u_octet4_loop_TpPAMAvailabilityProfileList;
    guint32   i_TpPAMAvailabilityProfileList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_attributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of attributeNames = %u",u_octet4_loop_attributeNames);
        }

        for (i_attributeNames=0; i_attributeNames < u_octet4_loop_attributeNames; i_attributeNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "attributeNames");

        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMAvailabilityProfileList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAvailabilityProfileList = %u",u_octet4_loop_TpPAMAvailabilityProfileList);
            }

            for (i_TpPAMAvailabilityProfileList=0; i_TpPAMAvailabilityProfileList < u_octet4_loop_TpPAMAvailabilityProfileList; i_TpPAMAvailabilityProfileList++) {

                /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

                

                decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

                /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/getPreference:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAvailability_getPreference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin union "org_csapi_pam_TpPAMPreferenceData"  */

            
            decode_org_csapi_pam_TpPAMPreferenceData_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_pam_TpPAMPreferenceData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMAvailability/setPreference:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMAvailability_setPreference(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "operation");

        /*  Begin union "org_csapi_pam_TpPAMPreferenceData"  */

        
        decode_org_csapi_pam_TpPAMPreferenceData_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_pam_TpPAMPreferenceData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/getAuthToken:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/obtainInterface:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/getAccessControl:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/setAccessControl:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "operation");

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/activateService:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/deactivateService:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/access/IpPAMPresenceAvailabilityManager/isActiveIdentity:1.0
 */

static void
decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpAppPAMEventHandler/eventNotify:1.0
 */

static void
decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotify(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventInfo;
    guint32   i_eventInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventInfo = %u",u_octet4_loop_eventInfo);
        }

        for (i_eventInfo=0; i_eventInfo < u_octet4_loop_eventInfo; i_eventInfo++) {

            /*  Begin union "org_csapi_pam_TpPAMNotificationInfo"  */

            
            decode_org_csapi_pam_TpPAMNotificationInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_pam_TpPAMNotificationInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpAppPAMEventHandler/eventNotifyErr:1.0
 */

static void
decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_pam_TpPAMErrorInfo"  */

        

        decode_org_csapi_pam_TpPAMErrorInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMErrorInfo"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/isRegistered:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventHandler_isRegistered(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/registerAppInterface:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventHandler_registerAppInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMClientID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/registerForEvent:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventHandler_registerForEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventList;
    guint32   i_eventList;
    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventList = %u",u_octet4_loop_eventList);
        }

        for (i_eventList=0; i_eventList < u_octet4_loop_eventList; i_eventList++) {

            /*  Begin union "org_csapi_pam_TpPAMEventInfo"  */

            
            decode_org_csapi_pam_TpPAMEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_pam_TpPAMEventInfo"  */

        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"validFor = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMEventID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/deregisterAppInterface:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"clientID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventHandler/deregisterFromEvent:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"eventID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/getAuthToken:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_getAuthToken(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_askerData;
    guint32   i_askerData;
    guint32   u_octet4_loop_TpPAMCredential;
    guint32   i_TpPAMCredential;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_askerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of askerData = %u",u_octet4_loop_askerData);
        }

        for (i_askerData=0; i_askerData < u_octet4_loop_askerData; i_askerData++) {

            /*  Begin struct "org_csapi_TpAttribute"  */

            

            decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAttribute"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            u_octet4_loop_TpPAMCredential = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCredential = %u",u_octet4_loop_TpPAMCredential);
            }

            for (i_TpPAMCredential=0; i_TpPAMCredential < u_octet4_loop_TpPAMCredential; i_TpPAMCredential++) {

                if (tree) {
                   proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMCredential = %u",get_CDR_octet(tvb,offset));
                }

            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/obtainInterface:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_obtainInterface(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "interfaceName");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/getAccessControl:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_getAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

            

            decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/setAccessControl:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_setAccessControl(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "operation");

        /*  Begin struct "org_csapi_pam_TpPAMAccessControlData"  */

        

        decode_org_csapi_pam_TpPAMAccessControlData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAccessControlData"  */

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/activateService:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_activateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/deactivateService:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_deactivateService(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/pam/event/IpPAMEventManager/isActiveIdentity:1.0
 */

static void
decode_org_csapi_pam_event_IpPAMEventManager_isActiveIdentity(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_authToken;
    guint32   i_authToken;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "identity");

        u_octet4_loop_authToken = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of authToken = %u",u_octet4_loop_authToken);
        }

        for (i_authToken=0; i_authToken < u_octet4_loop_authToken; i_authToken++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"authToken = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"TpBoolean = %u",get_CDR_boolean(tvb,offset));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/mailboxTerminated:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

        

        decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/reportNotification:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventInfo;
    guint32   i_eventInfo;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventInfo = %u",u_octet4_loop_eventInfo);
        }

        for (i_eventInfo=0; i_eventInfo < u_octet4_loop_eventInfo; i_eventInfo++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventInfo"  */

            
            decode_org_csapi_mmm_TpMessagingEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessagingEventInfo"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/notificationsInterrupted:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/notificationsResumed:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/multiMediaMessagingTerminated:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        

        decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/terminateMultipleMailboxes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_mailboxSet;
    guint32   i_mailboxSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_mailboxSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of mailboxSet = %u",u_octet4_loop_mailboxSet);
        }

        for (i_mailboxSet=0; i_mailboxSet < u_octet4_loop_mailboxSet; i_mailboxSet++) {

            /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

            

            decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessagingManager/terminateMultipleMultiMediaMessagingSessions:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_multiMediaMessagingSet;
    guint32   i_multiMediaMessagingSet;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        u_octet4_loop_multiMediaMessagingSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of multiMediaMessagingSet = %u",u_octet4_loop_multiMediaMessagingSet);
        }

        for (i_multiMediaMessagingSet=0; i_multiMediaMessagingSet < u_octet4_loop_multiMediaMessagingSet; i_multiMediaMessagingSet++) {

            /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            

            decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/openMailbox:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "mailboxID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "authenticationInfo");

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMailboxIdentifier"  */

            

            decode_org_csapi_mmm_TpMailboxIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMailboxIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/openMultiMediaMessaging:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        /*  Begin struct "org_csapi_mmm_TpTerminatingAddressList"  */

        

        decode_org_csapi_mmm_TpTerminatingAddressList_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpTerminatingAddressList"  */

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            

            decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/createNotification:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_createNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventCriteria;
    guint32   i_eventCriteria;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        u_octet4_loop_eventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventCriteria = %u",u_octet4_loop_eventCriteria);
        }

        for (i_eventCriteria=0; i_eventCriteria < u_octet4_loop_eventCriteria; i_eventCriteria++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

            
            decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/destroyNotification:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/changeNotification:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_eventCriteria;
    guint32   i_eventCriteria;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_eventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of eventCriteria = %u",u_octet4_loop_eventCriteria);
        }

        for (i_eventCriteria=0; i_eventCriteria < u_octet4_loop_eventCriteria; i_eventCriteria++) {

            /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

            
            decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/getNextNotification:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /*  Begin struct "org_csapi_mmm_TpMessagingNotificationRequestedSetEntry"  */

            

            decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMessagingNotificationRequestedSetEntry"  */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/enableNotifications:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessagingManager/disableNotifications:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/createFolderRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_createFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/createFolderErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_createFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFoldersRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFoldersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_folderNames;
    guint32   i_folderNames;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        u_octet4_loop_folderNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of folderNames = %u",u_octet4_loop_folderNames);
        }

        for (i_folderNames=0; i_folderNames < u_octet4_loop_folderNames; i_folderNames++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderNames");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFoldersErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFoldersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteFolderRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_deleteFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteFolderErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_deleteFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyFolderRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_copyFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyFolderErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_copyFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveFolderRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_moveFolderRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveFolderErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_moveFolderErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/putMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_putMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/putMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_putMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_copyMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/copyMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_copyMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_moveMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/moveMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_moveMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_deleteMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/deleteMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_deleteMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessagesRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_listMessagesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_messageList;
    guint32   i_messageList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_messageList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageList = %u",u_octet4_loop_messageList);
        }

        for (i_messageList=0; i_messageList < u_octet4_loop_messageList; i_messageList++) {

            /*  Begin struct "org_csapi_mmm_TpMessageDescription"  */

            

            decode_org_csapi_mmm_TpMessageDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMessageDescription"  */

        }

        /*  Begin struct "org_csapi_mmm_TpMailboxFolderStatusInformation"  */

        

        decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpMailboxFolderStatusInformation"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"final = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessagesErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_listMessagesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessageBodyPartsRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_partsList;
    guint32   i_partsList;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_partsList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of partsList = %u",u_octet4_loop_partsList);
        }

        for (i_partsList=0; i_partsList < u_octet4_loop_partsList; i_partsList++) {

            /*  Begin struct "org_csapi_mmm_TpBodyPartDescription"  */

            

            decode_org_csapi_mmm_TpBodyPartDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpBodyPartDescription"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/listMessageBodyPartsErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageBodyPartsRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_bodyParts;
    guint32   i_bodyParts;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_bodyParts = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of bodyParts = %u",u_octet4_loop_bodyParts);
        }

        for (i_bodyParts=0; i_bodyParts < u_octet4_loop_bodyParts; i_bodyParts++) {

            /*  Begin struct "org_csapi_mmm_TpBodyPart"  */

            

            decode_org_csapi_mmm_TpBodyPart_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpBodyPart"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageBodyPartsErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageHeadersRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_headers;
    guint32   i_headers;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of headers = %u",u_octet4_loop_headers);
        }

        for (i_headers=0; i_headers < u_octet4_loop_headers; i_headers++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageHeadersErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageContentRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageContentRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_content;
    guint32   i_content;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "contentType");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "contentTransferEncoding");

        u_octet4_loop_content = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of content = %u",u_octet4_loop_content);
        }

        for (i_content=0; i_content < u_octet4_loop_content; i_content++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"content = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageContentErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageContentErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFullMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFullMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_message;
    guint32   i_message;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFullMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFullMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMailboxInfoPropertiesRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpMailboxInfoProperty"  */

            
            decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMailboxInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFolderInfoPropertiesRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpFolderInfoProperty"  */

            
            decode_org_csapi_mmm_TpFolderInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpFolderInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageInfoPropertiesRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_returnedProperties;
    guint32   i_returnedProperties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        u_octet4_loop_returnedProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of returnedProperties = %u",u_octet4_loop_returnedProperties);
        }

        for (i_returnedProperties=0; i_returnedProperties < u_octet4_loop_returnedProperties; i_returnedProperties++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/setMessageInfoPropertiesRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_propertiesUpdated;
    guint32   i_propertiesUpdated;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        u_octet4_loop_propertiesUpdated = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertiesUpdated = %u",u_octet4_loop_propertiesUpdated);
        }

        for (i_propertiesUpdated=0; i_propertiesUpdated < u_octet4_loop_propertiesUpdated; i_propertiesUpdated++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/setMessageInfoPropertiesErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_propertiesNotUpdated;
    guint32   i_propertiesNotUpdated;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        u_octet4_loop_propertiesNotUpdated = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of propertiesNotUpdated = %u",u_octet4_loop_propertiesNotUpdated);
        }

        for (i_propertiesNotUpdated=0; i_propertiesNotUpdated < u_octet4_loop_propertiesNotUpdated; i_propertiesNotUpdated++) {

            /*  Begin struct "org_csapi_mmm_TpMessageInfoPropertyError"  */

            

            decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpMessageInfoPropertyError"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMailboxInfoPropertiesErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getFolderInfoPropertiesErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMailbox/getMessageInfoPropertiesErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"requestID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/close:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/createFolderReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_createFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFoldersReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getFoldersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/deleteFolderReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_deleteFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/copyFolderReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_copyFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sourceFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "destinationFolderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/moveFolderReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_moveFolderReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "sourceFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "destinationFolderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/putMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_putMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_message;
    guint32   i_message;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",get_CDR_octet(tvb,offset));
            }

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/copyMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_copyMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "fromFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "toFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/moveMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_moveMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "fromFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "toFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/deleteMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_deleteMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "fromFolderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/listMessagesReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_listMessagesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        /*  Begin struct "org_csapi_mmm_TpListMessagesCriteria"  */

        

        decode_org_csapi_mmm_TpListMessagesCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpListMessagesCriteria"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"reset = %u",get_CDR_boolean(tvb,offset));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/listMessageBodyPartsReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_listMessageBodyPartsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"maxNestingLevel = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageBodyPartsReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getMessageBodyPartsReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_partIDs;
    guint32   i_partIDs;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        u_octet4_loop_partIDs = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of partIDs = %u",u_octet4_loop_partIDs);
        }

        for (i_partIDs=0; i_partIDs < u_octet4_loop_partIDs; i_partIDs++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "partIDs");

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageHeadersReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getMessageHeadersReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageContentReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getMessageContentReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFullMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getFullMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMailboxInfoPropertiesReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getFolderInfoPropertiesReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "folderID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/getMessageInfoPropertiesReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMailbox/setMessageInfoPropertiesReq:1.0
 */

static void
decode_org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_properties;
    guint32   i_properties;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"mailboxSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "messageID");

        u_octet4_loop_properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of properties = %u",u_octet4_loop_properties);
        }

        for (i_properties=0; i_properties < u_octet4_loop_properties; i_properties++) {

            /*  Begin union "org_csapi_mmm_TpMessageInfoProperty"  */

            
            decode_org_csapi_mmm_TpMessageInfoProperty_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageInfoProperty"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/sendMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/sendMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/cancelMessageRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/cancelMessageErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/queryStatusRes:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_result;
    guint32   i_result;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_result = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of result = %u",u_octet4_loop_result);
        }

        for (i_result=0; i_result < u_octet4_loop_result; i_result++) {

            /*  Begin struct "org_csapi_mmm_TpQueryStatusReport"  */

            

            decode_org_csapi_mmm_TpQueryStatusReport_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_mmm_TpQueryStatusReport"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/queryStatusErr:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingError,"Unknown Enum Value"));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "errorDetails");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/messageStatusReport:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"deliveryReportType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "deliveryReportInfo");

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpAppMultiMediaMessaging/messageReceived:1.0
 */

static void
decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint32   u_octet4_loop_headers;
    guint32   i_headers;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",get_CDR_octet(tvb,offset));
            }

        }

        u_octet4_loop_headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of headers = %u",u_octet4_loop_headers);
        }

        for (i_headers=0; i_headers < u_octet4_loop_headers; i_headers++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/sendMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_messageTreatment;
    guint32   i_messageTreatment;
    guint32   u_octet4_loop_message;
    guint32   i_message;
    guint32   u_octet4_loop_additionalHeaders;
    guint32   i_additionalHeaders;
    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        /*  Begin struct "org_csapi_mmm_TpTerminatingAddressList"  */

        

        decode_org_csapi_mmm_TpTerminatingAddressList_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpTerminatingAddressList"  */

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "deliveryType");

        u_octet4_loop_messageTreatment = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of messageTreatment = %u",u_octet4_loop_messageTreatment);
        }

        for (i_messageTreatment=0; i_messageTreatment < u_octet4_loop_messageTreatment; i_messageTreatment++) {

            /*  Begin union "org_csapi_mmm_TpMessageTreatment"  */

            
            decode_org_csapi_mmm_TpMessageTreatment_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageTreatment"  */

        }

        u_octet4_loop_message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of message = %u",u_octet4_loop_message);
        }

        for (i_message=0; i_message < u_octet4_loop_message; i_message++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"message = %u",get_CDR_octet(tvb,offset));
            }

        }

        u_octet4_loop_additionalHeaders = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of additionalHeaders = %u",u_octet4_loop_additionalHeaders);
        }

        for (i_additionalHeaders=0; i_additionalHeaders < u_octet4_loop_additionalHeaders; i_additionalHeaders++) {

            /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

            
            decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TpAssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
            }

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/cancelMessageReq:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/queryStatusReq:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"assignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/*
 * IDL:org/csapi/mmm/IpMultiMediaMessaging/close:1.0
 */

static void
decode_org_csapi_mmm_IpMultiMediaMessaging_close(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    
    switch(header->message_type) {

    case Request:

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"sessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        break;

    case Reply:

        switch(header->rep_status) {

        case NO_EXCEPTION:

            /* Function returns void */

            break;

        case USER_EXCEPTION:

            break;

        default:
            {
        	proto_item *pi;

        	/* Unknown Exception */
        	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown exception %d", header->rep_status);
        	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown exception %d", header->rep_status);
            }

            break;

        
        }   /* switch(header->message_type) */

        break;

    default:
        {
    	proto_item *pi;

    	/* Unknown GIOP Message */
    	pi = proto_tree_add_text(tree, tvb, 0, 0, "Unknown GIOP message %d", header->message_type);
    	expert_add_info_format(pinfo, pi, PI_MALFORMED, PI_ERROR, "Unknown GIOP message %d", header->message_type);
        }

        break;

    } /* switch(header->message_type) */

}

/* Struct = IDL:org/csapi/TpAddress:1.0 */
static void
decode_org_csapi_TpAddress_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAddress_Plan  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPlan,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddress_AddrString");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddress_Name");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAddress_Presentation  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPresentation,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAddress_Screening  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressScreening,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddress_SubAddressString");

}

/* Struct = IDL:org/csapi/TpAddressRange:1.0 */
static void
decode_org_csapi_TpAddressRange_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAddressRange_Plan  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressPlan,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddressRange_AddrString");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddressRange_Name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddressRange_SubAddressString");

}

/* Struct = IDL:org/csapi/TpCAIElements:1.0 */
static void
decode_org_csapi_TpCAIElements_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitsPerInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_SecondsPerTimeInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_ScalingFactor = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitIncrement = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_UnitsPerDataInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_SegmentsPerDataInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCAIElements_InitialSecsPerTimeInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/TpChargeAdviceInfo:1.0 */
static void
decode_org_csapi_TpChargeAdviceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpCAIElements"  */

    

    decode_org_csapi_TpCAIElements_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpCAIElements"  */

    /*  Begin struct "org_csapi_TpCAIElements"  */

    

    decode_org_csapi_TpCAIElements_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpCAIElements"  */

}

/* Struct = IDL:org/csapi/TpChargePerTime:1.0 */
static void
decode_org_csapi_TpChargePerTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_InitialCharge = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_CurrentChargePerMinute = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerTime_NextChargePerMinute = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/TpAoCInfo:1.0 */
static void
decode_org_csapi_TpAoCInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin union "org_csapi_TpAoCOrder"  */

    
    decode_org_csapi_TpAoCOrder_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_TpAoCOrder"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAoCInfo_Currency");

}

/* Struct = IDL:org/csapi/TpTimeInterval:1.0 */
static void
decode_org_csapi_TpTimeInterval_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTimeInterval_StartTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTimeInterval_StopTime");

}

/* Struct = IDL:org/csapi/TpStructuredAttributeValue:1.0 */
static void
decode_org_csapi_TpStructuredAttributeValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpStructuredAttributeValue_Type");

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/TpAttribute:1.0 */
static void
decode_org_csapi_TpAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAttribute_AttributeName");

    /*  Begin union "org_csapi_TpAttributeValue"  */

    
    decode_org_csapi_TpAttributeValue_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_TpAttributeValue"  */

}

/* Struct = IDL:org/csapi/fw/TpFaultStats:1.0 */
static void
decode_org_csapi_fw_TpFaultStats_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_Fault  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpInterfaceFault,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_Occurrences = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_MaxDuration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_TotalDuration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFaultStats_NumberOfClientsAffected = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/fw/TpFaultStatsRecord:1.0 */
static void
decode_org_csapi_fw_TpFaultStatsRecord_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpFaultStatsRecord_FaultStatsSet;
    guint32   i_TpFaultStatsRecord_FaultStatsSet;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpTimeInterval"  */

    

    decode_org_csapi_TpTimeInterval_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpTimeInterval"  */

    u_octet4_loop_TpFaultStatsRecord_FaultStatsSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFaultStatsRecord_FaultStatsSet = %u",u_octet4_loop_TpFaultStatsRecord_FaultStatsSet);
    }

    for (i_TpFaultStatsRecord_FaultStatsSet=0; i_TpFaultStatsRecord_FaultStatsSet < u_octet4_loop_TpFaultStatsRecord_FaultStatsSet; i_TpFaultStatsRecord_FaultStatsSet++) {

        /*  Begin struct "org_csapi_fw_TpFaultStats"  */

        

        decode_org_csapi_fw_TpFaultStats_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFaultStats"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpLoadPolicy:1.0 */
static void
decode_org_csapi_fw_TpLoadPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpLoadPolicy_LoadPolicy");

}

/* Struct = IDL:org/csapi/fw/TpLoadStatisticData:1.0 */
static void
decode_org_csapi_fw_TpLoadStatisticData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadStatisticData_LoadValue = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadStatisticData_LoadLevel  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadThreshold:1.0 */
static void
decode_org_csapi_fw_TpLoadThreshold_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadThreshold_LoadThreshold = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadInitVal:1.0 */
static void
decode_org_csapi_fw_TpLoadInitVal_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadInitVal_LoadLevel  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadLevel,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_fw_TpLoadThreshold"  */

    

    decode_org_csapi_fw_TpLoadThreshold_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpLoadThreshold"  */

}

/* Struct = IDL:org/csapi/fw/TpProperty:1.0 */
static void
decode_org_csapi_fw_TpProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpProperty_PropertyName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpProperty_PropertyValue");

}

/* Struct = IDL:org/csapi/fw/TpClientAppDescription:1.0 */
static void
decode_org_csapi_fw_TpClientAppDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpClientAppDescription_ClientAppProperties;
    guint32   i_TpClientAppDescription_ClientAppProperties;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpClientAppDescription_ClientAppID");

    u_octet4_loop_TpClientAppDescription_ClientAppProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpClientAppDescription_ClientAppProperties = %u",u_octet4_loop_TpClientAppDescription_ClientAppProperties);
    }

    for (i_TpClientAppDescription_ClientAppProperties=0; i_TpClientAppDescription_ClientAppProperties < u_octet4_loop_TpClientAppDescription_ClientAppProperties; i_TpClientAppDescription_ClientAppProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpClientAppDescription_HasAccessSession = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpClientAppDescription_HasServiceInstances = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/fw/TpEntOp:1.0 */
static void
decode_org_csapi_fw_TpEntOp_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpEntOp_EntOpProperties;
    guint32   i_TpEntOp_EntOpProperties;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpEntOp_EntOpID");

    u_octet4_loop_TpEntOp_EntOpProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpEntOp_EntOpProperties = %u",u_octet4_loop_TpEntOp_EntOpProperties);
    }

    for (i_TpEntOp_EntOpProperties=0; i_TpEntOp_EntOpProperties < u_octet4_loop_TpEntOp_EntOpProperties; i_TpEntOp_EntOpProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpSag:1.0 */
static void
decode_org_csapi_fw_TpSag_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSag_SagID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSag_SagDescription");

}

/* Struct = IDL:org/csapi/fw/TpServiceProperty:1.0 */
static void
decode_org_csapi_fw_TpServiceProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceProperty_ServicePropertyValueList;
    guint32   i_TpServiceProperty_ServicePropertyValueList;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProperty_ServicePropertyName");

    u_octet4_loop_TpServiceProperty_ServicePropertyValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProperty_ServicePropertyValueList = %u",u_octet4_loop_TpServiceProperty_ServicePropertyValueList);
    }

    for (i_TpServiceProperty_ServicePropertyValueList=0; i_TpServiceProperty_ServicePropertyValueList < u_octet4_loop_TpServiceProperty_ServicePropertyValueList; i_TpServiceProperty_ServicePropertyValueList++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProperty_ServicePropertyValueList");

    }

}

/* Struct = IDL:org/csapi/fw/TpServiceDescription:1.0 */
static void
decode_org_csapi_fw_TpServiceDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceDescription_ServicePropertyList;
    guint32   i_TpServiceDescription_ServicePropertyList;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceDescription_ServiceTypeName");

    u_octet4_loop_TpServiceDescription_ServicePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceDescription_ServicePropertyList = %u",u_octet4_loop_TpServiceDescription_ServicePropertyList);
    }

    for (i_TpServiceDescription_ServicePropertyList=0; i_TpServiceDescription_ServicePropertyList < u_octet4_loop_TpServiceDescription_ServicePropertyList; i_TpServiceDescription_ServicePropertyList++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpService:1.0 */
static void
decode_org_csapi_fw_TpService_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpService_ServiceID");

    /*  Begin struct "org_csapi_fw_TpServiceDescription"  */

    

    decode_org_csapi_fw_TpServiceDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpServiceDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceProfileDescription:1.0 */
static void
decode_org_csapi_fw_TpServiceProfileDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties;
    guint32   i_TpServiceProfileDescription_ServiceSubscriptionProperties;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileDescription_ServiceContractID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileDescription_ServiceStartDate");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileDescription_ServiceEndDate");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileDescription_ServiceTypeName");

    u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceProfileDescription_ServiceSubscriptionProperties = %u",u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties);
    }

    for (i_TpServiceProfileDescription_ServiceSubscriptionProperties=0; i_TpServiceProfileDescription_ServiceSubscriptionProperties < u_octet4_loop_TpServiceProfileDescription_ServiceSubscriptionProperties; i_TpServiceProfileDescription_ServiceSubscriptionProperties++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceProfileDescription_InUse = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfileDescription_ServiceID");

}

/* Struct = IDL:org/csapi/fw/TpServiceTypeProperty:1.0 */
static void
decode_org_csapi_fw_TpServiceTypeProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypeProperty_ServicePropertyName");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpServiceTypeProperty_ServiceTypePropertyMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpServiceTypePropertyMode,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypeProperty_ServicePropertyTypeName");

}

/* Struct = IDL:org/csapi/fw/TpServiceTypeDescription:1.0 */
static void
decode_org_csapi_fw_TpServiceTypeDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList;
    guint32   i_TpServiceTypeDescription_ServiceTypePropertyList;
    guint32   u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList;
    guint32   i_TpServiceTypeDescription_ServiceTypeNameList;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeDescription_ServiceTypePropertyList = %u",u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList);
    }

    for (i_TpServiceTypeDescription_ServiceTypePropertyList=0; i_TpServiceTypeDescription_ServiceTypePropertyList < u_octet4_loop_TpServiceTypeDescription_ServiceTypePropertyList; i_TpServiceTypeDescription_ServiceTypePropertyList++) {

        /*  Begin struct "org_csapi_fw_TpServiceTypeProperty"  */

        

        decode_org_csapi_fw_TpServiceTypeProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceTypeProperty"  */

    }

    u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypeDescription_ServiceTypeNameList = %u",u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList);
    }

    for (i_TpServiceTypeDescription_ServiceTypeNameList=0; i_TpServiceTypeDescription_ServiceTypeNameList < u_octet4_loop_TpServiceTypeDescription_ServiceTypeNameList; i_TpServiceTypeDescription_ServiceTypeNameList++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypeDescription_ServiceTypeNameList");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceTypeDescription_AvailableOrUnavailable = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/fw/TpSignatureAndServiceMgr:1.0 */
static void
decode_org_csapi_fw_TpSignatureAndServiceMgr_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature;
    guint32   i_TpSignatureAndServiceMgr_DigitalSignature;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpSignatureAndServiceMgr_DigitalSignature = %u",u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature);
    }

    for (i_TpSignatureAndServiceMgr_DigitalSignature=0; i_TpSignatureAndServiceMgr_DigitalSignature < u_octet4_loop_TpSignatureAndServiceMgr_DigitalSignature; i_TpSignatureAndServiceMgr_DigitalSignature++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpSignatureAndServiceMgr_DigitalSignature = %u",get_CDR_octet(tvb,offset));
        }

    }

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/fw/TpPerson:1.0 */
static void
decode_org_csapi_fw_TpPerson_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPerson_PersonProperties;
    guint32   i_TpPerson_PersonProperties;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPerson_PersonName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPerson_PostalAddress");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPerson_TelephoneNumber");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPerson_Email");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPerson_HomePage");

    u_octet4_loop_TpPerson_PersonProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPerson_PersonProperties = %u",u_octet4_loop_TpPerson_PersonProperties);
    }

    for (i_TpPerson_PersonProperties=0; i_TpPerson_PersonProperties < u_octet4_loop_TpPerson_PersonProperties; i_TpPerson_PersonProperties++) {

        /*  Begin struct "org_csapi_fw_TpProperty"  */

        

        decode_org_csapi_fw_TpProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpProperty"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpServiceContractDescription:1.0 */
static void
decode_org_csapi_fw_TpServiceContractDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties;
    guint32   i_TpServiceContractDescription_ServiceSubscriptionProperties;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_fw_TpPerson"  */

    

    decode_org_csapi_fw_TpPerson_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpPerson"  */

    /*  Begin struct "org_csapi_fw_TpPerson"  */

    

    decode_org_csapi_fw_TpPerson_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpPerson"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractDescription_ServiceStartDate");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractDescription_ServiceEndDate");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractDescription_ServiceTypeName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContractDescription_ServiceID");

    u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceContractDescription_ServiceSubscriptionProperties = %u",u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties);
    }

    for (i_TpServiceContractDescription_ServiceSubscriptionProperties=0; i_TpServiceContractDescription_ServiceSubscriptionProperties < u_octet4_loop_TpServiceContractDescription_ServiceSubscriptionProperties; i_TpServiceContractDescription_ServiceSubscriptionProperties++) {

        /*  Begin struct "org_csapi_fw_TpServiceProperty"  */

        

        decode_org_csapi_fw_TpServiceProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpServiceProperty"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpServiceContractDescription_InUse = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/fw/TpLoadStatistic:1.0 */
static void
decode_org_csapi_fw_TpLoadStatistic_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin union "org_csapi_fw_TpLoadStatisticEntityID"  */

    
    decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_fw_TpLoadStatisticEntityID"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpLoadStatistic_TimeStamp");

    /*  Begin union "org_csapi_fw_TpLoadStatisticInfo"  */

    
    decode_org_csapi_fw_TpLoadStatisticInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_fw_TpLoadStatisticInfo"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceContract:1.0 */
static void
decode_org_csapi_fw_TpServiceContract_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceContract_ServiceContractID");

    /*  Begin struct "org_csapi_fw_TpServiceContractDescription"  */

    

    decode_org_csapi_fw_TpServiceContractDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpServiceContractDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpServiceProfile:1.0 */
static void
decode_org_csapi_fw_TpServiceProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceProfile_ServiceProfileID");

    /*  Begin struct "org_csapi_fw_TpServiceProfileDescription"  */

    

    decode_org_csapi_fw_TpServiceProfileDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpServiceProfileDescription"  */

}

/* Struct = IDL:org/csapi/fw/TpAuthDomain:1.0 */
static void
decode_org_csapi_fw_TpAuthDomain_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin union "org_csapi_fw_TpDomainID"  */

    
    decode_org_csapi_fw_TpDomainID_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_fw_TpDomainID"  */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/fw/TpSagProfilePair:1.0 */
static void
decode_org_csapi_fw_TpSagProfilePair_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagProfilePair_Sag");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpSagProfilePair_ServiceProfile");

}

/* Struct = IDL:org/csapi/fw/TpAddSagMembersConflict:1.0 */
static void
decode_org_csapi_fw_TpAddSagMembersConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddSagMembersConflict_ClientApplication");

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAddSagMembersConflict_Service");

}

/* Struct = IDL:org/csapi/fw/TpAssignSagToServiceProfileConflict:1.0 */
static void
decode_org_csapi_fw_TpAssignSagToServiceProfileConflict_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAssignSagToServiceProfileConflict_ClientApplication");

    /*  Begin struct "org_csapi_fw_TpSagProfilePair"  */

    

    decode_org_csapi_fw_TpSagProfilePair_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_fw_TpSagProfilePair"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpAssignSagToServiceProfileConflict_Service");

}

/* Struct = IDL:org/csapi/fw/TpServiceTypePropertyValue:1.0 */
static void
decode_org_csapi_fw_TpServiceTypePropertyValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList;
    guint32   i_TpServiceTypePropertyValue_ServicePropertyValueList;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypePropertyValue_ServicePropertyName");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpServiceTypePropertyValue_ServiceTypePropertyMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpServiceTypePropertyMode,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypePropertyValue_ServicePropertyTypeName");

    u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpServiceTypePropertyValue_ServicePropertyValueList = %u",u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList);
    }

    for (i_TpServiceTypePropertyValue_ServicePropertyValueList=0; i_TpServiceTypePropertyValue_ServicePropertyValueList < u_octet4_loop_TpServiceTypePropertyValue_ServicePropertyValueList; i_TpServiceTypePropertyValue_ServicePropertyValueList++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpServiceTypePropertyValue_ServicePropertyValueList");

    }

}

/* Struct = IDL:org/csapi/fw/TpFwMigrationServiceAvailableInfo:1.0 */
static void
decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo;
    guint32   i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwMigrationServiceAvailableInfo_ServiceType");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwMigrationServiceAvailableInfo_ServiceID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwMigrationServiceAvailableInfo_CompatibleServiceID");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_BackwardCompatibilityLevel = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_MigrationRequired = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpFwMigrationServiceAvailableInfo_DataMigrated = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwMigrationServiceAvailableInfo_MigrationDataAndTime");

    u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo = %u",u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo);
    }

    for (i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo=0; i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo < u_octet4_loop_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo; i_TpFwMigrationServiceAvailableInfo_MigrationAdditionalInfo++) {

        /*  Begin union "org_csapi_fw_TpMigrationAdditionalInfo"  */

        
        decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_fw_TpMigrationAdditionalInfo"  */

    }

}

/* Struct = IDL:org/csapi/fw/TpFwAgreementInfo:1.0 */
static void
decode_org_csapi_fw_TpFwAgreementInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwAgreementInfo_ClientApplicationID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwAgreementInfo_ServiceID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwAgreementInfo_ServiceContractID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpFwAgreementInfo_ServiceProfileID");

}

/* Struct = IDL:org/csapi/ui/TpUIMessageCriteria:1.0 */
static void
decode_org_csapi_ui_TpUIMessageCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIMessageCriteria_EndSequence");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIMessageCriteria_MaxMessageTime = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIMessageCriteria_MaxMessageSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/ui/TpUIEventInfo:1.0 */
static void
decode_org_csapi_ui_TpUIEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIEventInfo_ServiceCode");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIEventInfo_DataTypeIndication  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIEventInfoDataType,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIEventInfo_DataString");

}

/* Struct = IDL:org/csapi/ui/TpUIEventCriteria:1.0 */
static void
decode_org_csapi_ui_TpUIEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIEventCriteria_ServiceCode");

}

/* Struct = IDL:org/csapi/ui/TpUIEventCriteriaResult:1.0 */
static void
decode_org_csapi_ui_TpUIEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_ui_TpUIEventCriteria"  */

    

    decode_org_csapi_ui_TpUIEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_ui_TpUIEventCriteria"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIEventCriteriaResult_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/ui/TpUIEventNotificationInfo:1.0 */
static void
decode_org_csapi_ui_TpUIEventNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpUIEventNotificationInfo_UIEventData;
    guint32   i_TpUIEventNotificationInfo_UIEventData;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIEventNotificationInfo_ServiceCode");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIEventNotificationInfo_DataTypeIndication  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIEventInfoDataType,"Unknown Enum Value"));
    }

    u_octet4_loop_TpUIEventNotificationInfo_UIEventData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIEventNotificationInfo_UIEventData = %u",u_octet4_loop_TpUIEventNotificationInfo_UIEventData);
    }

    for (i_TpUIEventNotificationInfo_UIEventData=0; i_TpUIEventNotificationInfo_UIEventData < u_octet4_loop_TpUIEventNotificationInfo_UIEventData; i_TpUIEventNotificationInfo_UIEventData++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpUIEventNotificationInfo_UIEventData = %u",get_CDR_octet(tvb,offset));
        }

    }

}

/* Struct = IDL:org/csapi/ui/TpUIRecognitionProperty:1.0 */
static void
decode_org_csapi_ui_TpUIRecognitionProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIRecognitionProperty_PropertyName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIRecognitionProperty_PropertyValue");

}

/* Struct = IDL:org/csapi/ui/TpUIRecognitionCriteria:1.0 */
static void
decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpUIRecognitionCriteria_Properties;
    guint32   i_TpUIRecognitionCriteria_Properties;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIRecognitionCriteria_SpeakerID");

    u_octet4_loop_TpUIRecognitionCriteria_Properties = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUIRecognitionCriteria_Properties = %u",u_octet4_loop_TpUIRecognitionCriteria_Properties);
    }

    for (i_TpUIRecognitionCriteria_Properties=0; i_TpUIRecognitionCriteria_Properties < u_octet4_loop_TpUIRecognitionCriteria_Properties; i_TpUIRecognitionCriteria_Properties++) {

        /*  Begin struct "org_csapi_ui_TpUIRecognitionProperty"  */

        

        decode_org_csapi_ui_TpUIRecognitionProperty_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIRecognitionProperty"  */

    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIRecognitionCriteria_Grammar");

}

/* Struct = IDL:org/csapi/ui/TpUICollectCriteria:1.0 */
static void
decode_org_csapi_ui_TpUICollectCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_MinLength = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_MaxLength = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUICollectCriteria_EndSequence");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_StartTimeout = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_InterCharTimeout = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICollectCriteria_CollectMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUICollectMode,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_ui_TpUIRecognitionCriteria"  */

    

    decode_org_csapi_ui_TpUIRecognitionCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_ui_TpUIRecognitionCriteria"  */

}

/* Struct = IDL:org/csapi/ui/TpUIWordOverride:1.0 */
static void
decode_org_csapi_ui_TpUIWordOverride_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIWordOverride_Spelling");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIWordOverride_PronounceType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIPronounceType,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUIWordOverride_PronounceAs");

}

/* Struct = IDL:org/csapi/ui/TpUISynthesisInfoData:1.0 */
static void
decode_org_csapi_ui_TpUISynthesisInfoData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet;
    guint32   i_TpUISynthesisInfoData_WordOverrideSet;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUISynthesisInfoData_SpeakerGender  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisGender,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUISynthesisInfoData_SpeakerAge  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisAge,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUISynthesisInfoData_SpeakerRate  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisRate,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUISynthesisInfoData_SpeakerRange  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUISynthesisRange,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUISynthesisInfoData_TextData");

    u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUISynthesisInfoData_WordOverrideSet = %u",u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet);
    }

    for (i_TpUISynthesisInfoData_WordOverrideSet=0; i_TpUISynthesisInfoData_WordOverrideSet < u_octet4_loop_TpUISynthesisInfoData_WordOverrideSet; i_TpUISynthesisInfoData_WordOverrideSet++) {

        /*  Begin struct "org_csapi_ui_TpUIWordOverride"  */

        

        decode_org_csapi_ui_TpUIWordOverride_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUIWordOverride"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpCallError:1.0 */
static void
decode_org_csapi_cc_TpCallError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallError_ErrorTime");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallError_ErrorType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallErrorType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalErrorInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpCallAdditionalErrorInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallEndedReport:1.0 */
static void
decode_org_csapi_cc_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEndedReport_CallLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEndedReport_Cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallInfoReport:1.0 */
static void
decode_org_csapi_cc_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallInfoReport_CallInfoType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallInitiationStartTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallConnectedToResourceTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallConnectedToDestinationTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallEndTime");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallInfoReport_Cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallServiceCode:1.0 */
static void
decode_org_csapi_cc_TpCallServiceCode_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallServiceCode_CallServiceCodeType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallServiceCodeType,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallServiceCode_ServiceCodeValue");

}

/* Struct = IDL:org/csapi/cc/TpCallTreatment:1.0 */
static void
decode_org_csapi_cc_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallTreatment_CallTreatmentType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallTreatment_ReleaseCause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallChargePlan:1.0 */
static void
decode_org_csapi_cc_TpCallChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpCallChargePlan_TransparentCharge;
    guint32   i_TpCallChargePlan_TransparentCharge;
    guint32   u_octet4_loop_TpCallChargePlan_AdditionalInfo;
    guint32   i_TpCallChargePlan_AdditionalInfo;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallChargePlan_ChargeOrderType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallChargeOrderCategory,"Unknown Enum Value"));
    }

    u_octet4_loop_TpCallChargePlan_TransparentCharge = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallChargePlan_TransparentCharge = %u",u_octet4_loop_TpCallChargePlan_TransparentCharge);
    }

    for (i_TpCallChargePlan_TransparentCharge=0; i_TpCallChargePlan_TransparentCharge < u_octet4_loop_TpCallChargePlan_TransparentCharge; i_TpCallChargePlan_TransparentCharge++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCallChargePlan_TransparentCharge = %u",get_CDR_octet(tvb,offset));
        }

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallChargePlan_ChargePlan = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    u_octet4_loop_TpCallChargePlan_AdditionalInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallChargePlan_AdditionalInfo = %u",u_octet4_loop_TpCallChargePlan_AdditionalInfo);
    }

    for (i_TpCallChargePlan_AdditionalInfo=0; i_TpCallChargePlan_AdditionalInfo < u_octet4_loop_TpCallChargePlan_AdditionalInfo; i_TpCallChargePlan_AdditionalInfo++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCallChargePlan_AdditionalInfo = %u",get_CDR_octet(tvb,offset));
        }

    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallChargePlan_PartyToCharge  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyToChargeType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallPartyToChargeAdditionalInfo"  */

    
    decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpCallPartyToChargeAdditionalInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteria:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteria_CallEventName = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteria_CallNotificationType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallNotificationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteria_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventCriteriaResult:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

    

    decode_org_csapi_cc_gccs_TpCallEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_gccs_TpCallEventCriteria"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventCriteriaResult_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReleaseCause:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReleaseCause_Value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReleaseCause_Location = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReport:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReport_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallReport_CallEventTime");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReport_CallReportType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_gccs_TpCallAdditionalReportInfo"  */

    
    decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_gccs_TpCallAdditionalReportInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallReportRequest:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReportRequest_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallReportRequest_CallReportType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_gccs_TpCallAdditionalReportCriteria"  */

    
    decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_gccs_TpCallAdditionalReportCriteria"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEventInfo:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallEventInfo_CallAppInfo;
    guint32   i_TpCallEventInfo_CallAppInfo;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpCallEventInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallEventInfo_CallAppInfo = %u",u_octet4_loop_TpCallEventInfo_CallAppInfo);
    }

    for (i_TpCallEventInfo_CallAppInfo=0; i_TpCallEventInfo_CallAppInfo < u_octet4_loop_TpCallEventInfo_CallAppInfo; i_TpCallEventInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_gccs_TpCallAppInfo"  */

        
        decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_gccs_TpCallAppInfo"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_CallEventName = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_CallNotificationType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallNotificationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallEndedReport:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallEndedReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEndedReport_CallLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallInfoReport:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallInfoReport_CallInfoType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallInitiationStartTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallConnectedToResourceTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallConnectedToDestinationTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallInfoReport_CallEndTime");

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallTreatment:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallTreatment_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallTreatment_CallTreatmentType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    

    decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

    /*  Begin union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpCallAdditionalTreatmentInfo"  */

}

/* Struct = IDL:org/csapi/cc/gccs/TpCallIdentifier:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallIdentifier_CallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationScope:1.0 */
static void
decode_org_csapi_cc_TpCallNotificationScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationReportScope:1.0 */
static void
decode_org_csapi_cc_TpCallNotificationReportScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

}

/* Struct = IDL:org/csapi/cc/TpCallEventRequest:1.0 */
static void
decode_org_csapi_cc_TpCallEventRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventRequest_CallEventType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpAdditionalCallEventCriteria"  */

    
    decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpAdditionalCallEventCriteria"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventRequest_CallMonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationRequest:1.0 */
static void
decode_org_csapi_cc_TpCallNotificationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallNotificationRequest_CallEventsRequested;
    guint32   i_TpCallNotificationRequest_CallEventsRequested;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_TpCallNotificationScope"  */

    

    decode_org_csapi_cc_TpCallNotificationScope_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_TpCallNotificationScope"  */

    u_octet4_loop_TpCallNotificationRequest_CallEventsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallNotificationRequest_CallEventsRequested = %u",u_octet4_loop_TpCallNotificationRequest_CallEventsRequested);
    }

    for (i_TpCallNotificationRequest_CallEventsRequested=0; i_TpCallNotificationRequest_CallEventsRequested < u_octet4_loop_TpCallNotificationRequest_CallEventsRequested; i_TpCallNotificationRequest_CallEventsRequested++) {

        /*  Begin struct "org_csapi_cc_TpCallEventRequest"  */

        

        decode_org_csapi_cc_TpCallEventRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallEventRequest"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpNotificationRequested:1.0 */
static void
decode_org_csapi_cc_TpNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_TpCallNotificationRequest"  */

    

    decode_org_csapi_cc_TpCallNotificationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_TpCallNotificationRequest"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNotificationRequested_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallLegConnectionProperties:1.0 */
static void
decode_org_csapi_cc_TpCallLegConnectionProperties_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegConnectionProperties_AttachMechanism  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallLegAttachMechanism,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallEventInfo:1.0 */
static void
decode_org_csapi_cc_TpCallEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_CallEventType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_TpCallAdditionalEventInfo"  */

    
    decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_TpCallAdditionalEventInfo"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallEventInfo_CallMonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallEventInfo_CallEventTime");

}

/* Struct = IDL:org/csapi/cc/TpNotificationRequestedSetEntry:1.0 */
static void
decode_org_csapi_cc_TpNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet;
    guint32   i_TpNotificationRequestedSetEntry_NotificationRequestSet;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationRequestedSetEntry_NotificationRequestSet = %u",u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet);
    }

    for (i_TpNotificationRequestedSetEntry_NotificationRequestSet=0; i_TpNotificationRequestedSetEntry_NotificationRequestSet < u_octet4_loop_TpNotificationRequestedSetEntry_NotificationRequestSet; i_TpNotificationRequestedSetEntry_NotificationRequestSet++) {

        /*  Begin struct "org_csapi_cc_TpNotificationRequested"  */

        

        decode_org_csapi_cc_TpNotificationRequested_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpNotificationRequested"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpNotificationRequestedSetEntry_Final = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/cc/TpCarrier:1.0 */
static void
decode_org_csapi_cc_TpCarrier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCarrier_CarrierID;
    guint32   i_TpCarrier_CarrierID;
    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpCarrier_CarrierID = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCarrier_CarrierID = %u",u_octet4_loop_TpCarrier_CarrierID);
    }

    for (i_TpCarrier_CarrierID=0; i_TpCarrier_CarrierID < u_octet4_loop_TpCarrier_CarrierID; i_TpCarrier_CarrierID++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpCarrier_CarrierID = %u",get_CDR_octet(tvb,offset));
        }

    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCarrier_CarrierSelectionField  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCarrierSelectionField,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/TpCallNotificationInfo:1.0 */
static void
decode_org_csapi_cc_TpCallNotificationInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpCallNotificationInfo_CallAppInfo;
    guint32   i_TpCallNotificationInfo_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_TpCallNotificationReportScope"  */

    

    decode_org_csapi_cc_TpCallNotificationReportScope_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_TpCallNotificationReportScope"  */

    u_octet4_loop_TpCallNotificationInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallNotificationInfo_CallAppInfo = %u",u_octet4_loop_TpCallNotificationInfo_CallAppInfo);
    }

    for (i_TpCallNotificationInfo_CallAppInfo=0; i_TpCallNotificationInfo_CallAppInfo < u_octet4_loop_TpCallNotificationInfo_CallAppInfo; i_TpCallNotificationInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

    /*  Begin struct "org_csapi_cc_TpCallEventInfo"  */

    

    decode_org_csapi_cc_TpCallEventInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_TpCallEventInfo"  */

}

/* Struct = IDL:org/csapi/cc/TpCallLegInfoReport:1.0 */
static void
decode_org_csapi_cc_TpCallLegInfoReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpCallLegInfoReport_CallAppInfo;
    guint32   i_TpCallLegInfoReport_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegInfoReport_CallLegInfoType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegInfoReport_CallLegStartTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegInfoReport_CallLegConnectedToResourceTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegInfoReport_CallLegConnectedToAddressTime");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegInfoReport_CallLegEndTime");

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegInfoReport_CallLegReleaseCause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
    }

    u_octet4_loop_TpCallLegInfoReport_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpCallLegInfoReport_CallAppInfo = %u",u_octet4_loop_TpCallLegInfoReport_CallAppInfo);
    }

    for (i_TpCallLegInfoReport_CallAppInfo=0; i_TpCallLegInfoReport_CallAppInfo < u_octet4_loop_TpCallLegInfoReport_CallAppInfo; i_TpCallLegInfoReport_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

}

/* Struct = IDL:org/csapi/cc/TpCallLegProperty:1.0 */
static void
decode_org_csapi_cc_TpCallLegProperty_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegProperty_CallLegPropertyName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpCallLegProperty_CallLegPropertyValue");

}

/* Struct = IDL:org/csapi/cc/mpccs/TpMultiPartyCallIdentifier:1.0 */
static void
decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiPartyCallIdentifier_CallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mpccs/TpCallLegIdentifier:1.0 */
static void
decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLegIdentifier_CallLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mpccs/TpAppCallLegCallBack:1.0 */
static void
decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet;
    guint32   i_TpAppCallLegCallBack_AppCallLegSet;
    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAppCallLegCallBack_AppCallLegSet = %u",u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet);
    }

    for (i_TpAppCallLegCallBack_AppCallLegSet=0; i_TpAppCallLegCallBack_AppCallLegSet < u_octet4_loop_TpAppCallLegCallBack_AppCallLegSet; i_TpAppCallLegCallBack_AppCallLegSet++) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpCallSuperviseVolume:1.0 */
static void
decode_org_csapi_cc_mmccs_TpCallSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallSuperviseVolume_VolumeQuantity = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallSuperviseVolume_VolumeUnit = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStreamRequest:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStreamRequest_Direction  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDirection,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStreamRequest_MediaMonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStreamRequest_EventType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamEventType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaStream:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMediaStream_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStream_Direction  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDirection,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    
    decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStream_ChannelSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


}

/* Struct = IDL:org/csapi/cc/mmccs/TpNotificationMediaRequest:1.0 */
static void
decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested;
    guint32   i_TpNotificationMediaRequest_MediaStreamsRequested;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_TpCallNotificationScope"  */

    

    decode_org_csapi_cc_TpCallNotificationScope_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_TpCallNotificationScope"  */

    u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNotificationMediaRequest_MediaStreamsRequested = %u",u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested);
    }

    for (i_TpNotificationMediaRequest_MediaStreamsRequested=0; i_TpNotificationMediaRequest_MediaStreamsRequested < u_octet4_loop_TpNotificationMediaRequest_MediaStreamsRequested; i_TpNotificationMediaRequest_MediaStreamsRequested++) {

        /*  Begin struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

        

        decode_org_csapi_cc_mmccs_TpMediaStreamRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpMediaStreamRequest"  */

    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMediaNotificationRequested:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMediaNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

    

    decode_org_csapi_cc_mmccs_TpNotificationMediaRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cc_mmccs_TpNotificationMediaRequest"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaNotificationRequested_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallIdentifier:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMultiMediaCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaCallIdentifier_MMCallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpMultiMediaCallLegIdentifier:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMultiMediaCallLegIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaCallLegIdentifier_MMCallLegSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallLegCallBack:1.0 */
static void
decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet;
    guint32   i_TpAppMultiMediaCallLegCallBack_AppCallLegSet;
    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpAppMultiMediaCallLegCallBack_AppCallLegSet = %u",u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet);
    }

    for (i_TpAppMultiMediaCallLegCallBack_AppCallLegSet=0; i_TpAppMultiMediaCallLegCallBack_AppCallLegSet < u_octet4_loop_TpAppMultiMediaCallLegCallBack_AppCallLegSet; i_TpAppMultiMediaCallLegCallBack_AppCallLegSet++) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpMonoMediaConfPolicy:1.0 */
static void
decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMonoMediaConfPolicy_JoinAllowed = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpJoinEventInfo:1.0 */
static void
decode_org_csapi_cc_cccs_TpJoinEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpJoinEventInfo_CallAppInfo;
    guint32   i_TpJoinEventInfo_CallAppInfo;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpJoinEventInfo_CallAppInfo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpJoinEventInfo_CallAppInfo = %u",u_octet4_loop_TpJoinEventInfo_CallAppInfo);
    }

    for (i_TpJoinEventInfo_CallAppInfo=0; i_TpJoinEventInfo_CallAppInfo < u_octet4_loop_TpJoinEventInfo_CallAppInfo; i_TpJoinEventInfo_CallAppInfo++) {

        /*  Begin union "org_csapi_cc_TpCallAppInfo"  */

        
        decode_org_csapi_cc_TpCallAppInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cc_TpCallAppInfo"  */

    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchCriteria:1.0 */
static void
decode_org_csapi_cc_cccs_TpConfSearchCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpConfSearchCriteria_StartSearch");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpConfSearchCriteria_StopSearch");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchCriteria_RequestedResources = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchCriteria_RequestedDuration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfSearchResult:1.0 */
static void
decode_org_csapi_cc_cccs_TpConfSearchResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpConfSearchResult_MatchFound = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpConfSearchResult_ActualStartTime");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchResult_ActualResources = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfSearchResult_ActualDuration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpMultiMediaConfPolicy:1.0 */
static void
decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMultiMediaConfPolicy_JoinAllowed = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaConfPolicy_MediaAllowed = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMultiMediaConfPolicy_Chaired = %u",get_CDR_boolean(tvb,offset));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaConfPolicy_VideoHandling  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_cccs_TpVideoHandlingType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpResourceReservation:1.0 */
static void
decode_org_csapi_cc_cccs_TpResourceReservation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpResourceReservation_ReservationID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpConfCallIdentifier:1.0 */
static void
decode_org_csapi_cc_cccs_TpConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfCallIdentifier_ConfCallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cc/cccs/TpSubConfCallIdentifier:1.0 */
static void
decode_org_csapi_cc_cccs_TpSubConfCallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpSubConfCallIdentifier_SubConfCallSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/ui/TpUIIdentifier:1.0 */
static void
decode_org_csapi_ui_TpUIIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIIdentifier_UserInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/ui/TpUICallIdentifier:1.0 */
static void
decode_org_csapi_ui_TpUICallIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUICallIdentifier_UserInteractionSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationResponseTime:1.0 */
static void
decode_org_csapi_mm_TpLocationResponseTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationResponseTime_ResponseTime  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationResponseIndicator,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationResponseTime_TimerValue = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationTrigger:1.0 */
static void
decode_org_csapi_mm_TpLocationTrigger_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_Longitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_Latitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AreaSemiMajor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AreaSemiMinor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_AngleOfSemiMajor = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_Criterion  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationTriggerCriteria,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationTrigger_ReportingInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpLocationRequest:1.0 */
static void
decode_org_csapi_mm_TpLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationRequest_RequestedAccuracy = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    /*  Begin struct "org_csapi_mm_TpLocationResponseTime"  */

    

    decode_org_csapi_mm_TpLocationResponseTime_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpLocationResponseTime"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationRequest_AltitudeRequested = %u",get_CDR_boolean(tvb,offset));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationRequest_Type  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLocationRequest_Priority  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationPriority,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpLocationRequest_RequestedLocationMethod");

}

/* Struct = IDL:org/csapi/mm/TpGeographicalPosition:1.0 */
static void
decode_org_csapi_mm_TpGeographicalPosition_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_Longitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_Latitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_TypeOfUncertaintyShape  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpLocationUncertaintyShape,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyInnerSemiMajor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyOuterSemiMajor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyInnerSemiMinor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_UncertaintyOuterSemiMinor = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_AngleOfSemiMajor = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_SegmentStartAngle = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGeographicalPosition_SegmentEndAngle = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpMobilityStopAssignmentData:1.0 */
static void
decode_org_csapi_mm_TpMobilityStopAssignmentData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpMobilityStopAssignmentData_Users;
    guint32   i_TpMobilityStopAssignmentData_Users;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMobilityStopAssignmentData_AssignmentId = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMobilityStopAssignmentData_StopScope  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityStopScope,"Unknown Enum Value"));
    }

    u_octet4_loop_TpMobilityStopAssignmentData_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMobilityStopAssignmentData_Users = %u",u_octet4_loop_TpMobilityStopAssignmentData_Users);
    }

    for (i_TpMobilityStopAssignmentData_Users=0; i_TpMobilityStopAssignmentData_Users < u_octet4_loop_TpMobilityStopAssignmentData_Users; i_TpMobilityStopAssignmentData_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/mm/TpUlExtendedData:1.0 */
static void
decode_org_csapi_mm_TpUlExtendedData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUlExtendedData_TerminalType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUlExtendedData_AltitudePresent = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUlExtendedData_Altitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUlExtendedData_UncertaintyAltitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUlExtendedData_TimestampPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUlExtendedData_Timestamp");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUlExtendedData_UsedLocationMethod");

}

/* Struct = IDL:org/csapi/mm/TpUserLocation:1.0 */
static void
decode_org_csapi_mm_TpUserLocation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocation_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

}

/* Struct = IDL:org/csapi/mm/TpUserLocationExtended:1.0 */
static void
decode_org_csapi_mm_TpUserLocationExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpUserLocationExtended_Locations;
    guint32   i_TpUserLocationExtended_Locations;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationExtended_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    u_octet4_loop_TpUserLocationExtended_Locations = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpUserLocationExtended_Locations = %u",u_octet4_loop_TpUserLocationExtended_Locations);
    }

    for (i_TpUserLocationExtended_Locations=0; i_TpUserLocationExtended_Locations < u_octet4_loop_TpUserLocationExtended_Locations; i_TpUserLocationExtended_Locations++) {

        /*  Begin struct "org_csapi_mm_TpUlExtendedData"  */

        

        decode_org_csapi_mm_TpUlExtendedData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpUlExtendedData"  */

    }

}

/* Struct = IDL:org/csapi/mm/TpLocationTriggerCamel:1.0 */
static void
decode_org_csapi_mm_TpLocationTriggerCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationTriggerCamel_UpdateInsideVlr = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpLocationTriggerCamel_UpdateOutsideVlr = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mm/TpUserLocationCamel:1.0 */
static void
decode_org_csapi_mm_TpUserLocationCamel_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationCamel_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_GeographicalPositionPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_TimestampPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationCamel_Timestamp");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_VlrNumberPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_LocationNumberPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationCamel_CellIdOrLaiPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationCamel_CellIdOrLai");

}

/* Struct = IDL:org/csapi/mm/TpUserLocationEmergencyRequest:1.0 */
static void
decode_org_csapi_mm_TpUserLocationEmergencyRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_UserAddressPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_NaEsrdPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergencyRequest_NaEsrd");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_NaEsrkPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergencyRequest_NaEsrk");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergencyRequest_ImeiPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergencyRequest_Imei");

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

}

/* Struct = IDL:org/csapi/mm/TpUserLocationEmergency:1.0 */
static void
decode_org_csapi_mm_TpUserLocationEmergency_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_UserIdPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_NaEsrdPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergency_NaEsrd");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_NaEsrkPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergency_NaEsrk");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_ImeiPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergency_Imei");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_TriggeringEvent  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserLocationEmergencyTrigger,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_GeographicalPositionPresent = %u",get_CDR_boolean(tvb,offset));
    }

    /*  Begin struct "org_csapi_mm_TpGeographicalPosition"  */

    

    decode_org_csapi_mm_TpGeographicalPosition_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpGeographicalPosition"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_AltitudePresent = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_Altitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserLocationEmergency_UncertaintyAltitude = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserLocationEmergency_TimestampPresent = %u",get_CDR_boolean(tvb,offset));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergency_Timestamp");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserLocationEmergency_UsedLocationMethod");

}

/* Struct = IDL:org/csapi/mm/TpUserStatus:1.0 */
static void
decode_org_csapi_mm_TpUserStatus_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatus_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatus_Status  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserStatusIndicator,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatus_TerminalType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequest:1.0 */
static void
decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredStatusRequest_Users;
    guint32   i_TpTriggeredStatusRequest_Users;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpTriggeredStatusRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredStatusRequest_Users = %u",u_octet4_loop_TpTriggeredStatusRequest_Users);
    }

    for (i_TpTriggeredStatusRequest_Users=0; i_TpTriggeredStatusRequest_Users < u_octet4_loop_TpTriggeredStatusRequest_Users; i_TpTriggeredStatusRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTriggeredStatusRequest_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredStatusRequestSetEntry:1.0 */
static void
decode_org_csapi_mm_TpTriggeredStatusRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests;
    guint32   i_TpTriggeredStatusRequestSetEntry_Requests;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredStatusRequestSetEntry_Requests = %u",u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests);
    }

    for (i_TpTriggeredStatusRequestSetEntry_Requests=0; i_TpTriggeredStatusRequestSetEntry_Requests < u_octet4_loop_TpTriggeredStatusRequestSetEntry_Requests; i_TpTriggeredStatusRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpTriggeredStatusRequest"  */

        

        decode_org_csapi_mm_TpTriggeredStatusRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpTriggeredStatusRequest"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTriggeredStatusRequestSetEntry_Final = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequest:1.0 */
static void
decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPeriodicLocationRequest_Users;
    guint32   i_TpPeriodicLocationRequest_Users;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPeriodicLocationRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPeriodicLocationRequest_Users = %u",u_octet4_loop_TpPeriodicLocationRequest_Users);
    }

    for (i_TpPeriodicLocationRequest_Users=0; i_TpPeriodicLocationRequest_Users < u_octet4_loop_TpPeriodicLocationRequest_Users; i_TpPeriodicLocationRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPeriodicLocationRequest_ReportingInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPeriodicLocationRequest_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpPeriodicLocationRequestSetEntry:1.0 */
static void
decode_org_csapi_mm_TpPeriodicLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests;
    guint32   i_TpPeriodicLocationRequestSetEntry_Requests;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPeriodicLocationRequestSetEntry_Requests = %u",u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests);
    }

    for (i_TpPeriodicLocationRequestSetEntry_Requests=0; i_TpPeriodicLocationRequestSetEntry_Requests < u_octet4_loop_TpPeriodicLocationRequestSetEntry_Requests; i_TpPeriodicLocationRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpPeriodicLocationRequest"  */

        

        decode_org_csapi_mm_TpPeriodicLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpPeriodicLocationRequest"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPeriodicLocationRequestSetEntry_Final = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequest:1.0 */
static void
decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredLocationRequest_Users;
    guint32   i_TpTriggeredLocationRequest_Users;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpTriggeredLocationRequest_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredLocationRequest_Users = %u",u_octet4_loop_TpTriggeredLocationRequest_Users);
    }

    for (i_TpTriggeredLocationRequest_Users=0; i_TpTriggeredLocationRequest_Users < u_octet4_loop_TpTriggeredLocationRequest_Users; i_TpTriggeredLocationRequest_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    /*  Begin struct "org_csapi_mm_TpLocationRequest"  */

    

    decode_org_csapi_mm_TpLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpLocationRequest"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTriggeredLocationRequest_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mm/TpTriggeredLocationRequestSetEntry:1.0 */
static void
decode_org_csapi_mm_TpTriggeredLocationRequestSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests;
    guint32   i_TpTriggeredLocationRequestSetEntry_Requests;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTriggeredLocationRequestSetEntry_Requests = %u",u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests);
    }

    for (i_TpTriggeredLocationRequestSetEntry_Requests=0; i_TpTriggeredLocationRequestSetEntry_Requests < u_octet4_loop_TpTriggeredLocationRequestSetEntry_Requests; i_TpTriggeredLocationRequestSetEntry_Requests++) {

        /*  Begin struct "org_csapi_mm_TpTriggeredLocationRequest"  */

        

        decode_org_csapi_mm_TpTriggeredLocationRequest_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mm_TpTriggeredLocationRequest"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTriggeredLocationRequestSetEntry_Final = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mm/TpUserStatusIndicatorExtended:1.0 */
static void
decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatusIndicatorExtended_UserStatusIndicator  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpUserStatusIndicator,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpUserStatusIndicatorExtended_PDPContextActive = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mm/TpUserInfo:1.0 */
static void
decode_org_csapi_mm_TpUserInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserInfo_UserName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserInfo_Password");

}

/* Struct = IDL:org/csapi/mm/TpNetworkStatusIndicator:1.0 */
static void
decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNetworkStatusIndicator_CountryCode");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNetworkStatusIndicator_MobileNetworkCode");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNetworkStatusIndicator_AccessTechnology  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpAccessTechnology,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNetworkStatusIndicator_RoamingStatus  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpRoamingStatus,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mm/TpUserStatusExtended:1.0 */
static void
decode_org_csapi_mm_TpUserStatusExtended_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserStatusExtended_UserID");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatusExtended_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpMobilityError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpUserStatusIndicatorExtended"  */

    

    decode_org_csapi_mm_TpUserStatusIndicatorExtended_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpUserStatusIndicatorExtended"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatusExtended_TerminalType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpTerminalType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUserStatusExtended_AuthenticationStatus  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpAuthStatusIndicator,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_mm_TpNetworkStatusIndicator"  */

    

    decode_org_csapi_mm_TpNetworkStatusIndicator_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpNetworkStatusIndicator"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserStatusExtended_UserIPAddress");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserStatusExtended_UserMSISDN");

    /*  Begin struct "org_csapi_mm_TpUserInfo"  */

    

    decode_org_csapi_mm_TpUserInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mm_TpUserInfo"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserStatusExtended_UserConnectionID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpUserStatusExtended_AccessPointName");

}

/* Struct = IDL:org/csapi/mm/TpBindingNotificationCriteria:1.0 */
static void
decode_org_csapi_mm_TpBindingNotificationCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet;
    guint32   i_TpBindingNotificationCriteria_ContactAddressSet;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBindingNotificationCriteria_NotificationCriteriaType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBindingNotificationCriteria_ContactAddressSet = %u",u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet);
    }

    for (i_TpBindingNotificationCriteria_ContactAddressSet=0; i_TpBindingNotificationCriteria_ContactAddressSet < u_octet4_loop_TpBindingNotificationCriteria_ContactAddressSet; i_TpBindingNotificationCriteria_ContactAddressSet++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilities:1.0 */
static void
decode_org_csapi_termcap_TpTerminalCapabilities_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTerminalCapabilities_TerminalCapabilities");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpTerminalCapabilities_StatusCode = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/termcap/TpTerminalCapabilityScope:1.0 */
static void
decode_org_csapi_termcap_TpTerminalCapabilityScope_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTerminalCapabilityScope_ScopeType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_termcap_TpTerminalCapabilityScopeType,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTerminalCapabilityScope_Scope");

}

/* Struct = IDL:org/csapi/dsc/TpChargePerVolume:1.0 */
static void
decode_org_csapi_dsc_TpChargePerVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_InitialCharge = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_CurrentChargePerKilobyte = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargePerVolume_NextChargePerKilobyte = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionChargePlan:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionChargePlan_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin union "org_csapi_dsc_TpDataSessionChargeOrder"  */

    
    decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_dsc_TpDataSessionChargeOrder"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDataSessionChargePlan_Currency");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDataSessionChargePlan_AdditionalInfo");

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionError:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDataSessionError_ErrorTime");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionError_ErrorType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionErrorType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_dsc_TpDataSessionAdditionalErrorInfo"  */

    
    decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_dsc_TpDataSessionAdditionalErrorInfo"  */

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteria:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventCriteria_DataSessionEventName = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventCriteria_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventInfo:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventInfo_DataSessionEventName = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventInfo_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventInfo_QoSClass  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpDataSessionQosClass,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReleaseCause:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReleaseCause_Value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReleaseCause_Location = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReport:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReport_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDataSessionReport_DataSessionEventTime");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReport_DataSessionReportType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_dsc_TpDataSessionAdditionalReportInfo"  */

    
    decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_dsc_TpDataSessionAdditionalReportInfo"  */

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionReportRequest:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionReportRequest_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReportRequest_MonitorMode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionMonitorMode,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionReportRequest_DataSessionReportType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionSuperviseVolume:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionSuperviseVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionSuperviseVolume_VolumeQuantity = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionSuperviseVolume_VolumeUnit = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionEventCriteriaResult:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

    

    decode_org_csapi_dsc_TpDataSessionEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_dsc_TpDataSessionEventCriteria"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionEventCriteriaResult_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/dsc/TpDataSessionIdentifier:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionIdentifier_DataSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedInfo:1.0 */
static void
decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpGMSNewMessageArrivedInfo_FolderID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpGMSNewMessageArrivedInfo_MessageID");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpGMSNewMessageArrivedInfo_NumberOfProperties = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/gms/TpGMSNewMessageArrivedCriteria:1.0 */
static void
decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpGMSNewMessageArrivedCriteria_AuthenticationInfo");

}

/* Struct = IDL:org/csapi/gms/TpMailboxIdentifier:1.0 */
static void
decode_org_csapi_gms_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxIdentifier_SessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/gms/TpMailboxFolderIdentifier:1.0 */
static void
decode_org_csapi_gms_TpMailboxFolderIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxFolderIdentifier_SessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimePeriod:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagTimePeriod_duration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagTimeOfDay:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagTimeOfDay_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagTimeOfDay_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagTimeOfDay_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagTimeOfDay_value");

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagString:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagString_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagString_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagString_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagString_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagString_value");

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagMonth:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagMonth_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagMonth_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagMonth_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagMonth_value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagInt:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagInt_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagInt_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagInt_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagInt_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagInt_value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDir:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagDir_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDir_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDir_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDir_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDir_value  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTrafficDirection,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDayOfWeek:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDayOfWeek_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDayOfWeek_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDayOfWeek_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDayOfWeek_value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagDateTime:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDateTime_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDateTime_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagDateTime_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagDateTime_value");

}

/* Struct = IDL:org/csapi/cm/TpLossDescriptor:1.0 */
static void
decode_org_csapi_cm_TpLossDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpLoadDescriptor:1.0 */
static void
decode_org_csapi_cm_TpLoadDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpJitterDescriptor:1.0 */
static void
decode_org_csapi_cm_TpJitterDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpEndpoint:1.0 */
static void
decode_org_csapi_cm_TpEndpoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpEndpoint_type  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpSiteOrSap,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpEndpoint_id");

}

/* Struct = IDL:org/csapi/cm/TpDelayDescriptor:1.0 */
static void
decode_org_csapi_cm_TpDelayDescriptor_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagInt"  */

    

    decode_org_csapi_cm_TpNameDescrpTagInt_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagInt"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpNameDescrpTagExcessLoadAction:1.0 */
static void
decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagExcessLoadAction_name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNameDescrpTagExcessLoadAction_description");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagExcessLoadAction_tag  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpTagValue,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpNameDescrpTagExcessLoadAction_value  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpAction,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/cm/TpValidityInfo:1.0 */
static void
decode_org_csapi_cm_TpValidityInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDateTime"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDateTime_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDateTime"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimeOfDay"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimeOfDay_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimeOfDay"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    

    decode_org_csapi_cm_TpNameDescrpTagTimePeriod_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagTimePeriod"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDayOfWeek"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDayOfWeek_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDayOfWeek"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagMonth"  */

    

    decode_org_csapi_cm_TpNameDescrpTagMonth_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagMonth"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpProvisionedQoSInfo:1.0 */
static void
decode_org_csapi_cm_TpProvisionedQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpDelayDescriptor"  */

    

    decode_org_csapi_cm_TpDelayDescriptor_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpDelayDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpLossDescriptor"  */

    

    decode_org_csapi_cm_TpLossDescriptor_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpLossDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpJitterDescriptor"  */

    

    decode_org_csapi_cm_TpJitterDescriptor_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpJitterDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagExcessLoadAction"  */

    

    decode_org_csapi_cm_TpNameDescrpTagExcessLoadAction_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagExcessLoadAction"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpPipeQoSInfo:1.0 */
static void
decode_org_csapi_cm_TpPipeQoSInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagDir"  */

    

    decode_org_csapi_cm_TpNameDescrpTagDir_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagDir"  */

    /*  Begin struct "org_csapi_cm_TpEndpoint"  */

    

    decode_org_csapi_cm_TpEndpoint_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpEndpoint"  */

    /*  Begin struct "org_csapi_cm_TpEndpoint"  */

    

    decode_org_csapi_cm_TpEndpoint_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpEndpoint"  */

    /*  Begin struct "org_csapi_cm_TpLoadDescriptor"  */

    

    decode_org_csapi_cm_TpLoadDescriptor_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpLoadDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpLoadDescriptor"  */

    

    decode_org_csapi_cm_TpLoadDescriptor_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpLoadDescriptor"  */

    /*  Begin struct "org_csapi_cm_TpNameDescrpTagString"  */

    

    decode_org_csapi_cm_TpNameDescrpTagString_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cm_TpNameDescrpTagString"  */

}

/* Struct = IDL:org/csapi/cm/TpDsCodepoint:1.0 */
static void
decode_org_csapi_cm_TpDsCodepoint_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDsCodepoint_match");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpDsCodepoint_mask");

}

/* Struct = IDL:org/csapi/cm/TpIPSubnet:1.0 */
static void
decode_org_csapi_cm_TpIPSubnet_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpIPSubnet_subnetNumber");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpIPSubnet_subnetMask");

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpIPSubnet_addressType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpIPv4AddType,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpIPSubnet_IPVersionSupport  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cm_TpIPVersion,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/am/TpBalanceInfo:1.0 */
static void
decode_org_csapi_am_TpBalanceInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBalanceInfo_Currency");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_ValuePartA = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_ValuePartB = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceInfo_Exponent = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBalanceInfo_AdditionalInfo");

}

/* Struct = IDL:org/csapi/am/TpChargingEventInfo:1.0 */
static void
decode_org_csapi_am_TpChargingEventInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingEventInfo_ChargingEventName  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpChargingEventName,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpChargingEventInfo_ChargingEventTime");

}

/* Struct = IDL:org/csapi/am/TpBalance:1.0 */
static void
decode_org_csapi_am_TpBalance_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalance_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
    }

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

}

/* Struct = IDL:org/csapi/am/TpTransactionHistory:1.0 */
static void
decode_org_csapi_am_TpTransactionHistory_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpTransactionHistory_TransactionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTransactionHistory_TimeStamp");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpTransactionHistory_AdditionalInfo");

}

/* Struct = IDL:org/csapi/am/TpChargingEventCriteria:1.0 */
static void
decode_org_csapi_am_TpChargingEventCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpChargingEventCriteria_ChargingEvents;
    guint32   i_TpChargingEventCriteria_ChargingEvents;
    guint32   u_octet4;
    guint32   u_octet4_loop_TpChargingEventCriteria_Users;
    guint32   i_TpChargingEventCriteria_Users;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpChargingEventCriteria_ChargingEvents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteria_ChargingEvents = %u",u_octet4_loop_TpChargingEventCriteria_ChargingEvents);
    }

    for (i_TpChargingEventCriteria_ChargingEvents=0; i_TpChargingEventCriteria_ChargingEvents < u_octet4_loop_TpChargingEventCriteria_ChargingEvents; i_TpChargingEventCriteria_ChargingEvents++) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingEventCriteria_ChargingEvents  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpChargingEventName,"Unknown Enum Value"));
        }

    }

    u_octet4_loop_TpChargingEventCriteria_Users = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpChargingEventCriteria_Users = %u",u_octet4_loop_TpChargingEventCriteria_Users);
    }

    for (i_TpChargingEventCriteria_Users=0; i_TpChargingEventCriteria_Users < u_octet4_loop_TpChargingEventCriteria_Users; i_TpChargingEventCriteria_Users++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/am/TpChargingEventCriteriaResult:1.0 */
static void
decode_org_csapi_am_TpChargingEventCriteriaResult_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_am_TpChargingEventCriteria"  */

    

    decode_org_csapi_am_TpChargingEventCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_am_TpChargingEventCriteria"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingEventCriteriaResult_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/am/TpBalanceExpiryDate:1.0 */
static void
decode_org_csapi_am_TpBalanceExpiryDate_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBalanceExpiryDate_StatusCode  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_am_TpBalanceQueryError,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBalanceExpiryDate_ExpiryDate");

}

/* Struct = IDL:org/csapi/am/TpVoucher:1.0 */
static void
decode_org_csapi_am_TpVoucher_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpVoucher_VoucherID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    /*  Begin struct "org_csapi_am_TpBalanceInfo"  */

    

    decode_org_csapi_am_TpBalanceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_am_TpBalanceInfo"  */

}

/* Struct = IDL:org/csapi/cs/TpMerchantAccountID:1.0 */
static void
decode_org_csapi_cs_TpMerchantAccountID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpMerchantAccountID_MerchantID");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMerchantAccountID_AccountID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cs/TpCorrelationID:1.0 */
static void
decode_org_csapi_cs_TpCorrelationID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCorrelationID_CorrelationID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCorrelationID_CorrelationType = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cs/TpAmount:1.0 */
static void
decode_org_csapi_cs_TpAmount_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAmount_Number = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAmount_Exponent = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cs/TpChargingPrice:1.0 */
static void
decode_org_csapi_cs_TpChargingPrice_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpChargingPrice_Currency");

    /*  Begin struct "org_csapi_cs_TpAmount"  */

    

    decode_org_csapi_cs_TpAmount_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cs_TpAmount"  */

}

/* Struct = IDL:org/csapi/cs/TpVolume:1.0 */
static void
decode_org_csapi_cs_TpVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cs_TpAmount"  */

    

    decode_org_csapi_cs_TpAmount_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cs_TpAmount"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpVolume_Unit = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cs/TpChargingSessionID:1.0 */
static void
decode_org_csapi_cs_TpChargingSessionID_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingSessionID_ChargingSessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingSessionID_RequestNumberFirstRequest = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/cs/TpPriceVolume:1.0 */
static void
decode_org_csapi_cs_TpPriceVolume_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_cs_TpChargingPrice"  */

    

    decode_org_csapi_cs_TpChargingPrice_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cs_TpChargingPrice"  */

    /*  Begin struct "org_csapi_cs_TpVolume"  */

    

    decode_org_csapi_cs_TpVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_cs_TpVolume"  */

}

/* Struct = IDL:org/csapi/cs/TpApplicationDescription:1.0 */
static void
decode_org_csapi_cs_TpApplicationDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpApplicationDescription_AppInformation;
    guint32   i_TpApplicationDescription_AppInformation;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpApplicationDescription_Text");

    u_octet4_loop_TpApplicationDescription_AppInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpApplicationDescription_AppInformation = %u",u_octet4_loop_TpApplicationDescription_AppInformation);
    }

    for (i_TpApplicationDescription_AppInformation=0; i_TpApplicationDescription_AppInformation < u_octet4_loop_TpApplicationDescription_AppInformation; i_TpApplicationDescription_AppInformation++) {

        /*  Begin union "org_csapi_cs_TpAppInformation"  */

        
        decode_org_csapi_cs_TpAppInformation_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_cs_TpAppInformation"  */

    }

}

/* Struct = IDL:org/csapi/cs/TpChargingParameter:1.0 */
static void
decode_org_csapi_cs_TpChargingParameter_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingParameter_ParameterID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    /*  Begin union "org_csapi_cs_TpChargingParameterValue"  */

    
    decode_org_csapi_cs_TpChargingParameterValue_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_cs_TpChargingParameterValue"  */

}

/* Struct = IDL:org/csapi/policy/TpPolicyEvent:1.0 */
static void
decode_org_csapi_policy_TpPolicyEvent_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyEvent_Attributes;
    guint32   i_TpPolicyEvent_Attributes;
    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyEvent_EventID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyEvent_TimeGenerated");

    u_octet4_loop_TpPolicyEvent_Attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyEvent_Attributes = %u",u_octet4_loop_TpPolicyEvent_Attributes);
    }

    for (i_TpPolicyEvent_Attributes=0; i_TpPolicyEvent_Attributes < u_octet4_loop_TpPolicyEvent_Attributes; i_TpPolicyEvent_Attributes++) {

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAttribute"  */

    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyEvent_EventDefinitionName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyEvent_EventDomainName");

}

/* Struct = IDL:org/csapi/policy/TpPolicyNameValue:1.0 */
static void
decode_org_csapi_policy_TpPolicyNameValue_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyNameValue_Name");

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyRecordType:1.0 */
static void
decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyRecordType_Names;
    guint32   i_TpPolicyRecordType_Names;
    guint32   u_octet4_loop_TpPolicyRecordType_Types;
    guint32   i_TpPolicyRecordType_Types;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPolicyRecordType_Names = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyRecordType_Names = %u",u_octet4_loop_TpPolicyRecordType_Names);
    }

    for (i_TpPolicyRecordType_Names=0; i_TpPolicyRecordType_Names < u_octet4_loop_TpPolicyRecordType_Names; i_TpPolicyRecordType_Names++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyRecordType_Names");

    }

    u_octet4_loop_TpPolicyRecordType_Types = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyRecordType_Types = %u",u_octet4_loop_TpPolicyRecordType_Types);
    }

    for (i_TpPolicyRecordType_Types=0; i_TpPolicyRecordType_Types < u_octet4_loop_TpPolicyRecordType_Types; i_TpPolicyRecordType_Types++) {

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_policy_TpPolicyType"  */

    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyType/TpPolicyListType:1.0 */
static void
decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPolicyListType_ElementType;
    guint32   i_TpPolicyListType_ElementType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPolicyListType_ElementType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPolicyListType_ElementType = %u",u_octet4_loop_TpPolicyListType_ElementType);
    }

    for (i_TpPolicyListType_ElementType=0; i_TpPolicyListType_ElementType < u_octet4_loop_TpPolicyListType_ElementType; i_TpPolicyListType_ElementType++) {

        /*  Begin union "org_csapi_policy_TpPolicyType"  */

        
        decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_policy_TpPolicyType"  */

    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyVar:1.0 */
static void
decode_org_csapi_policy_TpPolicyVar_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPolicyVar_VarName");

    /*  Begin union "org_csapi_policy_TpPolicyType"  */

    
    decode_org_csapi_policy_TpPolicyType_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_policy_TpPolicyType"  */

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/policy/TpPolicyConditionListElement:1.0 */
static void
decode_org_csapi_policy_TpPolicyConditionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyConditionListElement_GroupNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPolicyConditionListElement_Negated = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/policy/TpPolicyActionListElement:1.0 */
static void
decode_org_csapi_policy_TpPolicyActionListElement_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyActionListElement_SequenceNumber = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAttributeDef:1.0 */
static void
decode_org_csapi_pam_TpPAMAttributeDef_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAttributeDef_Name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAttributeDef_Type");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMAttributeDef_IsStatic = %u",get_CDR_boolean(tvb,offset));
    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpPAMAttributeDef_IsRevertOnExpiration = %u",get_CDR_boolean(tvb,offset));
    }

    get_CDR_any(tvb,tree,offset,stream_is_big_endian, boundary, header);

}

/* Struct = IDL:org/csapi/pam/TpPAMAttribute:1.0 */
static void
decode_org_csapi_pam_TpPAMAttribute_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAttribute_AttributeName");

    /*  Begin union "org_csapi_TpAttributeValue"  */

    
    decode_org_csapi_TpAttributeValue_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_TpAttributeValue"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAttribute_ExpiresIn = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMPresenceData:1.0 */
static void
decode_org_csapi_pam_TpPAMPresenceData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_Name");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_subscriberStatus");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_networkStatus");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_communicationMeans");

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_subscriberProvidedLocation");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_networkProvidedLocation");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMPresenceData_Priority = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMPresenceData_otherInfo");

}

/* Struct = IDL:org/csapi/pam/TpPAMAvailabilityProfile:1.0 */
static void
decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAvailabilityProfile_PrivacyCode");

    /*  Begin struct "org_csapi_pam_TpPAMPresenceData"  */

    

    decode_org_csapi_pam_TpPAMPresenceData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_pam_TpPAMPresenceData"  */

}

/* Struct = IDL:org/csapi/pam/TpPAMCommunicationContext:1.0 */
static void
decode_org_csapi_pam_TpPAMCommunicationContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCommunicationContext_CommunicationCapability");

}

/* Struct = IDL:org/csapi/pam/TpPAMContext:1.0 */
static void
decode_org_csapi_pam_TpPAMContext_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMContext_AskerData;
    guint32   i_TpPAMContext_AskerData;
    
    /* Operation specific Variable declarations End */

    /*  Begin union "org_csapi_pam_TpPAMContextData"  */

    
    decode_org_csapi_pam_TpPAMContextData_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_pam_TpPAMContextData"  */

    u_octet4_loop_TpPAMContext_AskerData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMContext_AskerData = %u",u_octet4_loop_TpPAMContext_AskerData);
    }

    for (i_TpPAMContext_AskerData=0; i_TpPAMContext_AskerData < u_octet4_loop_TpPAMContext_AskerData; i_TpPAMContext_AskerData++) {

        /*  Begin struct "org_csapi_TpAttribute"  */

        

        decode_org_csapi_TpAttribute_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAttribute"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAccessControlData:1.0 */
static void
decode_org_csapi_pam_TpPAMAccessControlData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpPAMAccessControlData_AllowList;
    guint32   i_TpPAMAccessControlData_AllowList;
    guint32   u_octet4_loop_TpPAMAccessControlData_DenyList;
    guint32   i_TpPAMAccessControlData_DenyList;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMAccessControlData_DefaultPolicy  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMACLDefault,"Unknown Enum Value"));
    }

    u_octet4_loop_TpPAMAccessControlData_AllowList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAccessControlData_AllowList = %u",u_octet4_loop_TpPAMAccessControlData_AllowList);
    }

    for (i_TpPAMAccessControlData_AllowList=0; i_TpPAMAccessControlData_AllowList < u_octet4_loop_TpPAMAccessControlData_AllowList; i_TpPAMAccessControlData_AllowList++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAccessControlData_AllowList");

    }

    u_octet4_loop_TpPAMAccessControlData_DenyList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAccessControlData_DenyList = %u",u_octet4_loop_TpPAMAccessControlData_DenyList);
    }

    for (i_TpPAMAccessControlData_DenyList=0; i_TpPAMAccessControlData_DenyList < u_octet4_loop_TpPAMAccessControlData_DenyList; i_TpPAMAccessControlData_DenyList++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAccessControlData_DenyList");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMICEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMICEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMICEventData_IdentityType;
    guint32   i_TpPAMICEventData_IdentityType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMICEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMICEventData_IdentityType = %u",u_octet4_loop_TpPAMICEventData_IdentityType);
    }

    for (i_TpPAMICEventData_IdentityType=0; i_TpPAMICEventData_IdentityType < u_octet4_loop_TpPAMICEventData_IdentityType; i_TpPAMICEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMICEventData_IdentityType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMICNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMICNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMICNotificationData_Identities;
    guint32   i_TpPAMICNotificationData_Identities;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMICNotificationData_Identities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMICNotificationData_Identities = %u",u_octet4_loop_TpPAMICNotificationData_Identities);
    }

    for (i_TpPAMICNotificationData_Identities=0; i_TpPAMICNotificationData_Identities < u_octet4_loop_TpPAMICNotificationData_Identities; i_TpPAMICNotificationData_Identities++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMICNotificationData_Identities");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIDEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMIDEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIDEventData_IdentityName;
    guint32   i_TpPAMIDEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMIDEventData_IdentityType;
    guint32   i_TpPAMIDEventData_IdentityType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMIDEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDEventData_IdentityName = %u",u_octet4_loop_TpPAMIDEventData_IdentityName);
    }

    for (i_TpPAMIDEventData_IdentityName=0; i_TpPAMIDEventData_IdentityName < u_octet4_loop_TpPAMIDEventData_IdentityName; i_TpPAMIDEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIDEventData_IdentityName");

    }

    u_octet4_loop_TpPAMIDEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDEventData_IdentityType = %u",u_octet4_loop_TpPAMIDEventData_IdentityType);
    }

    for (i_TpPAMIDEventData_IdentityType=0; i_TpPAMIDEventData_IdentityType < u_octet4_loop_TpPAMIDEventData_IdentityType; i_TpPAMIDEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIDEventData_IdentityType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIDNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMIDNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIDNotificationData_Identities;
    guint32   i_TpPAMIDNotificationData_Identities;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMIDNotificationData_Identities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIDNotificationData_Identities = %u",u_octet4_loop_TpPAMIDNotificationData_Identities);
    }

    for (i_TpPAMIDNotificationData_Identities=0; i_TpPAMIDNotificationData_Identities < u_octet4_loop_TpPAMIDNotificationData_Identities; i_TpPAMIDNotificationData_Identities++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIDNotificationData_Identities");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMGMCEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMGMCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMGMCEventData_GroupName;
    guint32   i_TpPAMGMCEventData_GroupName;
    guint32   u_octet4_loop_TpPAMGMCEventData_GroupType;
    guint32   i_TpPAMGMCEventData_GroupType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMGMCEventData_GroupName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCEventData_GroupName = %u",u_octet4_loop_TpPAMGMCEventData_GroupName);
    }

    for (i_TpPAMGMCEventData_GroupName=0; i_TpPAMGMCEventData_GroupName < u_octet4_loop_TpPAMGMCEventData_GroupName; i_TpPAMGMCEventData_GroupName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMGMCEventData_GroupName");

    }

    u_octet4_loop_TpPAMGMCEventData_GroupType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCEventData_GroupType = %u",u_octet4_loop_TpPAMGMCEventData_GroupType);
    }

    for (i_TpPAMGMCEventData_GroupType=0; i_TpPAMGMCEventData_GroupType < u_octet4_loop_TpPAMGMCEventData_GroupType; i_TpPAMGMCEventData_GroupType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMGMCEventData_GroupType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMGMCNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMGMCNotificationData_Groups;
    guint32   i_TpPAMGMCNotificationData_Groups;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMGMCNotificationData_Groups = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMGMCNotificationData_Groups = %u",u_octet4_loop_TpPAMGMCNotificationData_Groups);
    }

    for (i_TpPAMGMCNotificationData_Groups=0; i_TpPAMGMCNotificationData_Groups < u_octet4_loop_TpPAMGMCNotificationData_Groups; i_TpPAMGMCNotificationData_Groups++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMGMCNotificationData_Groups");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMACEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACEventData_AgentType;
    guint32   i_TpPAMACEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMACEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACEventData_AgentType = %u",u_octet4_loop_TpPAMACEventData_AgentType);
    }

    for (i_TpPAMACEventData_AgentType=0; i_TpPAMACEventData_AgentType < u_octet4_loop_TpPAMACEventData_AgentType; i_TpPAMACEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACEventData_AgentType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMACNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACNotificationData_Agents;
    guint32   i_TpPAMACNotificationData_Agents;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMACNotificationData_Agents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACNotificationData_Agents = %u",u_octet4_loop_TpPAMACNotificationData_Agents);
    }

    for (i_TpPAMACNotificationData_Agents=0; i_TpPAMACNotificationData_Agents < u_octet4_loop_TpPAMACNotificationData_Agents; i_TpPAMACNotificationData_Agents++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACNotificationData_Agents");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMADEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMADEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMADEventData_AgentName;
    guint32   i_TpPAMADEventData_AgentName;
    guint32   u_octet4_loop_TpPAMADEventData_AgentType;
    guint32   i_TpPAMADEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMADEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADEventData_AgentName = %u",u_octet4_loop_TpPAMADEventData_AgentName);
    }

    for (i_TpPAMADEventData_AgentName=0; i_TpPAMADEventData_AgentName < u_octet4_loop_TpPAMADEventData_AgentName; i_TpPAMADEventData_AgentName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMADEventData_AgentName");

    }

    u_octet4_loop_TpPAMADEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADEventData_AgentType = %u",u_octet4_loop_TpPAMADEventData_AgentType);
    }

    for (i_TpPAMADEventData_AgentType=0; i_TpPAMADEventData_AgentType < u_octet4_loop_TpPAMADEventData_AgentType; i_TpPAMADEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMADEventData_AgentType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMADNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMADNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMADNotificationData_Agents;
    guint32   i_TpPAMADNotificationData_Agents;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMADNotificationData_Agents = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMADNotificationData_Agents = %u",u_octet4_loop_TpPAMADNotificationData_Agents);
    }

    for (i_TpPAMADNotificationData_Agents=0; i_TpPAMADNotificationData_Agents < u_octet4_loop_TpPAMADNotificationData_Agents; i_TpPAMADNotificationData_Agents++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMADNotificationData_Agents");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAAEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMAAEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAAEventData_IdentityName;
    guint32   i_TpPAMAAEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMAAEventData_IdentityType;
    guint32   i_TpPAMAAEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAAEventData_AgentName;
    guint32   i_TpPAMAAEventData_AgentName;
    guint32   u_octet4_loop_TpPAMAAEventData_AgentType;
    guint32   i_TpPAMAAEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMAAEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_IdentityName = %u",u_octet4_loop_TpPAMAAEventData_IdentityName);
    }

    for (i_TpPAMAAEventData_IdentityName=0; i_TpPAMAAEventData_IdentityName < u_octet4_loop_TpPAMAAEventData_IdentityName; i_TpPAMAAEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAAEventData_IdentityName");

    }

    u_octet4_loop_TpPAMAAEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_IdentityType = %u",u_octet4_loop_TpPAMAAEventData_IdentityType);
    }

    for (i_TpPAMAAEventData_IdentityType=0; i_TpPAMAAEventData_IdentityType < u_octet4_loop_TpPAMAAEventData_IdentityType; i_TpPAMAAEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAAEventData_IdentityType");

    }

    u_octet4_loop_TpPAMAAEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_AgentName = %u",u_octet4_loop_TpPAMAAEventData_AgentName);
    }

    for (i_TpPAMAAEventData_AgentName=0; i_TpPAMAAEventData_AgentName < u_octet4_loop_TpPAMAAEventData_AgentName; i_TpPAMAAEventData_AgentName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAAEventData_AgentName");

    }

    u_octet4_loop_TpPAMAAEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAAEventData_AgentType = %u",u_octet4_loop_TpPAMAAEventData_AgentType);
    }

    for (i_TpPAMAAEventData_AgentType=0; i_TpPAMAAEventData_AgentType < u_octet4_loop_TpPAMAAEventData_AgentType; i_TpPAMAAEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAAEventData_AgentType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAANotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMAANotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAANotificationData_Identity");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAANotificationData_Agent");

}

/* Struct = IDL:org/csapi/pam/TpPAMAUEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMAUEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAUEventData_IdentityName;
    guint32   i_TpPAMAUEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMAUEventData_IdentityType;
    guint32   i_TpPAMAUEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAUEventData_AgentName;
    guint32   i_TpPAMAUEventData_AgentName;
    guint32   u_octet4_loop_TpPAMAUEventData_AgentType;
    guint32   i_TpPAMAUEventData_AgentType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMAUEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_IdentityName = %u",u_octet4_loop_TpPAMAUEventData_IdentityName);
    }

    for (i_TpPAMAUEventData_IdentityName=0; i_TpPAMAUEventData_IdentityName < u_octet4_loop_TpPAMAUEventData_IdentityName; i_TpPAMAUEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUEventData_IdentityName");

    }

    u_octet4_loop_TpPAMAUEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_IdentityType = %u",u_octet4_loop_TpPAMAUEventData_IdentityType);
    }

    for (i_TpPAMAUEventData_IdentityType=0; i_TpPAMAUEventData_IdentityType < u_octet4_loop_TpPAMAUEventData_IdentityType; i_TpPAMAUEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUEventData_IdentityType");

    }

    u_octet4_loop_TpPAMAUEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_AgentName = %u",u_octet4_loop_TpPAMAUEventData_AgentName);
    }

    for (i_TpPAMAUEventData_AgentName=0; i_TpPAMAUEventData_AgentName < u_octet4_loop_TpPAMAUEventData_AgentName; i_TpPAMAUEventData_AgentName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUEventData_AgentName");

    }

    u_octet4_loop_TpPAMAUEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAUEventData_AgentType = %u",u_octet4_loop_TpPAMAUEventData_AgentType);
    }

    for (i_TpPAMAUEventData_AgentType=0; i_TpPAMAUEventData_AgentType < u_octet4_loop_TpPAMAUEventData_AgentType; i_TpPAMAUEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUEventData_AgentType");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAUNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMAUNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUNotificationData_Identity");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAUNotificationData_Agent");

}

/* Struct = IDL:org/csapi/pam/TpPAMCCEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMCCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMCCEventData_IdentityName;
    guint32   i_TpPAMCCEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMCCEventData_IdentityType;
    guint32   i_TpPAMCCEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMCCEventData_Capabilities;
    guint32   i_TpPAMCCEventData_Capabilities;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMCCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_IdentityName = %u",u_octet4_loop_TpPAMCCEventData_IdentityName);
    }

    for (i_TpPAMCCEventData_IdentityName=0; i_TpPAMCCEventData_IdentityName < u_octet4_loop_TpPAMCCEventData_IdentityName; i_TpPAMCCEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCCEventData_IdentityName");

    }

    u_octet4_loop_TpPAMCCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_IdentityType = %u",u_octet4_loop_TpPAMCCEventData_IdentityType);
    }

    for (i_TpPAMCCEventData_IdentityType=0; i_TpPAMCCEventData_IdentityType < u_octet4_loop_TpPAMCCEventData_IdentityType; i_TpPAMCCEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCCEventData_IdentityType");

    }

    u_octet4_loop_TpPAMCCEventData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCEventData_Capabilities = %u",u_octet4_loop_TpPAMCCEventData_Capabilities);
    }

    for (i_TpPAMCCEventData_Capabilities=0; i_TpPAMCCEventData_Capabilities < u_octet4_loop_TpPAMCCEventData_Capabilities; i_TpPAMCCEventData_Capabilities++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCCEventData_Capabilities");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMCCNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMCCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMCCNotificationData_Capabilities;
    guint32   i_TpPAMCCNotificationData_Capabilities;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCCNotificationData_Identity");

    u_octet4_loop_TpPAMCCNotificationData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMCCNotificationData_Capabilities = %u",u_octet4_loop_TpPAMCCNotificationData_Capabilities);
    }

    for (i_TpPAMCCNotificationData_Capabilities=0; i_TpPAMCCNotificationData_Capabilities < u_octet4_loop_TpPAMCCNotificationData_Capabilities; i_TpPAMCCNotificationData_Capabilities++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMCCNotificationData_Capabilities");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACPSEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMACPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACPSEventData_AgentName;
    guint32   i_TpPAMACPSEventData_AgentName;
    guint32   u_octet4_loop_TpPAMACPSEventData_AgentType;
    guint32   i_TpPAMACPSEventData_AgentType;
    guint32   u_octet4_loop_TpPAMACPSEventData_Capabilities;
    guint32   i_TpPAMACPSEventData_Capabilities;
    guint32   u_octet4_loop_TpPAMACPSEventData_AttributeNames;
    guint32   i_TpPAMACPSEventData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMACPSEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AgentName = %u",u_octet4_loop_TpPAMACPSEventData_AgentName);
    }

    for (i_TpPAMACPSEventData_AgentName=0; i_TpPAMACPSEventData_AgentName < u_octet4_loop_TpPAMACPSEventData_AgentName; i_TpPAMACPSEventData_AgentName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSEventData_AgentName");

    }

    u_octet4_loop_TpPAMACPSEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AgentType = %u",u_octet4_loop_TpPAMACPSEventData_AgentType);
    }

    for (i_TpPAMACPSEventData_AgentType=0; i_TpPAMACPSEventData_AgentType < u_octet4_loop_TpPAMACPSEventData_AgentType; i_TpPAMACPSEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSEventData_AgentType");

    }

    u_octet4_loop_TpPAMACPSEventData_Capabilities = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_Capabilities = %u",u_octet4_loop_TpPAMACPSEventData_Capabilities);
    }

    for (i_TpPAMACPSEventData_Capabilities=0; i_TpPAMACPSEventData_Capabilities < u_octet4_loop_TpPAMACPSEventData_Capabilities; i_TpPAMACPSEventData_Capabilities++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSEventData_Capabilities");

    }

    u_octet4_loop_TpPAMACPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMACPSEventData_AttributeNames);
    }

    for (i_TpPAMACPSEventData_AttributeNames=0; i_TpPAMACPSEventData_AttributeNames < u_octet4_loop_TpPAMACPSEventData_AttributeNames; i_TpPAMACPSEventData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSEventData_AttributeNames");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMACPSEventData_ReportingPeriod = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMACPSNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMACPSNotificationData_AttributeNames;
    guint32   i_TpPAMACPSNotificationData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSNotificationData_Agent");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSNotificationData_Capability");

    u_octet4_loop_TpPAMACPSNotificationData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMACPSNotificationData_AttributeNames = %u",u_octet4_loop_TpPAMACPSNotificationData_AttributeNames);
    }

    for (i_TpPAMACPSNotificationData_AttributeNames=0; i_TpPAMACPSNotificationData_AttributeNames < u_octet4_loop_TpPAMACPSNotificationData_AttributeNames; i_TpPAMACPSNotificationData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMACPSNotificationData_AttributeNames");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAPSEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMAPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAPSEventData_AgentName;
    guint32   i_TpPAMAPSEventData_AgentName;
    guint32   u_octet4_loop_TpPAMAPSEventData_AgentType;
    guint32   i_TpPAMAPSEventData_AgentType;
    guint32   u_octet4_loop_TpPAMAPSEventData_AttributeNames;
    guint32   i_TpPAMAPSEventData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMAPSEventData_AgentName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AgentName = %u",u_octet4_loop_TpPAMAPSEventData_AgentName);
    }

    for (i_TpPAMAPSEventData_AgentName=0; i_TpPAMAPSEventData_AgentName < u_octet4_loop_TpPAMAPSEventData_AgentName; i_TpPAMAPSEventData_AgentName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAPSEventData_AgentName");

    }

    u_octet4_loop_TpPAMAPSEventData_AgentType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AgentType = %u",u_octet4_loop_TpPAMAPSEventData_AgentType);
    }

    for (i_TpPAMAPSEventData_AgentType=0; i_TpPAMAPSEventData_AgentType < u_octet4_loop_TpPAMAPSEventData_AgentType; i_TpPAMAPSEventData_AgentType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAPSEventData_AgentType");

    }

    u_octet4_loop_TpPAMAPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMAPSEventData_AttributeNames);
    }

    for (i_TpPAMAPSEventData_AttributeNames=0; i_TpPAMAPSEventData_AttributeNames < u_octet4_loop_TpPAMAPSEventData_AttributeNames; i_TpPAMAPSEventData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAPSEventData_AttributeNames");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAPSEventData_ReportingPeriod = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAPSNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAPSNotificationData_AttributeNames;
    guint32   i_TpPAMAPSNotificationData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAPSNotificationData_Agent");

    u_octet4_loop_TpPAMAPSNotificationData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAPSNotificationData_AttributeNames = %u",u_octet4_loop_TpPAMAPSNotificationData_AttributeNames);
    }

    for (i_TpPAMAPSNotificationData_AttributeNames=0; i_TpPAMAPSNotificationData_AttributeNames < u_octet4_loop_TpPAMAPSNotificationData_AttributeNames; i_TpPAMAPSNotificationData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAPSNotificationData_AttributeNames");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIPSEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMIPSEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIPSEventData_IdentityName;
    guint32   i_TpPAMIPSEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMIPSEventData_IdentityType;
    guint32   i_TpPAMIPSEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMIPSEventData_AttributeNames;
    guint32   i_TpPAMIPSEventData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMIPSEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_IdentityName = %u",u_octet4_loop_TpPAMIPSEventData_IdentityName);
    }

    for (i_TpPAMIPSEventData_IdentityName=0; i_TpPAMIPSEventData_IdentityName < u_octet4_loop_TpPAMIPSEventData_IdentityName; i_TpPAMIPSEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIPSEventData_IdentityName");

    }

    u_octet4_loop_TpPAMIPSEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_IdentityType = %u",u_octet4_loop_TpPAMIPSEventData_IdentityType);
    }

    for (i_TpPAMIPSEventData_IdentityType=0; i_TpPAMIPSEventData_IdentityType < u_octet4_loop_TpPAMIPSEventData_IdentityType; i_TpPAMIPSEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIPSEventData_IdentityType");

    }

    u_octet4_loop_TpPAMIPSEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSEventData_AttributeNames = %u",u_octet4_loop_TpPAMIPSEventData_AttributeNames);
    }

    for (i_TpPAMIPSEventData_AttributeNames=0; i_TpPAMIPSEventData_AttributeNames < u_octet4_loop_TpPAMIPSEventData_AttributeNames; i_TpPAMIPSEventData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIPSEventData_AttributeNames");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMIPSEventData_ReportingPeriod = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMIPSNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMIPSNotificationData_Attributes;
    guint32   i_TpPAMIPSNotificationData_Attributes;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMIPSNotificationData_Identity");

    u_octet4_loop_TpPAMIPSNotificationData_Attributes = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMIPSNotificationData_Attributes = %u",u_octet4_loop_TpPAMIPSNotificationData_Attributes);
    }

    for (i_TpPAMIPSNotificationData_Attributes=0; i_TpPAMIPSNotificationData_Attributes < u_octet4_loop_TpPAMIPSNotificationData_Attributes; i_TpPAMIPSNotificationData_Attributes++) {

        /*  Begin struct "org_csapi_pam_TpPAMPresenceData"  */

        

        decode_org_csapi_pam_TpPAMPresenceData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMPresenceData"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAVCEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMAVCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAVCEventData_IdentityName;
    guint32   i_TpPAMAVCEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMAVCEventData_IdentityType;
    guint32   i_TpPAMAVCEventData_IdentityType;
    guint32   u_octet4_loop_TpPAMAVCEventData_PAMContext;
    guint32   i_TpPAMAVCEventData_PAMContext;
    guint32   u_octet4_loop_TpPAMAVCEventData_AttributeNames;
    guint32   i_TpPAMAVCEventData_AttributeNames;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMAVCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_IdentityName = %u",u_octet4_loop_TpPAMAVCEventData_IdentityName);
    }

    for (i_TpPAMAVCEventData_IdentityName=0; i_TpPAMAVCEventData_IdentityName < u_octet4_loop_TpPAMAVCEventData_IdentityName; i_TpPAMAVCEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAVCEventData_IdentityName");

    }

    u_octet4_loop_TpPAMAVCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_IdentityType = %u",u_octet4_loop_TpPAMAVCEventData_IdentityType);
    }

    for (i_TpPAMAVCEventData_IdentityType=0; i_TpPAMAVCEventData_IdentityType < u_octet4_loop_TpPAMAVCEventData_IdentityType; i_TpPAMAVCEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAVCEventData_IdentityType");

    }

    u_octet4_loop_TpPAMAVCEventData_PAMContext = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_PAMContext = %u",u_octet4_loop_TpPAMAVCEventData_PAMContext);
    }

    for (i_TpPAMAVCEventData_PAMContext=0; i_TpPAMAVCEventData_PAMContext < u_octet4_loop_TpPAMAVCEventData_PAMContext; i_TpPAMAVCEventData_PAMContext++) {

        /*  Begin struct "org_csapi_pam_TpPAMContext"  */

        

        decode_org_csapi_pam_TpPAMContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMContext"  */

    }

    u_octet4_loop_TpPAMAVCEventData_AttributeNames = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCEventData_AttributeNames = %u",u_octet4_loop_TpPAMAVCEventData_AttributeNames);
    }

    for (i_TpPAMAVCEventData_AttributeNames=0; i_TpPAMAVCEventData_AttributeNames < u_octet4_loop_TpPAMAVCEventData_AttributeNames; i_TpPAMAVCEventData_AttributeNames++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAVCEventData_AttributeNames");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMAVCEventData_ReportingPeriod = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMAVCNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMAVCNotificationData_Availability;
    guint32   i_TpPAMAVCNotificationData_Availability;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMAVCNotificationData_Identity");

    u_octet4_loop_TpPAMAVCNotificationData_Availability = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMAVCNotificationData_Availability = %u",u_octet4_loop_TpPAMAVCNotificationData_Availability);
    }

    for (i_TpPAMAVCNotificationData_Availability=0; i_TpPAMAVCNotificationData_Availability < u_octet4_loop_TpPAMAVCNotificationData_Availability; i_TpPAMAVCNotificationData_Availability++) {

        /*  Begin struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

        

        decode_org_csapi_pam_TpPAMAvailabilityProfile_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAvailabilityProfile"  */

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMWCEventData:1.0 */
static void
decode_org_csapi_pam_TpPAMWCEventData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpPAMWCEventData_Events;
    guint32   i_TpPAMWCEventData_Events;
    guint32   u_octet4;
    guint32   u_octet4_loop_TpPAMWCEventData_IdentityName;
    guint32   i_TpPAMWCEventData_IdentityName;
    guint32   u_octet4_loop_TpPAMWCEventData_IdentityType;
    guint32   i_TpPAMWCEventData_IdentityType;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpPAMWCEventData_Events = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_Events = %u",u_octet4_loop_TpPAMWCEventData_Events);
    }

    for (i_TpPAMWCEventData_Events=0; i_TpPAMWCEventData_Events < u_octet4_loop_TpPAMWCEventData_Events; i_TpPAMWCEventData_Events++) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMWCEventData_Events  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
        }

    }

    u_octet4_loop_TpPAMWCEventData_IdentityName = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_IdentityName = %u",u_octet4_loop_TpPAMWCEventData_IdentityName);
    }

    for (i_TpPAMWCEventData_IdentityName=0; i_TpPAMWCEventData_IdentityName < u_octet4_loop_TpPAMWCEventData_IdentityName; i_TpPAMWCEventData_IdentityName++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMWCEventData_IdentityName");

    }

    u_octet4_loop_TpPAMWCEventData_IdentityType = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCEventData_IdentityType = %u",u_octet4_loop_TpPAMWCEventData_IdentityType);
    }

    for (i_TpPAMWCEventData_IdentityType=0; i_TpPAMWCEventData_IdentityType < u_octet4_loop_TpPAMWCEventData_IdentityType; i_TpPAMWCEventData_IdentityType++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMWCEventData_IdentityType");

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-8,8,"TpPAMWCEventData_ReportingPeriod = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/pam/TpPAMWCNotificationData:1.0 */
static void
decode_org_csapi_pam_TpPAMWCNotificationData_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    guint32   u_octet4_loop_TpPAMWCNotificationData_Watchers;
    guint32   i_TpPAMWCNotificationData_Watchers;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMWCNotificationData_Event  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMWCNotificationData_ChangeType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMwatcherChangeType,"Unknown Enum Value"));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMWCNotificationData_Identity");

    u_octet4_loop_TpPAMWCNotificationData_Watchers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpPAMWCNotificationData_Watchers = %u",u_octet4_loop_TpPAMWCNotificationData_Watchers);
    }

    for (i_TpPAMWCNotificationData_Watchers=0; i_TpPAMWCNotificationData_Watchers < u_octet4_loop_TpPAMWCNotificationData_Watchers; i_TpPAMWCNotificationData_Watchers++) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpPAMWCNotificationData_Watchers");

    }

}

/* Struct = IDL:org/csapi/pam/TpPAMErrorInfo:1.0 */
static void
decode_org_csapi_pam_TpPAMErrorInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMErrorInfo_Cause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMErrorCause,"Unknown Enum Value"));
    }

    /*  Begin union "org_csapi_pam_TpPAMNotificationInfo"  */

    
    decode_org_csapi_pam_TpPAMNotificationInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End union "org_csapi_pam_TpPAMNotificationInfo"  */

}

/* Struct = IDL:org/csapi/mmm/TpMailboxIdentifier:1.0 */
static void
decode_org_csapi_mmm_TpMailboxIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxIdentifier_SessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpMultiMediaMessagingIdentifier:1.0 */
static void
decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMultiMediaMessagingIdentifier_SessionID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpListMessagesCriteria:1.0 */
static void
decode_org_csapi_mmm_TpListMessagesCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpListMessagesCriteria_OnlyUnreadMessages = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mmm/TpMailboxFolderStatusInformation:1.0 */
static void
decode_org_csapi_mmm_TpMailboxFolderStatusInformation_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxFolderStatusInformation_TotalMessageCount = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessageDescription:1.0 */
static void
decode_org_csapi_mmm_TpMessageDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessageDescription_To;
    guint32   i_TpMessageDescription_To;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpMessageDescription_MessageID");

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpMessageDescription_To = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessageDescription_To = %u",u_octet4_loop_TpMessageDescription_To);
    }

    for (i_TpMessageDescription_To=0; i_TpMessageDescription_To < u_octet4_loop_TpMessageDescription_To; i_TpMessageDescription_To++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpMessageDescription_Subject");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpMessageDescription_ReceivedDate");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageDescription_Size = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpBodyPartDescription:1.0 */
static void
decode_org_csapi_mmm_TpBodyPartDescription_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_ContentDescription");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBodyPartDescription_ContentSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_ContentType");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_ContentTransferEncoding");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_ContentID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_ContentDisposition");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpBodyPartDescription_PartID");

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBodyPartDescription_NestingLevel = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpBodyPart:1.0 */
static void
decode_org_csapi_mmm_TpBodyPart_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpBodyPart_BodyPartContent;
    guint32   i_TpBodyPart_BodyPartContent;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_mmm_TpBodyPartDescription"  */

    

    decode_org_csapi_mmm_TpBodyPartDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mmm_TpBodyPartDescription"  */

    u_octet4_loop_TpBodyPart_BodyPartContent = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpBodyPart_BodyPartContent = %u",u_octet4_loop_TpBodyPart_BodyPartContent);
    }

    for (i_TpBodyPart_BodyPartContent=0; i_TpBodyPart_BodyPartContent < u_octet4_loop_TpBodyPart_BodyPartContent; i_TpBodyPart_BodyPartContent++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpBodyPart_BodyPartContent = %u",get_CDR_octet(tvb,offset));
        }

    }

}

/* Struct = IDL:org/csapi/mmm/TpGenericHeaderField:1.0 */
static void
decode_org_csapi_mmm_TpGenericHeaderField_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpGenericHeaderField_FieldName");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpGenericHeaderField_FieldValue");

}

/* Struct = IDL:org/csapi/mmm/TpMessageInfoPropertyError:1.0 */
static void
decode_org_csapi_mmm_TpMessageInfoPropertyError_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    
    /* Operation specific Variable declarations End */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageInfoPropertyError_MessagePropertyName  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageInfoPropertyError_Error  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpSetPropertyError,"Unknown Enum Value"));
    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedCriteria:1.0 */
static void
decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNewMailboxMessageArrivedCriteria_MailboxID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNewMailboxMessageArrivedCriteria_AuthenticationInfo");

}

/* Struct = IDL:org/csapi/mmm/TpNewMailboxMessageArrivedInfo:1.0 */
static void
decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription;
    guint32   i_TpNewMailboxMessageArrivedInfo_MessageDescription;
    guint32   u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation;
    guint32   i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation;
    
    /* Operation specific Variable declarations End */

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNewMailboxMessageArrivedInfo_MailboxID");

    giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "TpNewMailboxMessageArrivedInfo_FolderID");

    u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMailboxMessageArrivedInfo_MessageDescription = %u",u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription);
    }

    for (i_TpNewMailboxMessageArrivedInfo_MessageDescription=0; i_TpNewMailboxMessageArrivedInfo_MessageDescription < u_octet4_loop_TpNewMailboxMessageArrivedInfo_MessageDescription; i_TpNewMailboxMessageArrivedInfo_MessageDescription++) {

        /*  Begin struct "org_csapi_mmm_TpMessageDescription"  */

        

        decode_org_csapi_mmm_TpMessageDescription_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpMessageDescription"  */

    }

    u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation = %u",u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation);
    }

    for (i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation=0; i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation < u_octet4_loop_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation; i_TpNewMailboxMessageArrivedInfo_ExtendedHeaderInformation++) {

        /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

        
        decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

    }

}

/* Struct = IDL:org/csapi/mmm/TpQueryStatusReport:1.0 */
static void
decode_org_csapi_mmm_TpQueryStatusReport_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpQueryStatusReport_ReportedStatus = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpTerminatingAddressList:1.0 */
static void
decode_org_csapi_mmm_TpTerminatingAddressList_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpTerminatingAddressList_ToAddressList;
    guint32   i_TpTerminatingAddressList_ToAddressList;
    guint32   u_octet4_loop_TpTerminatingAddressList_CcAddressList;
    guint32   i_TpTerminatingAddressList_CcAddressList;
    guint32   u_octet4_loop_TpTerminatingAddressList_BccAddressList;
    guint32   i_TpTerminatingAddressList_BccAddressList;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpTerminatingAddressList_ToAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_ToAddressList = %u",u_octet4_loop_TpTerminatingAddressList_ToAddressList);
    }

    for (i_TpTerminatingAddressList_ToAddressList=0; i_TpTerminatingAddressList_ToAddressList < u_octet4_loop_TpTerminatingAddressList_ToAddressList; i_TpTerminatingAddressList_ToAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpTerminatingAddressList_CcAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_CcAddressList = %u",u_octet4_loop_TpTerminatingAddressList_CcAddressList);
    }

    for (i_TpTerminatingAddressList_CcAddressList=0; i_TpTerminatingAddressList_CcAddressList < u_octet4_loop_TpTerminatingAddressList_CcAddressList; i_TpTerminatingAddressList_CcAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpTerminatingAddressList_BccAddressList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpTerminatingAddressList_BccAddressList = %u",u_octet4_loop_TpTerminatingAddressList_BccAddressList);
    }

    for (i_TpTerminatingAddressList_BccAddressList=0; i_TpTerminatingAddressList_BccAddressList < u_octet4_loop_TpTerminatingAddressList_BccAddressList; i_TpTerminatingAddressList_BccAddressList++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedCriteria:1.0 */
static void
decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    /*  Begin struct "org_csapi_TpAddressRange"  */

    

    decode_org_csapi_TpAddressRange_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddressRange"  */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpNewMessageArrivedCriteria_CreateMultiMediaMessagingSession = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequested:1.0 */
static void
decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessagingNotificationRequested_EventCriteria;
    guint32   i_TpMessagingNotificationRequested_EventCriteria;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpMessagingNotificationRequested_EventCriteria = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessagingNotificationRequested_EventCriteria = %u",u_octet4_loop_TpMessagingNotificationRequested_EventCriteria);
    }

    for (i_TpMessagingNotificationRequested_EventCriteria=0; i_TpMessagingNotificationRequested_EventCriteria < u_octet4_loop_TpMessagingNotificationRequested_EventCriteria; i_TpMessagingNotificationRequested_EventCriteria++) {

        /*  Begin union "org_csapi_mmm_TpMessagingEventCriteria"  */

        
        decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_mmm_TpMessagingEventCriteria"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingNotificationRequested_AssignmentID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
    }

}

/* Struct = IDL:org/csapi/mmm/TpMessagingNotificationRequestedSetEntry:1.0 */
static void
decode_org_csapi_mmm_TpMessagingNotificationRequestedSetEntry_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet;
    guint32   i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet;
    
    /* Operation specific Variable declarations End */

    u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet = %u",u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet);
    }

    for (i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet=0; i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet < u_octet4_loop_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet; i_TpMessagingNotificationRequestedSetEntry_MessagingNotificationRequestedSet++) {

        /*  Begin struct "org_csapi_mmm_TpMessagingNotificationRequested"  */

        

        decode_org_csapi_mmm_TpMessagingNotificationRequested_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpMessagingNotificationRequested"  */

    }

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-1,1,"TpMessagingNotificationRequestedSetEntry_Final = %u",get_CDR_boolean(tvb,offset));
    }

}

/* Struct = IDL:org/csapi/mmm/TpNewMessageArrivedInfo:1.0 */
static void
decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet;
    guint32   i_TpNewMessageArrivedInfo_DestinationAddressSet;
    guint32   u_octet4_loop_TpNewMessageArrivedInfo_Message;
    guint32   i_TpNewMessageArrivedInfo_Message;
    guint32   u_octet4_loop_TpNewMessageArrivedInfo_Headers;
    guint32   i_TpNewMessageArrivedInfo_Headers;
    
    /* Operation specific Variable declarations End */

    /*  Begin struct "org_csapi_TpAddress"  */

    

    decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_TpAddress"  */

    u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_DestinationAddressSet = %u",u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet);
    }

    for (i_TpNewMessageArrivedInfo_DestinationAddressSet=0; i_TpNewMessageArrivedInfo_DestinationAddressSet < u_octet4_loop_TpNewMessageArrivedInfo_DestinationAddressSet; i_TpNewMessageArrivedInfo_DestinationAddressSet++) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

    }

    u_octet4_loop_TpNewMessageArrivedInfo_Message = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_Message = %u",u_octet4_loop_TpNewMessageArrivedInfo_Message);
    }

    for (i_TpNewMessageArrivedInfo_Message=0; i_TpNewMessageArrivedInfo_Message < u_octet4_loop_TpNewMessageArrivedInfo_Message; i_TpNewMessageArrivedInfo_Message++) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"TpNewMessageArrivedInfo_Message = %u",get_CDR_octet(tvb,offset));
        }

    }

    u_octet4_loop_TpNewMessageArrivedInfo_Headers = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TpNewMessageArrivedInfo_Headers = %u",u_octet4_loop_TpNewMessageArrivedInfo_Headers);
    }

    for (i_TpNewMessageArrivedInfo_Headers=0; i_TpNewMessageArrivedInfo_Headers < u_octet4_loop_TpNewMessageArrivedInfo_Headers; i_TpNewMessageArrivedInfo_Headers++) {

        /*  Begin union "org_csapi_mmm_TpMessageHeaderField"  */

        
        decode_org_csapi_mmm_TpMessageHeaderField_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_mmm_TpMessageHeaderField"  */

    }

    /*  Begin struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

    

    decode_org_csapi_mmm_TpMultiMediaMessagingIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

    /*  End struct "org_csapi_mmm_TpMultiMediaMessagingIdentifier"  */

}

/* Union = IDL:org/csapi/TpAoCOrder:1.0 */
static void
decode_org_csapi_TpAoCOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAoCOrder;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/TpAoCOrder:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAoCOrder  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpCallAoCOrderCategory,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpCallAoCOrderCategory:1.0
     */

    disc_s_TpAoCOrder = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAoCOrder == 0 ) {

        /*  Begin struct "org_csapi_TpChargeAdviceInfo"  */

        

        decode_org_csapi_TpChargeAdviceInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpChargeAdviceInfo"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAoCOrder == 1 ) {

        /*  Begin struct "org_csapi_TpChargePerTime"  */

        

        decode_org_csapi_TpChargePerTime_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpChargePerTime"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAoCOrder == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "NetworkCharge");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/TpSimpleAttributeValue:1.0 */
static void
decode_org_csapi_TpSimpleAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpSimpleAttributeValue;
    gint8     s_octet1;
    gchar   *seq = NULL;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/TpSimpleAttributeValue:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpSimpleAttributeValue  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpSimpleAttributeTypeInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpSimpleAttributeTypeInfo:1.0
     */

    disc_s_TpSimpleAttributeValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpSimpleAttributeValue == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"BooleanValue = %u",get_CDR_boolean(tvb,offset));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"OctetValue = %u",get_CDR_octet(tvb,offset));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 2 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"CharValue = %u",get_CDR_char(tvb,offset));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 3 ) {

        s_octet1 = get_CDR_wchar(tvb, &seq, offset, header);
        if (tree) {
            if (s_octet1 > 0)
                proto_tree_add_text(tree,tvb,*offset-1-s_octet1,1,"length = %u",s_octet1);

            if (s_octet1 < 0)
                s_octet1 = -s_octet1;

            if (s_octet1 > 0)
                proto_tree_add_text(tree,tvb,*offset-s_octet1,s_octet1,"WCharValue = %s",seq);

        }


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "StringValue");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 5 ) {

        u_octet4 = get_CDR_wstring(tvb, &seq, offset, stream_is_big_endian, boundary, header);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-u_octet4,u_octet4,"WStringValue (%u) = %s",
              u_octet4, (u_octet4 > 0) ? seq : "");
        }


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 6 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-2,2,"Int16Value = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 7 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-2,2,"UnsignedInt16Value = %u",get_CDR_ushort(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 8 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Int32Value = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 9 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UnsignedInt32Value = %u",get_CDR_ulong(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 10 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"Int64Value = %" G_GINT64_MODIFIER "d",get_CDR_long_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 11 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"UnsignedInt64Value = %" G_GINT64_MODIFIER "u",get_CDR_ulong_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 12 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FloatValue = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpSimpleAttributeValue == 13 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-8,8,"DoubleValue = %.15e",get_CDR_double(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/TpAttributeValue:1.0 */
static void
decode_org_csapi_TpAttributeValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAttributeValue;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/TpAttributeValue:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAttributeValue  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAttributeTagInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/TpAttributeTagInfo:1.0
     */

    disc_s_TpAttributeValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAttributeValue == 0 ) {

        /*  Begin union "org_csapi_TpSimpleAttributeValue"  */

        
        decode_org_csapi_TpSimpleAttributeValue_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_TpSimpleAttributeValue"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAttributeValue == 1 ) {

        /*  Begin struct "org_csapi_TpStructuredAttributeValue"  */

        

        decode_org_csapi_TpStructuredAttributeValue_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpStructuredAttributeValue"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAttributeValue == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "XMLValue");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/fw/TpFwEventCriteria:1.0 */
static void
decode_org_csapi_fw_TpFwEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFwEventCriteria;
    guint32   u_octet4_loop_ServiceTypeNameList;
    guint32   i_ServiceTypeNameList;
    guint32   u_octet4_loop_UnavailableServiceTypeNameList;
    guint32   i_UnavailableServiceTypeNameList;
    guint32   u_octet4_loop_CompatibleServiceTypeNameList;
    guint32   i_CompatibleServiceTypeNameList;
    guint32   u_octet4_loop_SessionCreatedList;
    guint32   i_SessionCreatedList;
    guint32   u_octet4_loop_SessionTerminatedList;
    guint32   i_SessionTerminatedList;
    guint32   u_octet4_loop_AgreementSignedList;
    guint32   i_AgreementSignedList;
    guint32   u_octet4_loop_AgreementEndedList;
    guint32   i_AgreementEndedList;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpFwEventCriteria:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFwEventCriteria  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpFwEventName:1.0
     */

    disc_s_TpFwEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFwEventCriteria == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "EventNameUndefined");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 1 ) {

        u_octet4_loop_ServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ServiceTypeNameList = %u",u_octet4_loop_ServiceTypeNameList);
        }

        for (i_ServiceTypeNameList=0; i_ServiceTypeNameList < u_octet4_loop_ServiceTypeNameList; i_ServiceTypeNameList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ServiceTypeNameList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 2 ) {

        u_octet4_loop_UnavailableServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of UnavailableServiceTypeNameList = %u",u_octet4_loop_UnavailableServiceTypeNameList);
        }

        for (i_UnavailableServiceTypeNameList=0; i_UnavailableServiceTypeNameList < u_octet4_loop_UnavailableServiceTypeNameList; i_UnavailableServiceTypeNameList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "UnavailableServiceTypeNameList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 3 ) {

        u_octet4_loop_CompatibleServiceTypeNameList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of CompatibleServiceTypeNameList = %u",u_octet4_loop_CompatibleServiceTypeNameList);
        }

        for (i_CompatibleServiceTypeNameList=0; i_CompatibleServiceTypeNameList < u_octet4_loop_CompatibleServiceTypeNameList; i_CompatibleServiceTypeNameList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "CompatibleServiceTypeNameList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 4 ) {

        u_octet4_loop_SessionCreatedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of SessionCreatedList = %u",u_octet4_loop_SessionCreatedList);
        }

        for (i_SessionCreatedList=0; i_SessionCreatedList < u_octet4_loop_SessionCreatedList; i_SessionCreatedList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "SessionCreatedList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 5 ) {

        u_octet4_loop_SessionTerminatedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of SessionTerminatedList = %u",u_octet4_loop_SessionTerminatedList);
        }

        for (i_SessionTerminatedList=0; i_SessionTerminatedList < u_octet4_loop_SessionTerminatedList; i_SessionTerminatedList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "SessionTerminatedList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 6 ) {

        u_octet4_loop_AgreementSignedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of AgreementSignedList = %u",u_octet4_loop_AgreementSignedList);
        }

        for (i_AgreementSignedList=0; i_AgreementSignedList < u_octet4_loop_AgreementSignedList; i_AgreementSignedList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "AgreementSignedList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventCriteria == 7 ) {

        u_octet4_loop_AgreementEndedList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of AgreementEndedList = %u",u_octet4_loop_AgreementEndedList);
        }

        for (i_AgreementEndedList=0; i_AgreementEndedList < u_octet4_loop_AgreementEndedList; i_AgreementEndedList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "AgreementEndedList");

        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0 */
static void
decode_org_csapi_fw_TpLoadStatisticEntityID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpLoadStatisticEntityID;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpLoadStatisticEntityID:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadStatisticEntityID  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticEntityType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpLoadStatisticEntityType:1.0
     */

    disc_s_TpLoadStatisticEntityID = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpLoadStatisticEntityID == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "FrameworkID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpLoadStatisticEntityID == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ServiceID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpLoadStatisticEntityID == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ClientAppID");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/fw/TpLoadStatisticInfo:1.0 */
static void
decode_org_csapi_fw_TpLoadStatisticInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpLoadStatisticInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpLoadStatisticInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpLoadStatisticInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpLoadStatisticInfoType:1.0
     */

    disc_s_TpLoadStatisticInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpLoadStatisticInfo == 0 ) {

        /*  Begin struct "org_csapi_fw_TpLoadStatisticData"  */

        

        decode_org_csapi_fw_TpLoadStatisticData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpLoadStatisticData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpLoadStatisticInfo == 1 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"LoadStatisticError  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpLoadStatisticError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/fw/TpDomainID:1.0 */
static void
decode_org_csapi_fw_TpDomainID_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDomainID;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpDomainID:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDomainID  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpDomainIDType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpDomainIDType:1.0
     */

    disc_s_TpDomainID = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDomainID == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "FwID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpDomainID == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ClientAppID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpDomainID == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "EntOpID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpDomainID == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ServiceID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpDomainID == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ServiceSupplierID");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0 */
static void
decode_org_csapi_fw_TpMigrationAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMigrationAdditionalInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpMigrationAdditionalInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMigrationAdditionalInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpMigrationAdditionalInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpMigrationAdditionalInfoType:1.0
     */

    disc_s_TpMigrationAdditionalInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/fw/TpFwEventInfo:1.0 */
static void
decode_org_csapi_fw_TpFwEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFwEventInfo;
    guint32   u_octet4_loop_ServiceIDList;
    guint32   i_ServiceIDList;
    guint32   u_octet4_loop_UnavailableServiceIDList;
    guint32   i_UnavailableServiceIDList;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/fw/TpFwEventInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFwEventInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_fw_TpFwEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/fw/TpFwEventName:1.0
     */

    disc_s_TpFwEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFwEventInfo == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "EventNameUndefined");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 1 ) {

        u_octet4_loop_ServiceIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ServiceIDList = %u",u_octet4_loop_ServiceIDList);
        }

        for (i_ServiceIDList=0; i_ServiceIDList < u_octet4_loop_ServiceIDList; i_ServiceIDList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ServiceIDList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 2 ) {

        u_octet4_loop_UnavailableServiceIDList = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of UnavailableServiceIDList = %u",u_octet4_loop_UnavailableServiceIDList);
        }

        for (i_UnavailableServiceIDList=0; i_UnavailableServiceIDList < u_octet4_loop_UnavailableServiceIDList; i_UnavailableServiceIDList++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "UnavailableServiceIDList");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 3 ) {

        /*  Begin struct "org_csapi_fw_TpFwMigrationServiceAvailableInfo"  */

        

        decode_org_csapi_fw_TpFwMigrationServiceAvailableInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFwMigrationServiceAvailableInfo"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "AppSessionCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 5 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "AppSessionTerminated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 6 ) {

        /*  Begin struct "org_csapi_fw_TpFwAgreementInfo"  */

        

        decode_org_csapi_fw_TpFwAgreementInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFwAgreementInfo"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFwEventInfo == 7 ) {

        /*  Begin struct "org_csapi_fw_TpFwAgreementInfo"  */

        

        decode_org_csapi_fw_TpFwAgreementInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_fw_TpFwAgreementInfo"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/ui/TpUIVariableInfo:1.0 */
static void
decode_org_csapi_ui_TpUIVariableInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUIVariableInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUIVariableInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIVariableInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIVariablePartType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUIVariablePartType:1.0
     */

    disc_s_TpUIVariableInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUIVariableInfo == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"VariablePartInteger = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIVariableInfo == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "VariablePartAddress");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIVariableInfo == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "VariablePartTime");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIVariableInfo == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "VariablePartDate");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIVariableInfo == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "VariablePartPrice");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/ui/TpUIInfo:1.0 */
static void
decode_org_csapi_ui_TpUIInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUIInfo;
    guint32   u_octet4_loop_InfoBinData;
    guint32   i_InfoBinData;
    guint32   u_octet4_loop_InfoMimeData;
    guint32   i_InfoMimeData;
    guint32   u_octet4_loop_InfoWaveData;
    guint32   i_InfoWaveData;
    guint32   u_octet4_loop_InfoAuData;
    guint32   i_InfoAuData;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUIInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUIInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUIInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUIInfoType:1.0
     */

    disc_s_TpUIInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUIInfo == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"InfoID = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "InfoData");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "InfoAddress");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 3 ) {

        u_octet4_loop_InfoBinData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoBinData = %u",u_octet4_loop_InfoBinData);
        }

        for (i_InfoBinData=0; i_InfoBinData < u_octet4_loop_InfoBinData; i_InfoBinData++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoBinData = %u",get_CDR_octet(tvb,offset));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "InfoUUEncData");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 5 ) {

        u_octet4_loop_InfoMimeData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoMimeData = %u",u_octet4_loop_InfoMimeData);
        }

        for (i_InfoMimeData=0; i_InfoMimeData < u_octet4_loop_InfoMimeData; i_InfoMimeData++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoMimeData = %u",get_CDR_octet(tvb,offset));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 6 ) {

        u_octet4_loop_InfoWaveData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoWaveData = %u",u_octet4_loop_InfoWaveData);
        }

        for (i_InfoWaveData=0; i_InfoWaveData < u_octet4_loop_InfoWaveData; i_InfoWaveData++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoWaveData = %u",get_CDR_octet(tvb,offset));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 7 ) {

        u_octet4_loop_InfoAuData = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InfoAuData = %u",u_octet4_loop_InfoAuData);
        }

        for (i_InfoAuData=0; i_InfoAuData < u_octet4_loop_InfoAuData; i_InfoAuData++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"InfoAuData = %u",get_CDR_octet(tvb,offset));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 8 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "InfoVXMLData");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUIInfo == 9 ) {

        /*  Begin struct "org_csapi_ui_TpUISynthesisInfoData"  */

        

        decode_org_csapi_ui_TpUISynthesisInfoData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_ui_TpUISynthesisInfoData"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0 */
static void
decode_org_csapi_cc_TpCallAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalErrorInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalErrorInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAdditionalErrorInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallErrorType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallErrorType:1.0
     */

    disc_s_TpCallAdditionalErrorInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalErrorInfo == 1 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallErrorInvalidAddress  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0 */
static void
decode_org_csapi_cc_TpCallLoadControlMechanism_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallLoadControlMechanism;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallLoadControlMechanism:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallLoadControlMechanism  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallLoadControlMechanismType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallLoadControlMechanismType:1.0
     */

    disc_s_TpCallLoadControlMechanism = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallLoadControlMechanism == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallLoadControlPerInterval = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0 */
static void
decode_org_csapi_cc_TpCallAdditionalTreatmentInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalTreatmentInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalTreatmentInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAdditionalTreatmentInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTreatmentType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallTreatmentType:1.0
     */

    disc_s_TpCallAdditionalTreatmentInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalTreatmentInfo == 2 ) {

        /*  Begin union "org_csapi_ui_TpUIInfo"  */

        
        decode_org_csapi_ui_TpUIInfo_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_ui_TpUIInfo"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0 */
static void
decode_org_csapi_cc_TpCallPartyToChargeAdditionalInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallPartyToChargeAdditionalInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallPartyToChargeAdditionalInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallPartyToChargeAdditionalInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyToChargeType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallPartyToChargeType:1.0
     */

    disc_s_TpCallPartyToChargeAdditionalInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallPartyToChargeAdditionalInfo == 2 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAppInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAppInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAppInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallAppInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallAppInfoType:1.0
     */

    disc_s_TpCallAppInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAppInfo == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppAlertingMechanism = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 2 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppNetworkAccessType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallNetworkAccessType,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 3 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppTeleService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTeleService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 4 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppBearerService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallBearerService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 5 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppPartyCategory  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyCategory,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 6 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 7 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "CallAppGenericInfo");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 8 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalReportInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAdditionalReportInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAdditionalReportInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallReportType:1.0
     */

    disc_s_TpCallAdditionalReportInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalReportInfo == 4 ) {

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 6 ) {

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 7 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 8 ) {

        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 9 ) {

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 10 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "QueueStatus");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportInfo == 11 ) {

        /*  Begin struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        

        decode_org_csapi_cc_gccs_TpCallReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0 */
static void
decode_org_csapi_cc_gccs_TpCallAdditionalReportCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalReportCriteria;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/gccs/TpCallAdditionalReportCriteria:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAdditionalReportCriteria  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_gccs_TpCallReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/gccs/TpCallReportType:1.0
     */

    disc_s_TpCallAdditionalReportCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalReportCriteria == 5 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"NoAnswerDuration = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalReportCriteria == 8 ) {

        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0 */
static void
decode_org_csapi_cc_TpCallAdditionalEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAdditionalEventInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAdditionalEventInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAdditionalEventInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallEventType:1.0
     */

    disc_s_TpCallAdditionalEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAdditionalEventInfo == 3 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 4 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 5 ) {

        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 6 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"OriginatingReleaseCause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 11 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"TerminatingReleaseCause  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 12 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAdditionalEventInfo == 13 ) {

        /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

        

        decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0 */
static void
decode_org_csapi_cc_TpAdditionalCallEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAdditionalCallEventCriteria;
    guint32   u_octet4_loop_OriginatingServiceCode;
    guint32   i_OriginatingServiceCode;
    guint32   u_octet4_loop_OriginatingReleaseCauseSet;
    guint32   i_OriginatingReleaseCauseSet;
    guint32   u_octet4_loop_TerminatingReleaseCauseSet;
    guint32   i_TerminatingReleaseCauseSet;
    guint32   u_octet4_loop_TerminatingServiceCode;
    guint32   i_TerminatingServiceCode;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpAdditionalCallEventCriteria:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAdditionalCallEventCriteria  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallEventType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallEventType:1.0
     */

    disc_s_TpAdditionalCallEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAdditionalCallEventCriteria == 3 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MinAddressLength = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAdditionalCallEventCriteria == 5 ) {

        u_octet4_loop_OriginatingServiceCode = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OriginatingServiceCode = %u",u_octet4_loop_OriginatingServiceCode);
        }

        for (i_OriginatingServiceCode=0; i_OriginatingServiceCode < u_octet4_loop_OriginatingServiceCode; i_OriginatingServiceCode++) {

            /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

            

            decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAdditionalCallEventCriteria == 6 ) {

        u_octet4_loop_OriginatingReleaseCauseSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OriginatingReleaseCauseSet = %u",u_octet4_loop_OriginatingReleaseCauseSet);
        }

        for (i_OriginatingReleaseCauseSet=0; i_OriginatingReleaseCauseSet < u_octet4_loop_OriginatingReleaseCauseSet; i_OriginatingReleaseCauseSet++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"OriginatingReleaseCauseSet  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAdditionalCallEventCriteria == 11 ) {

        u_octet4_loop_TerminatingReleaseCauseSet = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TerminatingReleaseCauseSet = %u",u_octet4_loop_TerminatingReleaseCauseSet);
        }

        for (i_TerminatingReleaseCauseSet=0; i_TerminatingReleaseCauseSet < u_octet4_loop_TerminatingReleaseCauseSet; i_TerminatingReleaseCauseSet++) {

            
            u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-4,4,"TerminatingReleaseCauseSet  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpReleaseCause,"Unknown Enum Value"));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAdditionalCallEventCriteria == 13 ) {

        u_octet4_loop_TerminatingServiceCode = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of TerminatingServiceCode = %u",u_octet4_loop_TerminatingServiceCode);
        }

        for (i_TerminatingServiceCode=0; i_TerminatingServiceCode < u_octet4_loop_TerminatingServiceCode; i_TerminatingServiceCode++) {

            /*  Begin struct "org_csapi_cc_TpCallServiceCode"  */

            

            decode_org_csapi_cc_TpCallServiceCode_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCallServiceCode"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/TpCallAppInfo:1.0 */
static void
decode_org_csapi_cc_TpCallAppInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpCallAppInfo;
    guint32   u_octet4_loop_CallAppCarrier;
    guint32   i_CallAppCarrier;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/TpCallAppInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpCallAppInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallAppInfoType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/TpCallAppInfoType:1.0
     */

    disc_s_TpCallAppInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpCallAppInfo == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppAlertingMechanism = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 2 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppNetworkAccessType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallNetworkAccessType,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 3 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppTeleService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallTeleService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 4 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppBearerService  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallBearerService,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 5 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallAppPartyCategory  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_TpCallPartyCategory,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 6 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 7 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "CallAppGenericInfo");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 8 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 9 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 10 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 11 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"CallHighProbabilityCompletion = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpCallAppInfo == 12 ) {

        u_octet4_loop_CallAppCarrier = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of CallAppCarrier = %u",u_octet4_loop_CallAppCarrier);
        }

        for (i_CallAppCarrier=0; i_CallAppCarrier < u_octet4_loop_CallAppCarrier; i_CallAppCarrier++) {

            /*  Begin struct "org_csapi_cc_TpCarrier"  */

            

            decode_org_csapi_cc_TpCarrier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_cc_TpCarrier"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0 */
static void
decode_org_csapi_cc_mpccs_TpAppMultiPartyCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppMultiPartyCallBack;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBack:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAppMultiPartyCallBack  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mpccs_TpAppMultiPartyCallBackRefType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mpccs/TpAppMultiPartyCallBackRefType:1.0
     */

    disc_s_TpAppMultiPartyCallBack = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppMultiPartyCallBack == 1 ) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAppMultiPartyCallBack == 2 ) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAppMultiPartyCallBack == 3 ) {

        /*  Begin struct "org_csapi_cc_mpccs_TpAppCallLegCallBack"  */

        

        decode_org_csapi_cc_mpccs_TpAppCallLegCallBack_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpAppCallLegCallBack"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0 */
static void
decode_org_csapi_cc_mmccs_TpMediaStreamDataTypeRequest_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMediaStreamDataTypeRequest;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequest:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMediaStreamDataTypeRequest  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpMediaStreamDataTypeRequestType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mmccs/TpMediaStreamDataTypeRequestType:1.0
     */

    disc_s_TpMediaStreamDataTypeRequest = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMediaStreamDataTypeRequest == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Audio = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMediaStreamDataTypeRequest == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Video = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMediaStreamDataTypeRequest == 2 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Data = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0 */
static void
decode_org_csapi_cc_mmccs_TpAppMultiMediaCallBack_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppMultiMediaCallBack;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBack:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAppMultiMediaCallBack  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_mmccs_TpAppMultiMediaCallBackRefType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/mmccs/TpAppMultiMediaCallBackRefType:1.0
     */

    disc_s_TpAppMultiMediaCallBack = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppMultiMediaCallBack == 1 ) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAppMultiMediaCallBack == 2 ) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpAppMultiMediaCallBack == 3 ) {

        /*  Begin struct "org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack"  */

        

        decode_org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mmccs_TpAppMultiMediaCallLegCallBack"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cc/cccs/TpConfPolicy:1.0 */
static void
decode_org_csapi_cc_cccs_TpConfPolicy_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpConfPolicy;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cc/cccs/TpConfPolicy:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpConfPolicy  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cc_cccs_TpConfPolicyType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cc/cccs/TpConfPolicyType:1.0
     */

    disc_s_TpConfPolicy = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpConfPolicy == 1 ) {

        /*  Begin struct "org_csapi_cc_cccs_TpMonoMediaConfPolicy"  */

        

        decode_org_csapi_cc_cccs_TpMonoMediaConfPolicy_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpMonoMediaConfPolicy"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpConfPolicy == 2 ) {

        /*  Begin struct "org_csapi_cc_cccs_TpMultiMediaConfPolicy"  */

        

        decode_org_csapi_cc_cccs_TpMultiMediaConfPolicy_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_cccs_TpMultiMediaConfPolicy"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/ui/TpUITargetObject:1.0 */
static void
decode_org_csapi_ui_TpUITargetObject_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpUITargetObject;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/ui/TpUITargetObject:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpUITargetObject  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_ui_TpUITargetObjectType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/ui/TpUITargetObjectType:1.0
     */

    disc_s_TpUITargetObject = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpUITargetObject == 0 ) {

        /*  Begin struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        

        decode_org_csapi_cc_gccs_TpCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_gccs_TpCallIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUITargetObject == 1 ) {

        /*  Begin struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpMultiPartyCallIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpMultiPartyCallIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpUITargetObject == 2 ) {

        /*  Begin struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        

        decode_org_csapi_cc_mpccs_TpCallLegIdentifier_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_cc_mpccs_TpCallLegIdentifier"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/mm/TpBindingEntry:1.0 */
static void
decode_org_csapi_mm_TpBindingEntry_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpBindingEntry;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mm/TpBindingEntry:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpBindingEntry  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mm_TpBindingEntryType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mm/TpBindingEntryType:1.0
     */

    disc_s_TpBindingEntry = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpBindingEntry == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UBExpires = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpBindingEntry == 2 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpBindingEntry == 3 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"UBPreference = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionChargeOrder_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionChargeOrder;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionChargeOrder:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionChargeOrder  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionChargeOrderCategory,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionChargeOrderCategory:1.0
     */

    disc_s_TpDataSessionChargeOrder = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionChargeOrder == 0 ) {

        /*  Begin struct "org_csapi_dsc_TpChargePerVolume"  */

        

        decode_org_csapi_dsc_TpChargePerVolume_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpChargePerVolume"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpDataSessionChargeOrder == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "NetworkCharge");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionAdditionalErrorInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionAdditionalErrorInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionAdditionalErrorInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionAdditionalErrorInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionErrorType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionErrorType:1.0
     */

    disc_s_TpDataSessionAdditionalErrorInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionAdditionalErrorInfo == 1 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"DataSessionErrorInvalidAddress  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpAddressError,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0 */
static void
decode_org_csapi_dsc_TpDataSessionAdditionalReportInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDataSessionAdditionalReportInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/dsc/TpDataSessionAdditionalReportInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDataSessionAdditionalReportInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_dsc_TpDataSessionReportType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/dsc/TpDataSessionReportType:1.0
     */

    disc_s_TpDataSessionAdditionalReportInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDataSessionAdditionalReportInfo == 2 ) {

        /*  Begin struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        

        decode_org_csapi_dsc_TpDataSessionReleaseCause_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_dsc_TpDataSessionReleaseCause"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/gms/TpMessageInfoProperty:1.0 */
static void
decode_org_csapi_gms_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessageInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessageInfoPropertyName:1.0
     */

    disc_s_TpMessageInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageInfoProperty == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageSubject");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageDateSent");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageDateReceived");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 5 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 6 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 7 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 8 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 9 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 10 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessagingMessageSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 11 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessagingMessagePriority  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagePriority,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 12 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessagingMessageFormat  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageFormat,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 13 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMessageFolder");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 14 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessagingMessageStatus  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessageStatus,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/gms/TpMailboxInfoProperty:1.0 */
static void
decode_org_csapi_gms_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMailboxInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMailboxInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMailboxInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMailboxInfoPropertyName:1.0
     */

    disc_s_TpMailboxInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMailboxInfoProperty == 1 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMailboxOwner");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMailboxFolder");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMailboxDateCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 5 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingMailboxDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/gms/TpMessagingEventInfo:1.0 */
static void
decode_org_csapi_gms_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessagingEventInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingEventInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessagingEventName:1.0
     */

    disc_s_TpMessagingEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventInfo == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "EventNameUndefined");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessagingEventInfo == 1 ) {

        /*  Begin struct "org_csapi_gms_TpGMSNewMessageArrivedInfo"  */

        

        decode_org_csapi_gms_TpGMSNewMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_gms_TpGMSNewMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/gms/TpMessagingEventCriteria:1.0 */
static void
decode_org_csapi_gms_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventCriteria;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpMessagingEventCriteria:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingEventCriteria  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpMessagingEventName:1.0
     */

    disc_s_TpMessagingEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventCriteria == 1 ) {

        /*  Begin struct "org_csapi_gms_TpGMSNewMessageArrivedCriteria"  */

        

        decode_org_csapi_gms_TpGMSNewMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_gms_TpGMSNewMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/gms/TpFolderInfoProperty:1.0 */
static void
decode_org_csapi_gms_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFolderInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/gms/TpFolderInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFolderInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_gms_TpFolderInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/gms/TpFolderInfoPropertyName:1.0
     */

    disc_s_TpFolderInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFolderInfoProperty == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingFolderID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingFolderMessage");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingFolderSubfolder");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingFolderDateCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 5 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessagingFolderDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/cs/TpChargingParameterValue:1.0 */
static void
decode_org_csapi_cs_TpChargingParameterValue_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpChargingParameterValue;
    guint32   u_octet4_loop_OctetValue;
    guint32   i_OctetValue;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cs/TpChargingParameterValue:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpChargingParameterValue  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpChargingParameterValueType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cs/TpChargingParameterValueType:1.0
     */

    disc_s_TpChargingParameterValue = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpChargingParameterValue == 0 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"IntValue = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpChargingParameterValue == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FloatValue = %.6e",get_CDR_float(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpChargingParameterValue == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "StringValue");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpChargingParameterValue == 3 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-1,1,"BooleanValue = %u",get_CDR_boolean(tvb,offset));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpChargingParameterValue == 4 ) {

        u_octet4_loop_OctetValue = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of OctetValue = %u",u_octet4_loop_OctetValue);
        }

        for (i_OctetValue=0; i_OctetValue < u_octet4_loop_OctetValue; i_OctetValue++) {

            if (tree) {
               proto_tree_add_text(tree,tvb,*offset-1,1,"OctetValue = %u",get_CDR_octet(tvb,offset));
            }

        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/cs/TpAppInformation:1.0 */
static void
decode_org_csapi_cs_TpAppInformation_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpAppInformation;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/cs/TpAppInformation:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpAppInformation  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_cs_TpAppInformationType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/cs/TpAppInformationType:1.0
     */

    disc_s_TpAppInformation = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpAppInformation == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "Timestamp");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/policy/TpPolicyType:1.0 */
static void
decode_org_csapi_policy_TpPolicyType_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPolicyType;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/policy/TpPolicyType:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPolicyType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_policy_TpPolicyTypeInfo,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/policy/TpPolicyTypeInfo:1.0
     */

    disc_s_TpPolicyType = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPolicyType == 0 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"SimpleType  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_TpSimpleAttributeTypeInfo,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPolicyType == 1 ) {

        /*  Begin struct "org_csapi_policy_TpPolicyType_TpPolicyRecordType"  */

        

        decode_org_csapi_policy_TpPolicyType_TpPolicyRecordType_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_policy_TpPolicyType_TpPolicyRecordType"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPolicyType == 2 ) {

        /*  Begin struct "org_csapi_policy_TpPolicyType_TpPolicyListType"  */

        

        decode_org_csapi_policy_TpPolicyType_TpPolicyListType_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_policy_TpPolicyType_TpPolicyListType"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPolicyType == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "StructuredType");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPolicyType == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "XMLString");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/pam/TpPAMContextData:1.0 */
static void
decode_org_csapi_pam_TpPAMContextData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMContextData;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMContextData:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMContextData  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMContextName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMContextName:1.0
     */

    disc_s_TpPAMContextData = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMContextData == 1 ) {

        /*  Begin struct "org_csapi_pam_TpPAMCommunicationContext"  */

        

        decode_org_csapi_pam_TpPAMCommunicationContext_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMCommunicationContext"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/pam/TpPAMEventInfo:1.0 */
static void
decode_org_csapi_pam_TpPAMEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMEventInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMEventInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMEventInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMEventName:1.0
     */

    disc_s_TpPAMEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMEventInfo == 0 ) {

        /*  Begin struct "org_csapi_pam_TpPAMIPSEventData"  */

        

        decode_org_csapi_pam_TpPAMIPSEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMIPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 1 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAVCEventData"  */

        

        decode_org_csapi_pam_TpPAMAVCEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAVCEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 2 ) {

        /*  Begin struct "org_csapi_pam_TpPAMWCEventData"  */

        

        decode_org_csapi_pam_TpPAMWCEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMWCEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 3 ) {

        /*  Begin struct "org_csapi_pam_TpPAMICEventData"  */

        

        decode_org_csapi_pam_TpPAMICEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMICEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 4 ) {

        /*  Begin struct "org_csapi_pam_TpPAMIDEventData"  */

        

        decode_org_csapi_pam_TpPAMIDEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMIDEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 5 ) {

        /*  Begin struct "org_csapi_pam_TpPAMGMCEventData"  */

        

        decode_org_csapi_pam_TpPAMGMCEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMGMCEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 6 ) {

        /*  Begin struct "org_csapi_pam_TpPAMACEventData"  */

        

        decode_org_csapi_pam_TpPAMACEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMACEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 7 ) {

        /*  Begin struct "org_csapi_pam_TpPAMADEventData"  */

        

        decode_org_csapi_pam_TpPAMADEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMADEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 8 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAAEventData"  */

        

        decode_org_csapi_pam_TpPAMAAEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAAEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 9 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAUEventData"  */

        

        decode_org_csapi_pam_TpPAMAUEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAUEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 10 ) {

        /*  Begin struct "org_csapi_pam_TpPAMCCEventData"  */

        

        decode_org_csapi_pam_TpPAMCCEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMCCEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 11 ) {

        /*  Begin struct "org_csapi_pam_TpPAMACPSEventData"  */

        

        decode_org_csapi_pam_TpPAMACPSEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMACPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMEventInfo == 12 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAPSEventData"  */

        

        decode_org_csapi_pam_TpPAMAPSEventData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAPSEventData"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/pam/TpPAMNotificationInfo:1.0 */
static void
decode_org_csapi_pam_TpPAMNotificationInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMNotificationInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMNotificationInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMNotificationInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMEventName:1.0
     */

    disc_s_TpPAMNotificationInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMNotificationInfo == 0 ) {

        /*  Begin struct "org_csapi_pam_TpPAMIPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMIPSNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMIPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 1 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAVCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAVCNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAVCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 2 ) {

        /*  Begin struct "org_csapi_pam_TpPAMWCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMWCNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMWCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 3 ) {

        /*  Begin struct "org_csapi_pam_TpPAMICNotificationData"  */

        

        decode_org_csapi_pam_TpPAMICNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMICNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 4 ) {

        /*  Begin struct "org_csapi_pam_TpPAMIDNotificationData"  */

        

        decode_org_csapi_pam_TpPAMIDNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMIDNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 5 ) {

        /*  Begin struct "org_csapi_pam_TpPAMGMCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMGMCNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMGMCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 6 ) {

        /*  Begin struct "org_csapi_pam_TpPAMACNotificationData"  */

        

        decode_org_csapi_pam_TpPAMACNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMACNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 7 ) {

        /*  Begin struct "org_csapi_pam_TpPAMADNotificationData"  */

        

        decode_org_csapi_pam_TpPAMADNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMADNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 8 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAANotificationData"  */

        

        decode_org_csapi_pam_TpPAMAANotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAANotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 9 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAUNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAUNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAUNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 10 ) {

        /*  Begin struct "org_csapi_pam_TpPAMCCNotificationData"  */

        

        decode_org_csapi_pam_TpPAMCCNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMCCNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 11 ) {

        /*  Begin struct "org_csapi_pam_TpPAMACPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMACPSNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMACPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpPAMNotificationInfo == 12 ) {

        /*  Begin struct "org_csapi_pam_TpPAMAPSNotificationData"  */

        

        decode_org_csapi_pam_TpPAMAPSNotificationData_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_pam_TpPAMAPSNotificationData"  */

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/pam/TpPAMPreferenceData:1.0 */
static void
decode_org_csapi_pam_TpPAMPreferenceData_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpPAMPreferenceData;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/pam/TpPAMPreferenceData:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpPAMPreferenceData  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_pam_TpPAMPreferenceType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/pam/TpPAMPreferenceType:1.0
     */

    disc_s_TpPAMPreferenceData = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpPAMPreferenceData == 1 ) {

        get_CDR_object(tvb, pinfo, tree, offset, stream_is_big_endian, boundary);


        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpFolderInfoProperty:1.0 */
static void
decode_org_csapi_mmm_TpFolderInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpFolderInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpFolderInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpFolderInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpFolderInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpFolderInfoPropertyName:1.0
     */

    disc_s_TpFolderInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpFolderInfoProperty == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "FolderDateCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "FolderDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 3 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FolderSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpFolderInfoProperty == 4 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"FolderNumberOfMessages = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0 */
static void
decode_org_csapi_mmm_TpMailboxInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMailboxInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMailboxInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMailboxInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMailboxInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMailboxInfoPropertyName:1.0
     */

    disc_s_TpMailboxInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMailboxInfoProperty == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MailboxOwner");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MailboxDateCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MailboxDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMailboxInfoProperty == 4 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MailboxSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpMessageInfoProperty:1.0 */
static void
decode_org_csapi_mmm_TpMessageInfoProperty_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageInfoProperty;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageInfoProperty:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageInfoProperty  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageInfoPropertyName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageInfoPropertyName:1.0
     */

    disc_s_TpMessageInfoProperty = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageInfoProperty == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessageDateCreated");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessageDateReceived");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 3 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MessageDateChanged");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 4 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessageSize = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageInfoProperty == 5 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"MessageStatus  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMailboxMessageStatus,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpMessageHeaderField:1.0 */
static void
decode_org_csapi_mmm_TpMessageHeaderField_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageHeaderField;
    guint32   u_octet4_loop_From;
    guint32   i_From;
    guint32   u_octet4_loop_ReplyTo;
    guint32   i_ReplyTo;
    guint32   u_octet4_loop_To;
    guint32   i_To;
    guint32   u_octet4_loop_Cc;
    guint32   i_Cc;
    guint32   u_octet4_loop_Bcc;
    guint32   i_Bcc;
    guint32   u_octet4_loop_InReplyTo;
    guint32   i_InReplyTo;
    guint32   u_octet4_loop_References;
    guint32   i_References;
    guint32   u_octet4_loop_Keywords;
    guint32   i_Keywords;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageHeaderField:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageHeaderField  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageHeaderFieldType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageHeaderFieldType:1.0
     */

    disc_s_TpMessageHeaderField = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageHeaderField == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "DateSent");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 1 ) {

        u_octet4_loop_From = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of From = %u",u_octet4_loop_From);
        }

        for (i_From=0; i_From < u_octet4_loop_From; i_From++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 2 ) {

        /*  Begin struct "org_csapi_TpAddress"  */

        

        decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_TpAddress"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 3 ) {

        u_octet4_loop_ReplyTo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of ReplyTo = %u",u_octet4_loop_ReplyTo);
        }

        for (i_ReplyTo=0; i_ReplyTo < u_octet4_loop_ReplyTo; i_ReplyTo++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 4 ) {

        u_octet4_loop_To = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of To = %u",u_octet4_loop_To);
        }

        for (i_To=0; i_To < u_octet4_loop_To; i_To++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 5 ) {

        u_octet4_loop_Cc = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Cc = %u",u_octet4_loop_Cc);
        }

        for (i_Cc=0; i_Cc < u_octet4_loop_Cc; i_Cc++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 6 ) {

        u_octet4_loop_Bcc = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Bcc = %u",u_octet4_loop_Bcc);
        }

        for (i_Bcc=0; i_Bcc < u_octet4_loop_Bcc; i_Bcc++) {

            /*  Begin struct "org_csapi_TpAddress"  */

            

            decode_org_csapi_TpAddress_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

            /*  End struct "org_csapi_TpAddress"  */

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 7 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "RFC822MessageID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 8 ) {

        u_octet4_loop_InReplyTo = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of InReplyTo = %u",u_octet4_loop_InReplyTo);
        }

        for (i_InReplyTo=0; i_InReplyTo < u_octet4_loop_InReplyTo; i_InReplyTo++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "InReplyTo");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 9 ) {

        u_octet4_loop_References = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of References = %u",u_octet4_loop_References);
        }

        for (i_References=0; i_References < u_octet4_loop_References; i_References++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "References");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 10 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "Subject");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 11 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "Comments");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 12 ) {

        u_octet4_loop_Keywords = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4, 4 ,"Seq length of Keywords = %u",u_octet4_loop_Keywords);
        }

        for (i_Keywords=0; i_Keywords < u_octet4_loop_Keywords; i_Keywords++) {

            giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "Keywords");

        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 13 ) {

        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 14 ) {

        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 15 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeVersion");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 16 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeContent");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 17 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeEncoding");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 18 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 19 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeDescription");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 20 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "MimeDisposition");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 21 ) {

        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 22 ) {

        /*  Begin struct "org_csapi_mmm_TpGenericHeaderField"  */

        

        decode_org_csapi_mmm_TpGenericHeaderField_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpGenericHeaderField"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageHeaderField == 23 ) {

        
        u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"Priority  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagePriority,"Unknown Enum Value"));
        }

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/mmm/TpDeliveryTime:1.0 */
static void
decode_org_csapi_mmm_TpDeliveryTime_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpDeliveryTime;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpDeliveryTime:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpDeliveryTime  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpDeliveryTimeType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpDeliveryTimeType:1.0
     */

    disc_s_TpDeliveryTime = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpDeliveryTime == 1 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "DeliveryTime");

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpMessageTreatment:1.0 */
static void
decode_org_csapi_mmm_TpMessageTreatment_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessageTreatment;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessageTreatment:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessageTreatment  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessageTreatmentType,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessageTreatmentType:1.0
     */

    disc_s_TpMessageTreatment = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessageTreatment == 1 ) {

        if (tree) {
           proto_tree_add_text(tree,tvb,*offset-4,4,"DeliveryReport = %i",get_CDR_long(tvb,offset,stream_is_big_endian, boundary));
        }

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageTreatment == 2 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "BillingID");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageTreatment == 3 ) {

        /*  Begin union "org_csapi_mmm_TpDeliveryTime"  */

        
        decode_org_csapi_mmm_TpDeliveryTime_un(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End union "org_csapi_mmm_TpDeliveryTime"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessageTreatment == 4 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "ValidityTime");

        return;     /* End Compare for this discriminant type */
    }

}

/* Union = IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0 */
static void
decode_org_csapi_mmm_TpMessagingEventCriteria_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventCriteria;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessagingEventCriteria:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingEventCriteria  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessagingEventName:1.0
     */

    disc_s_TpMessagingEventCriteria = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventCriteria == 1 ) {

        /*  Begin struct "org_csapi_mmm_TpNewMailboxMessageArrivedCriteria"  */

        

        decode_org_csapi_mmm_TpNewMailboxMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpNewMailboxMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessagingEventCriteria == 2 ) {

        /*  Begin struct "org_csapi_mmm_TpNewMessageArrivedCriteria"  */

        

        decode_org_csapi_mmm_TpNewMessageArrivedCriteria_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpNewMessageArrivedCriteria"  */

        return;     /* End Compare for this discriminant type */
    }

    
    /* Default Union Case Start */

    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-2,2,"Dummy = %i",get_CDR_short(tvb,offset,stream_is_big_endian, boundary));
    }

    /* Default Union Case End */

}

/* Union = IDL:org/csapi/mmm/TpMessagingEventInfo:1.0 */
static void
decode_org_csapi_mmm_TpMessagingEventInfo_un(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_, int *offset _U_, MessageHeader *header _U_, gchar *operation _U_, gboolean stream_is_big_endian _U_)
{

    
    /* Operation specific Variable declarations Begin */

    guint32   u_octet4;
    gint32    disc_s_TpMessagingEventInfo;
    
    /* Operation specific Variable declarations End */

    /*
     * IDL Union Start - IDL:org/csapi/mmm/TpMessagingEventInfo:1.0
     */

    
    u_octet4 = get_CDR_enum(tvb,offset,stream_is_big_endian, boundary);
    if (tree) {
       proto_tree_add_text(tree,tvb,*offset-4,4,"TpMessagingEventInfo  = %u (%s)",u_octet4,val_to_str(u_octet4,org_csapi_mmm_TpMessagingEventName,"Unknown Enum Value"));
    }

    /*
     * IDL Union - Discriminant - IDL:org/csapi/mmm/TpMessagingEventName:1.0
     */

    disc_s_TpMessagingEventInfo = (gint32) u_octet4;     /* save Enum Value  discriminant and cast to gint32 */

    if (disc_s_TpMessagingEventInfo == 0 ) {

        giop_add_CDR_string(tree, tvb, offset, stream_is_big_endian, boundary, "EventNameUndefined");

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessagingEventInfo == 1 ) {

        /*  Begin struct "org_csapi_mmm_TpNewMailboxMessageArrivedInfo"  */

        

        decode_org_csapi_mmm_TpNewMailboxMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpNewMailboxMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }

    if (disc_s_TpMessagingEventInfo == 2 ) {

        /*  Begin struct "org_csapi_mmm_TpNewMessageArrivedInfo"  */

        

        decode_org_csapi_mmm_TpNewMessageArrivedInfo_st(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);

        /*  End struct "org_csapi_mmm_TpNewMessageArrivedInfo"  */

        return;     /* End Compare for this discriminant type */
    }

}

/*
 * Called once we accept the packet as being for us; it sets the
 * Protocol and Info columns and creates the top-level protocol
 * tree item.
 */
static proto_tree *
start_dissecting(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset)
{

    proto_item *ti = NULL;
    proto_tree *tree = NULL;            /* init later, inside if(tree) */

    col_set_str(pinfo->cinfo, COL_PROTOCOL, "PARLAY");

    /*
     * Do not clear COL_INFO, as nothing is being written there by
     * this dissector yet. So leave it as is from the GIOP dissector.
     * TODO: add something useful to COL_INFO
     *     col_clear(pinfo->cinfo, COL_INFO);
     */

    if (ptree) {
        ti = proto_tree_add_item(ptree, proto_parlay, tvb, *offset, -1, ENC_NA);
        tree = proto_item_add_subtree(ti, ett_parlay);
    }
    return tree;
}

static gboolean
dissect_parlay(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset, MessageHeader *header, gchar *operation, gchar *idlname)
{

    gboolean stream_is_big_endian;                        /* big endianess */
    proto_tree *tree _U_;
#define process_RequestOperation(){ \
		proto_item *pi; \
     	if(header->message_type == Reply){ col_append_fstr(pinfo->cinfo, COL_INFO, " op = %s",operation); }; /* fill-up info column */ \
	    pi=proto_tree_add_string_format_value(ptree,hf_operationrequest,tvb,0,0,operation," %s",operation);PROTO_ITEM_SET_GENERATED(pi); /* fill-up the field */ \
   };

    stream_is_big_endian = is_big_endian(header);         /* get endianess  */

    /* If we have a USER Exception, then decode it and return */

    if ((header->message_type == Reply) && (header->rep_status == USER_EXCEPTION)) {

       return decode_user_exception(tvb, pinfo, ptree, offset, header, operation, stream_is_big_endian);

    }

    switch(header->message_type) {

    case Request:
    case Reply:

        if (strcmp(operation, "setCallback") == 0
            && (!idlname || strcmp(idlname, "org/csapi/IpService") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_IpService_setCallback(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCallbackWithSessionID") == 0
            && (!idlname || strcmp(idlname, "org/csapi/IpService") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_IpService_setCallbackWithSessionID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "initiateAuthentication") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpInitial") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthentication(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "initiateAuthenticationWithVersion") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpInitial") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpInitial_initiateAuthenticationWithVersion(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "requestAccess") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAuthentication_requestAccess(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateAccess") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAccess_terminateAccess(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "obtainInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "obtainInterfaceWithCallback") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_obtainInterfaceWithCallback(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "endAccess") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_endAccess(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listInterfaces") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_listInterfaces(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "releaseInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_releaseInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "selectSigningAlgorithm") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_selectSigningAlgorithm(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateAccess") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_terminateAccess(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "relinquishInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAccess") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAccess_relinquishInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "authenticate") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticate(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortAuthentication") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_abortAuthentication(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "authenticationSucceeded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_authenticationSucceeded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "challenge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpClientAPILevelAuthentication_challenge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "selectEncryptionMethod") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectEncryptionMethod(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "authenticate") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticate(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortAuthentication") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_abortAuthentication(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "authenticationSucceeded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_authenticationSucceeded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "selectAuthenticationMechanism") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_selectAuthenticationMechanism(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "challenge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_access_trust_and_security_IpAPILevelAuthentication_challenge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpAppEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "notificationTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpAppEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpAppEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/notification/IpEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_notification_IpEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appActivityTestReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appActivityTestReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwFaultReportInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultReportInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwFaultRecoveryInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwFaultRecoveryInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_activityTestErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_svcAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppFaultManager_fwAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "loadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_loadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "resumeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "suspendNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadStatsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryAppLoadStatsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppLoadManager_queryLoadStatsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportLoad") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_reportLoad(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "resumeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "suspendNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryLoadStatsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadStatsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryAppLoadStatsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpLoadManager_queryAppLoadStatsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "systemDateTimeQuery") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppOAM") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "systemDateTimeQuery") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpOAM") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_activityTestReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appActivityTestRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appActivityTestErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appActivityTestErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_appAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_enableHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_disableHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeInterval") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "pulse") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeat") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "pulse") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpHeartBeat") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableAppHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_enableAppHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableAppHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_disableAppHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeInterval") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_integrity_IpAppHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listServiceTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listServiceTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeServiceType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_describeServiceType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "discoverService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_discoverService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listSubscribedServices") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/discovery/IpServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_discovery_IpServiceDiscovery_listSubscribedServices(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "signServiceAgreement") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_signServiceAgreement(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateServiceAgreement") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpAppServiceAgreementManagement_terminateServiceAgreement(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "signServiceAgreement") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_signServiceAgreement(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateServiceAgreement") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_terminateServiceAgreement(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "selectService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_selectService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "initiateSignServiceAgreement") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_application_service_agreement_IpServiceAgreementManagement_initiateSignServiceAgreement(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createServiceProfile") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_createServiceProfile(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "modifyServiceProfile") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_modifyServiceProfile(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteServiceProfile") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deleteServiceProfile(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "assign") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_assign(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deassign") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_deassign(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "requestConflictInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileManagement_requestConflictInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listServiceProfiles") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listServiceProfiles(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeServiceProfile") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_describeServiceProfile(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAssignedMembers") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceProfileInfoQuery_listAssignedMembers(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createServiceContract") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_createServiceContract(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "modifyServiceContract") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_modifyServiceContract(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteServiceContract") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractManagement_deleteServiceContract(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeServiceContract") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_describeServiceContract(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listServiceContracts") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceContracts(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listServiceProfiles") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpServiceContractInfoQuery_listServiceProfiles(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "modifyEntOpAccount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_modifyEntOpAccount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteEntOpAccount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountManagement_deleteEntOpAccount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeEntOpAccount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpEntOpAccountInfoQuery_describeEntOpAccount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createClientApp") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createClientApp(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "modifyClientApp") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifyClientApp(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteClientApp") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteClientApp(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createSAG") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_createSAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "modifySAG") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_modifySAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteSAG") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_deleteSAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addSAGMembers") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_addSAGMembers(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeSAGMembers") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_removeSAGMembers(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "requestConflictInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppManagement_requestConflictInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeClientApp") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeClientApp(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listClientApps") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientApps(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeSAG") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_describeSAG(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listSAGs") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGs(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listSAGMembers") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listSAGMembers(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listClientAppMembership") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_service_subscription_IpClientAppInfoQuery_listClientAppMembership(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "notificationTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpClientEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_enterprise_operator_notification_IpEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listServiceTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listServiceTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeServiceType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_describeServiceType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "discoverService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_discoverService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listRegisteredServices") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_discovery_IpFwServiceDiscovery_listRegisteredServices(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createServiceManager") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_createServiceManager(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyServiceManager") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_lifecycle_IpServiceInstanceLifecycleManager_destroyServiceManager(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "registerService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "announceServiceAvailability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_announceServiceAvailability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unregisterService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unregisterService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "describeService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_describeService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unannounceService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_unannounceService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "registerServiceSubType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_service_registration_IpFwServiceRegistration_registerServiceSubType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "loadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_loadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "suspendNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "resumeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadStatsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_querySvcLoadStatsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcLoadManager_queryLoadStatsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportLoad") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_reportLoad(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_createLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyLoadLevelNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_destroyLoadLevelNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "suspendNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_suspendNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "resumeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_resumeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryLoadStatsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_queryLoadStatsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadStatsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "querySvcLoadStatsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwLoadManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwLoadManager_querySvcLoadStatsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcActivityTestReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcActivityTestReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwFaultReportInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultReportInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwFaultRecoveryInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwFaultRecoveryInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_activityTestErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_appAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "fwAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcFaultManager_fwAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activityTestReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_activityTestReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcActivityTestRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_appUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcUnavailableInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcUnavailableInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcActivityTestErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcActivityTestErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "genFaultStatsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_genFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "svcAvailStatusInd") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_svcAvailStatusInd(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateFaultStatisticsRecordErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwFaultManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwFaultManager_generateFaultStatisticsRecordErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "systemDateTimeQuery") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcOAM") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "systemDateTimeQuery") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwOAM") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwOAM_systemDateTimeQuery(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_enableHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_disableHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeInterval") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "pulse") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeat") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "pulse") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpFwHeartBeat") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpFwHeartBeat_pulse(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableSvcHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_enableSvcHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableSvcHeartBeat") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_disableSvcHeartBeat(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeInterval") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_integrity_IpSvcHeartBeatMgmt_changeInterval(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpFwEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpFwEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpFwEventNotification_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpSvcEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "notificationTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/fw/fw_service/notification/IpSvcEventNotification") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_fw_fw_service_notification_IpSvcEventNotification_notificationTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "routeRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_routeRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "routeErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_routeErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCallInfoRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getCallInfoRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCallInfoErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getCallInfoErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseCallRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_superviseCallRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseCallErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_superviseCallErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callFaultDetected") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_callFaultDetected(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMoreDialledDigitsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMoreDialledDigitsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_getMoreDialledDigitsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callEnded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCall_callEnded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "routeReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_routeReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deassignCall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_deassignCall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCallInfoReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_getCallInfoReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCallChargePlan") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_setCallChargePlan(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAdviceOfCharge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMoreDialledDigitsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_getMoreDialledDigitsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseCallReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_superviseCallReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "continueProcessing") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCall_continueProcessing(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callAborted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callAborted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callEventNotify") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callEventNotify(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callNotificationInterrupted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationInterrupted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callNotificationContinued") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callNotificationContinued(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callOverloadEncountered") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadEncountered(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callOverloadCeased") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_callOverloadCeased(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortMultipleCalls") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpAppCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpAppCallControlManager_abortMultipleCalls(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_createCall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableCallNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_enableCallNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableCallNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_disableCallNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCallLoadControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_setCallLoadControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeCallNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_changeCallNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCriteria") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/gccs/IpCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_gccs_IpCallControlManager_getCriteria(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "eventReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "eventReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_eventReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "attachMediaRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "attachMediaErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_attachMediaErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "detachMediaRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "detachMediaErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_detachMediaErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_getInfoErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "routeErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_routeErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_superviseErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callLegEnded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppCallLeg_callLegEnded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createCall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_changeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCallLoadControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_setCallLoadControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_enableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_disableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCallControlManager_getNextNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "routeReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_routeReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "eventReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_eventReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getInfoReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getCall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "attachMediaReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_attachMediaReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "detachMediaReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_detachMediaReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCurrentDestinationAddress") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getCurrentDestinationAddress(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "continueProcessing") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_continueProcessing(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setChargePlan") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setChargePlan(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAdviceOfCharge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_superviseReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deassign") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_deassign(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_getProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpCallLeg_setProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_getInfoErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_superviseErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callEnded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_callEnded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAndRouteCallLegErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCall_createAndRouteCallLegErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCallLegs") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_getCallLegs(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCallLeg") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_createCallLeg(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAndRouteCallLegReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_createAndRouteCallLegReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deassignCall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_deassignCall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_getInfoReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setChargePlan") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_setChargePlan(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAdviceOfCharge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpMultiPartyCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpMultiPartyCall_superviseReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callAborted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callAborted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "managerInterrupted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerInterrupted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "managerResumed") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_managerResumed(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callOverloadEncountered") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadEncountered(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "callOverloadCeased") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_callOverloadCeased(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortMultipleCalls") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mpccs_IpAppMultiPartyCallControlManager_abortMultipleCalls(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseVolumeRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseVolumeErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCall_superviseVolumeErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mediaStreamMonitorRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCallLeg_mediaStreamMonitorRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "subtract") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaStream") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaStream_subtract(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mediaStreamAllow") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamAllow(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mediaStreamMonitorReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_mediaStreamMonitorReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMediaStreams") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallLeg") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallLeg_getMediaStreams(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseVolumeReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCall_superviseVolumeReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportMediaNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpAppMultiMediaCallControlManager_reportMediaNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createMediaNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_createMediaNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyMediaNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_destroyMediaNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeMediaNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_changeMediaNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMediaNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/mmccs/IpMultiMediaCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_mmccs_IpMultiMediaCallControlManager_getMediaNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "chairSelection") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppSubConfCall_chairSelection(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "floorRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppSubConfCall_floorRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "partyJoined") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCall_partyJoined(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "leaveMonitorRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCall_leaveMonitorRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createConference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_createConference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "checkResources") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_checkResources(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveResources") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_reserveResources(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "freeResources") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCallControlManager_freeResources(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "conferenceCreated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpAppConfCallControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpAppConfCallControlManager_conferenceCreated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "splitSubConference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_splitSubConference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mergeSubConference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_mergeSubConference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveCallLeg") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_moveCallLeg(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "inspectVideo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "inspectVideoCancel") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_inspectVideoCancel(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "appointSpeaker") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_appointSpeaker(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "chairSelection") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_chairSelection(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeConferencePolicy") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpSubConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpSubConfCall_changeConferencePolicy(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSubConferences") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_getSubConferences(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createSubConference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_createSubConference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "leaveMonitorReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_leaveMonitorReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConferenceAddress") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cc/cccs/IpConfCall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cc_cccs_IpConfCall_getConferenceAddress(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoAndCollectRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoAndCollectRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoAndCollectErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_sendInfoAndCollectErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "userInteractionFaultDetected") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUI_userInteractionFaultDetected(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "recordMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_recordMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "recordMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_recordMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_deleteMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_deleteMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortActionRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_abortActionRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortActionErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_abortActionErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_getMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUICall_getMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "userInteractionAborted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionAborted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "userInteractionNotificationInterrupted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationInterrupted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "userInteractionNotificationContinued") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_userInteractionNotificationContinued(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportEventNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_reportEventNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortMultipleUserInteractions") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIManager_abortMultipleUserInteractions(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_sendInfoReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendInfoAndCollectReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_sendInfoAndCollectReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setOriginatingAddress") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_setOriginatingAddress(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getOriginatingAddress") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUI") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUI_getOriginatingAddress(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "recordMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_recordMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_deleteMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortActionReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_abortActionReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUICall") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUICall_getMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createUI") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createUI(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createUICall") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createUICall(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_changeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_getNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_enableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIManager_disableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_deleteMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_putMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_putMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageListRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageListRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageListErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpAppUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpAppUIAdminManager_getMessageListErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_getMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_putMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_deleteMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageListReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/ui/IpUIAdminManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_ui_IpUIAdminManager_getMessageListReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_locationReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_locationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedLocationReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_extendedLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppUserLocation_periodicLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_locationReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedLocationReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_extendedLocationReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_periodicLocationReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextPeriodicLocationRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpUserLocation_getNextPeriodicLocationRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppTriggeredUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpAppTriggeredUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpAppTriggeredUserLocation_triggeredLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_triggeredLocationReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextTriggeredLocationRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ul/IpTriggeredUserLocation") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ul_IpTriggeredUserLocation_getNextTriggeredLocationRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_locationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_periodicLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpAppUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpAppUserLocationCamel_triggeredLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "locationReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_locationReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "periodicLocationReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_periodicLocationReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredLocationReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_triggeredLocationReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextPeriodicLocationRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextPeriodicLocationRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextTriggeredLocationRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ulc/IpUserLocationCamel") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ulc_IpUserLocationCamel_getNextTriggeredLocationRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "emergencyLocationReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpAppUserLocationEmergency") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "emergencyLocationReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpAppUserLocationEmergency") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpAppUserLocationEmergency_emergencyLocationReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "emergencyLocationReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_emergencyLocationReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "subscribeEmergencyLocationReports") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_subscribeEmergencyLocationReports(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unSubscribeEmergencyLocationReports") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ule/IpUserLocationEmergency") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ule_IpUserLocationEmergency_unSubscribeEmergencyLocationReports(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "statusReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_statusReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "statusReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_statusReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredStatusReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredStatusReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_triggeredStatusReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedStatusReportRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedStatusReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extendedStatusReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extTriggeredStatusReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extTriggeredStatusReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpAppUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpAppUserStatus_extTriggeredStatusReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "statusReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_statusReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredStatusReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredStatusReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_triggeredStatusReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextTriggeredStatusRequest") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_getNextTriggeredStatusRequest(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendedStatusReportReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extendedStatusReportReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extTriggeredStatusReportingStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extTriggeredStatusReportingStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/us/IpUserStatus") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_us_IpUserStatus_extTriggeredStatusReportingStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredBindingRequestNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpAppUserBinding") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredBindingRequestNotificationStartErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpAppUserBinding") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpAppUserBinding_triggeredBindingRequestNotificationStartErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredBindingRequestNotificationStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpUserBinding") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredBindingRequestNotificationStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mm/ub/IpUserBinding") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mm_ub_IpUserBinding_triggeredBindingRequestNotificationStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getTerminalCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpTerminalCapabilities") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpTerminalCapabilities_getTerminalCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredTerminalCapabilityReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpAppExtendedTerminalCapabilities") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredTerminalCapabilityReportErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpAppExtendedTerminalCapabilities") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpAppExtendedTerminalCapabilities_triggeredTerminalCapabilityReportErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredTerminalCapabilityStartReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpExtendedTerminalCapabilities") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStartReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "triggeredTerminalCapabilityStop") == 0
            && (!idlname || strcmp(idlname, "org/csapi/termcap/IpExtendedTerminalCapabilities") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_termcap_IpExtendedTerminalCapabilities_triggeredTerminalCapabilityStop(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "connectRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_connectRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "connectErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_connectErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseDataSessionRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseDataSessionErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_superviseDataSessionErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "dataSessionFaultDetected") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSession_dataSessionFaultDetected(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "dataSessionAborted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionAborted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "dataSessionNotificationContinued") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationContinued(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "dataSessionNotificationInterrupted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_dataSessionNotificationInterrupted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortMultipleDataSessions") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpAppDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpAppDataSessionControlManager_abortMultipleDataSessions(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "connectReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_connectReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "superviseDataSessionReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_superviseDataSessionReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setDataSessionChargePlan") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_setDataSessionChargePlan(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAdviceOfCharge") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_setAdviceOfCharge(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deassignDataSession") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_deassignDataSession(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "continueProcessing") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSession_continueProcessing(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_changeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_enableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_disableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_getNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/dsc/IpDataSessionControlManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_dsc_IpDataSessionControlManager_createNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "openMailbox") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_openMailbox(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableMessagingNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_enableMessagingNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableMessagingNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessagingManager_disableMessagingNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mailboxTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_mailboxTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mailboxFaultDetected") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_mailboxFaultDetected(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "messagingEventNotify") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_messagingEventNotify(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "messagingNotificationTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpAppMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpAppMessagingManager_messagingNotificationTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "close") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_close(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "lock") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_lock(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unlock") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_unlock(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoAmount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_getInfoAmount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_getInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_setInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "openFolder") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_openFolder(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createFolder") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_createFolder(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "remove") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailbox_remove(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoAmount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getInfoAmount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_setInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "remove") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_remove(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getContent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMessage") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMessage_getContent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoAmount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getInfoAmount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setInfoProperties") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_setInfoProperties(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessage") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_putMessage(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessage") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_getMessage(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "close") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_close(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "remove") == 0
            && (!idlname || strcmp(idlname, "org/csapi/gms/IpMailboxFolder") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_gms_IpMailboxFolder_remove(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVPrPID") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getVPrPID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSlaID") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getSlaID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getStatus") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getStatus(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getProvisionedQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getValidityInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getValidityInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getPipeQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getPipeQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDsCodepoint") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrP") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrP_getDsCodepoint(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVPrPList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_getVPrPList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVPrP") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_getVPrP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVPrP") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_createVPrP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteVPrP") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpVPrN") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpVPrN_deleteVPrP(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getTemplate") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSMenu") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSMenu_getTemplate(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getTemplateList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSMenu") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSMenu_getTemplateList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getQoSMenu") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpConnectivityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpConnectivityManager_getQoSMenu(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getEnterpriseNetwork") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpConnectivityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpConnectivityManager_getEnterpriseNetwork(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getTemplateType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getTemplateType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDescription") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getDescription(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setSlaID") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setSlaID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getPipeQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getPipeQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setPipeQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setPipeQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getValidityInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getValidityInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setValidityInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setValidityInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setProvisionedQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_setProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getProvisionedQoSInfo") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getProvisionedQoSInfo(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDsCodepoint") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpQoSTemplate") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpQoSTemplate_getDsCodepoint(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSiteList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getSiteList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVPrN") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getVPrN(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSite") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetwork") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetwork_getSite(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSAPList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSiteID") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteID(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSiteLocation") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteLocation(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSiteDescription") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSiteDescription(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getIPSubnet") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getIPSubnet(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSAPIPSubnet") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cm/IpEnterpriseNetworkSite") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cm_IpEnterpriseNetworkSite_getSAPIPSubnet(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "retrieveTransactionHistoryRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "retrieveTransactionHistoryErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_retrieveTransactionHistoryErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceExpiryDateRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceExpiryDateErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryBalanceExpiryDateErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "updateBalanceRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_updateBalanceRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "updateBalanceErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_updateBalanceErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVoucherRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_createVoucherRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVoucherErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_createVoucherErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyVoucherRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_destroyVoucherRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyVoucherErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_destroyVoucherErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryVoucherRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryVoucherRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryVoucherErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryVoucherErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryUserVouchersRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryUserVouchersRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryUserVouchersErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAppAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAppAccountManager_queryUserVouchersErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryBalanceReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_changeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_getNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "retrieveTransactionHistoryReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_retrieveTransactionHistoryReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_enableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_disableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryBalanceExpiryDateReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryBalanceExpiryDateReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "updateBalanceReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_updateBalanceReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVoucherReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_createVoucherReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyVoucherReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_destroyVoucherReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryVoucherReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryVoucherReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryUserVouchersReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/am/IpAccountManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_am_IpAccountManager_queryUserVouchersReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditAmountErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditAmountErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditAmountRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditAmountRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditUnitErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditUnitErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditUnitRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_creditUnitRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitAmountErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitAmountErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitAmountRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitAmountRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitUnitErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitUnitErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitUnitRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_debitUnitRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditAmountErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditAmountErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditAmountRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditAmountRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditUnitErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditUnitErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditUnitRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directCreditUnitRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitAmountErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitAmountErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitAmountRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitAmountRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitUnitErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitUnitErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitUnitRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_directDebitUnitRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendLifeTimeErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendLifeTimeRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_extendLifeTimeRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "rateErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_rateErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "rateRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_rateRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveAmountErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveAmountErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveAmountRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveAmountRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveUnitErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveUnitErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveUnitRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_reserveUnitRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sessionEnded") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingSession_sessionEnded(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditAmountReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_creditAmountReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "creditUnitReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_creditUnitReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitAmountReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_debitAmountReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "debitUnitReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_debitUnitReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditAmountReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directCreditAmountReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directCreditUnitReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directCreditUnitReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitAmountReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directDebitAmountReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "directDebitUnitReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_directDebitUnitReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "extendLifeTimeReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_extendLifeTimeReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAmountLeft") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getAmountLeft(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getLifeTimeLeft") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getLifeTimeLeft(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getUnitLeft") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_getUnitLeft(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "rateReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_rateReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "release") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_release(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveAmountReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_reserveAmountReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reserveUnitReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingSession") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingSession_reserveUnitReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sessionAborted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingManager_sessionAborted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortMultipleChargingSessions") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpAppChargingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpAppChargingManager_abortMultipleChargingSessions(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createChargingSession") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingManager_createChargingSession(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createSplitChargingSession") == 0
            && (!idlname || strcmp(idlname, "org/csapi/cs/IpChargingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_cs_IpChargingManager_createSplitChargingSession(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "evalPolicyRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "evalPolicyErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpAppPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpAppPolicyDomain_evalPolicyErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "evalPolicy") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicy(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "evalPolicyReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_evalPolicyReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortEvalPolicyReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_abortEvalPolicyReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "generateEvent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_generateEvent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/evaluation/IpPolicyEvalManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_evaluation_IpPolicyEvalManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_getAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_setAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_getAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicy") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicy_setAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyIterator") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyIterator_getList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getParentRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepositoryCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepositoryIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getRepositoryIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConditionCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConditionIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getConditionIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_createAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_removeAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getActionCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getActionIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRepository") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRepository_getActionIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getParentGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getParentDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_createCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_removeCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConditionCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConditionIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_createAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeAction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_removeAction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getActionCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getActionIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setValidityPeriodConditionByName") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodConditionByName(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setValidityPeriodCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getValidityPeriodCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unsetValidityPeriodCondition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_unsetValidityPeriodCondition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setConditionList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setConditionList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getConditionList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getConditionList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setActionList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_setActionList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getActionList") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyRule") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyRule_getActionList(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_createDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_removeDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomainCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomainIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getDomainIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "findMatchingDomains") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_findMatchingDomains(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_createRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_removeRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepositoryCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRepositoryIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_getRepositoryIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "startTransaction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_startTransaction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "commitTransaction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_commitTransaction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "abortTransaction") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyManager_abortTransaction(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getParentGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_createGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_removeGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroupCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroupIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getGroupIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_createRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_removeRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRuleCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRuleIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyGroup") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyGroup_getRuleIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setRequiredAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setRequiredAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setOptionalAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_setOptionalAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRequiredAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getRequiredAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getOptionalAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getOptionalAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyEventDefinition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyEventDefinition_getParentDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyCondition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyCondition") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyCondition_getParentRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentRepository") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyAction") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRepository(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyAction") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyAction_getParentRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setInputVariables") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setInputVariables(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setOutputVariables") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setOutputVariables(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getInputVariables") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getInputVariables(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getOutputVariables") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getOutputVariables(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setGroupNames") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setGroupNames(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setPolicyRoles") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_setPolicyRoles(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroupNames") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getGroupNames(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getPolicyRoles") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getPolicyRoles(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicySignature") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicySignature_getParentDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getParentDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getParentDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeDomain") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeDomain(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomainCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getDomainIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getDomainIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroupCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getGroupIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getGroupIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeRule") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeRule(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRuleCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getRuleIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getRuleIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createEventDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createEventDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getEventDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeEventDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeEventDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getEventDefinitionCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getEventDefinitionIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getEventDefinitionIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVariableSet") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariableSet(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariableSet") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSet(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeVariableSet") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariableSet(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariableSetCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariableSetIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableSetIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createVariable") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createVariable(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setVariableValue") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_setVariableValue(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariableType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariableValue") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariableValue(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getVariable") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getVariable(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeVariable") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeVariable(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createSignature") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_createSignature(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSignature") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignature(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeSignature") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_removeSignature(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSignatureCount") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureCount(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getSignatureIterator") == 0
            && (!idlname || strcmp(idlname, "org/csapi/policy/provisioning/IpPolicyDomain") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_policy_provisioning_IpPolicyDomain_getSignatureIterator(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createGroupIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_createGroupIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteGroupIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_deleteGroupIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addToGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addToGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeFromGroup") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeFromGroup(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMembers") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listMembers(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isGroupIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_isGroupIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listGroupMembership") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listGroupMembership(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addAlias") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_addAlias(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeAliases") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_removeAliases(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAliases") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listAliases(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "lookupByAlias") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_lookupByAlias(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "associateTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_associateTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disassociateTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_disassociateTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listTypesOfIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_listTypesOfIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "hasType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_hasType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getIdentityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_getIdentityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setIdentityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityManagement_setIdentityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_createAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_deleteAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_enableCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disableCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listEnabledCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listEnabledCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAllCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listAllCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isCapableOf") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_isCapableOf(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "associateTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_associateTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disassociateTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_disassociateTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listTypesOfAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_listTypesOfAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "hasType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_hasType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAgentAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_getAgentAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAgentAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentManagement_setAgentAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "assignAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_assignAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unassignAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_unassignAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAssignedAgents") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgents(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAssociatedIdentitiesOfAgent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssociatedIdentitiesOfAgent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAssignedAgentsByCapability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listAssignedAgentsByCapability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listCapabilitiesOfIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_listCapabilitiesOfIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isIdentityCapableOf") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentAssignment") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentAssignment_isIdentityCapableOf(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createIdentityAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteIdentityAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getIdentityAttributeDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_getIdentityAttributeDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAllIdentityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listAllIdentityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createIdentityType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_createIdentityType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteIdentityType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_deleteIdentityType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listIdentityTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addIdentityTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_addIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeIdentityTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_removeIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listIdentityTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMIdentityTypeManagement_listIdentityTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAgentAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteAgentAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAgentAttributeDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_getAgentAttributeDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAllAgentAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAllAgentAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createAgentType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_createAgentType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteAgentType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_deleteAgentType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAgentTypes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addAgentTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_addAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeAgentTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_removeAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAgentTypeAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMAgentTypeManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMAgentTypeManagement_listAgentTypeAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCapabilityAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapabilityAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteCapabilityAttribute") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapabilityAttribute(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCapabilityAttributeDefinition") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_getCapabilityAttributeDefinition(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listAllCapabilityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listAllCapabilityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createCapability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_createCapability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteCapability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_deleteCapability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listCapabilities") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilities(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "addCapabilityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_addCapabilityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "removeCapabilityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_removeCapabilityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listCapabilityAttributes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilityAttributes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "assignCapabilitiesToType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_assignCapabilitiesToType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "unassignCapabilitiesFromType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_unassignCapabilitiesFromType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listCapabilitiesOfType") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMCapabilityManagement") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMCapabilityManagement_listCapabilitiesOfType(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAuthToken") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAuthToken(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "obtainInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_obtainInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_getAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/provisioning/IpPAMProvisioningManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_provisioning_IpPAMProvisioningManager_setAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setIdentityPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setIdentityPresenceExpiration") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_setIdentityPresenceExpiration(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getIdentityPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMIdentityPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMIdentityPresence_getIdentityPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAgentPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCapabilityPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAgentPresenceExpiration") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setAgentPresenceExpiration(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setCapabilityPresenceExpiration") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_setCapabilityPresenceExpiration(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAgentPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_getAgentPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getCapabilityPresence") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAgentPresence") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAgentPresence_getCapabilityPresence(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "computeAvailability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpAppPAMPreferenceCheck") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpAppPAMPreferenceCheck_computeAvailability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAvailability") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_getAvailability(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getPreference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_getPreference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setPreference") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMAvailability") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMAvailability_setPreference(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAuthToken") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAuthToken(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "obtainInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_obtainInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_getAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_setAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activateService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_activateService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deactivateService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_deactivateService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isActiveIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/access/IpPAMPresenceAvailabilityManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_access_IpPAMPresenceAvailabilityManager_isActiveIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "eventNotify") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpAppPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotify(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "eventNotifyErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpAppPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpAppPAMEventHandler_eventNotifyErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isRegistered") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_isRegistered(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "registerAppInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_registerAppInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "registerForEvent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_registerForEvent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deregisterAppInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_deregisterAppInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deregisterFromEvent") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventHandler") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventHandler_deregisterFromEvent(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAuthToken") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_getAuthToken(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "obtainInterface") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_obtainInterface(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_getAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setAccessControl") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_setAccessControl(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "activateService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_activateService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deactivateService") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_deactivateService(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "isActiveIdentity") == 0
            && (!idlname || strcmp(idlname, "org/csapi/pam/event/IpPAMEventManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_pam_event_IpPAMEventManager_isActiveIdentity(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "mailboxTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_mailboxTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "reportNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_reportNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "notificationsInterrupted") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsInterrupted(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "notificationsResumed") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_notificationsResumed(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "multiMediaMessagingTerminated") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_multiMediaMessagingTerminated(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateMultipleMailboxes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMailboxes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "terminateMultipleMultiMediaMessagingSessions") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessagingManager_terminateMultipleMultiMediaMessagingSessions(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "openMailbox") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMailbox(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "openMultiMediaMessaging") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_openMultiMediaMessaging(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_createNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "destroyNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_destroyNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "changeNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_changeNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getNextNotification") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_getNextNotification(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "enableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_enableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "disableNotifications") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessagingManager") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessagingManager_disableNotifications(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createFolderRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_createFolderRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createFolderErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_createFolderErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFoldersRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFoldersRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFoldersErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFoldersErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteFolderRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteFolderRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteFolderErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteFolderErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyFolderRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyFolderRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyFolderErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyFolderErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveFolderRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveFolderRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveFolderErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveFolderErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_putMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_putMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_copyMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_moveMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_deleteMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessagesRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessagesRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessagesErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessagesErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessageBodyPartsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessageBodyPartsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_listMessageBodyPartsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageBodyPartsRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageBodyPartsErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageBodyPartsErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageHeadersRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageHeadersErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageHeadersErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageContentRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageContentRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageContentErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageContentErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFullMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFullMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFullMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFullMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMailboxInfoPropertiesRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFolderInfoPropertiesRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageInfoPropertiesRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setMessageInfoPropertiesRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setMessageInfoPropertiesErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_setMessageInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMailboxInfoPropertiesErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMailboxInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFolderInfoPropertiesErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getFolderInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageInfoPropertiesErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMailbox_getMessageInfoPropertiesErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "close") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_close(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "createFolderReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_createFolderReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFoldersReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFoldersReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteFolderReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_deleteFolderReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyFolderReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_copyFolderReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveFolderReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_moveFolderReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "putMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_putMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "copyMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_copyMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "moveMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_moveMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "deleteMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_deleteMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessagesReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_listMessagesReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "listMessageBodyPartsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_listMessageBodyPartsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageBodyPartsReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageBodyPartsReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageHeadersReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageHeadersReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageContentReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageContentReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFullMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFullMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMailboxInfoPropertiesReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMailboxInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getFolderInfoPropertiesReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getFolderInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "getMessageInfoPropertiesReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_getMessageInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "setMessageInfoPropertiesReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMailbox") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMailbox_setMessageInfoPropertiesReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_sendMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "cancelMessageRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "cancelMessageErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_cancelMessageErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryStatusRes") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusRes(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryStatusErr") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_queryStatusErr(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "messageStatusReport") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageStatusReport(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "messageReceived") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpAppMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpAppMultiMediaMessaging_messageReceived(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "sendMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_sendMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "cancelMessageReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_cancelMessageReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "queryStatusReq") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_queryStatusReq(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        if (strcmp(operation, "close") == 0
            && (!idlname || strcmp(idlname, "org/csapi/mmm/IpMultiMediaMessaging") == 0)) {
           process_RequestOperation();  /* fill-up Request_Operation field & info column */
           tree = start_dissecting(tvb, pinfo, ptree, offset);
           decode_org_csapi_mmm_IpMultiMediaMessaging_close(tvb, pinfo, tree, offset, header, operation, stream_is_big_endian);
           return TRUE;
        }

        
        break;

    case CancelRequest:
    case LocateRequest:
    case LocateReply:
    case CloseConnection:
    case MessageError:
    case Fragment:
       return FALSE;      /* not handled yet */

    default:
       return FALSE;      /* not handled yet */

    }   /* switch */


    return FALSE;

}  /* End of main dissector  */



/* Register the protocol with Wireshark */

void proto_register_giop_parlay(void) {

   /* setup list of header fields */

   static hf_register_info hf[] = {
        /* field that indicates the currently ongoing request/reply exchange */
		{&hf_operationrequest, {"Request_Operation","giop-parlay.Request_Operation",FT_STRING,BASE_NONE,NULL,0x0,NULL,HFILL}},

      /* no fields yet */

   };

   /* setup protocol subtree array */

   static gint *ett[] = {
      &ett_parlay,
   };

   /* Register the protocol name and description */

   proto_parlay = proto_register_protocol("Parlay Dissector Using GIOP API" , "PARLAY", "giop-parlay" );

   proto_register_field_array(proto_parlay, hf, array_length(hf));

   proto_register_subtree_array(ett,array_length(ett));

}


/* register me as handler for these interfaces */

void proto_reg_handoff_giop_parlay(void) {


    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/IpService", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/am/IpAccountManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/am/IpAppAccountManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppConfCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpAppSubConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpConfCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/cccs/IpSubConfCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpAppCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpAppCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/gccs/IpCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpAppMultiMediaCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mmccs/IpMultiMediaStream", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppMultiPartyCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpAppMultiPartyCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpCallLeg", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpMultiPartyCall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cc/mpccs/IpMultiPartyCallControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpConnectivityManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpEnterpriseNetwork", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpEnterpriseNetworkSite", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpQoSMenu", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpQoSTemplate", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpVPrN", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cm/IpVPrP", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpAppChargingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpAppChargingSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpChargingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/cs/IpChargingSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpAppDataSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpAppDataSessionControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpDataSession", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/dsc/IpDataSessionControlManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAPILevelAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAccess", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpClientAPILevelAuthentication", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpClientAccess", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_access/trust_and_security/IpInitial", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/discovery/IpServiceDiscovery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpAppOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/integrity/IpOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/notification/IpAppEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/notification/IpEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/service_agreement/IpAppServiceAgreementManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_application/service_agreement/IpServiceAgreementManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/notification/IpClientEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/notification/IpEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpClientAppManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpEntOpAccountManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceContractManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileInfoQuery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_enterprise_operator/service_subscription/IpServiceProfileManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/discovery/IpFwServiceDiscovery", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpFwOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcFaultManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcHeartBeat", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcHeartBeatMgmt", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcLoadManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/integrity/IpSvcOAM", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/notification/IpFwEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/notification/IpSvcEventNotification", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/service_lifecycle/IpServiceInstanceLifecycleManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/fw/fw_service/service_registration/IpFwServiceRegistration", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpAppMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMailboxFolder", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMessage", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/gms/IpMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ub/IpAppUserBinding", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ub/IpUserBinding", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpAppTriggeredUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpAppUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpTriggeredUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ul/IpUserLocation", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ulc/IpAppUserLocationCamel", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ulc/IpUserLocationCamel", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ule/IpAppUserLocationEmergency", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/ule/IpUserLocationEmergency", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/us/IpAppUserStatus", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mm/us/IpUserStatus", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMultiMediaMessaging", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpAppMultiMediaMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMailbox", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMultiMediaMessaging", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/mmm/IpMultiMediaMessagingManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpAppPAMPreferenceCheck", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMAgentPresence", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMAvailability", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMIdentityPresence", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/access/IpPAMPresenceAvailabilityManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpAppPAMEventHandler", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpPAMEventHandler", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/event/IpPAMEventManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentAssignment", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMAgentTypeManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMCapabilityManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMIdentityManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMIdentityTypeManagement", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/pam/provisioning/IpPAMProvisioningManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/evaluation/IpAppPolicyDomain", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/evaluation/IpPolicyEvalManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicy", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyAction", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyCondition", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyDomain", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyEventDefinition", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyGroup", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyIterator", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyRepository", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicyRule", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/policy/provisioning/IpPolicySignature", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpAppExtendedTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpExtendedTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/termcap/IpTerminalCapabilities", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUI", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUIAdminManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUICall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpAppUIManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUI", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUIAdminManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUICall", proto_parlay );     /* explicit dissector */

    
    /* Register for Explicit Dissection */

    register_giop_user_module(dissect_parlay, "PARLAY", "org/csapi/ui/IpUIManager", proto_parlay );     /* explicit dissector */

    
    /* Register for Heuristic Dissection */

    register_giop_user(dissect_parlay, "PARLAY" ,proto_parlay);     /* heuristic dissector */


}

